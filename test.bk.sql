-- MySQL dump 10.13  Distrib 8.0.12, for macos10.13 (x86_64)
--
-- Host: localhost    Database: test
-- ------------------------------------------------------
-- Server version	8.0.12

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
 SET NAMES utf8mb4 ;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `article_entity`
--

DROP TABLE IF EXISTS `article_entity`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `article_entity` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `author` varchar(10) NOT NULL,
  `createdAt` varchar(255) NOT NULL,
  `updatedAt` varchar(255) DEFAULT NULL,
  `title` varchar(100) NOT NULL,
  `subtitle` varchar(150) DEFAULT NULL,
  `content` text NOT NULL,
  `isPublished` tinyint(4) NOT NULL,
  `isOriginal` tinyint(4) NOT NULL,
  `isDeleted` tinyint(4) NOT NULL DEFAULT '0',
  `category` varchar(255) NOT NULL,
  `userId` int(11) NOT NULL,
  `statisticsId` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `REL_2b807638ed95e29f29e74824c9` (`statisticsId`),
  KEY `FK_3b151817ce909c2ef790028096b` (`userId`),
  CONSTRAINT `FK_2b807638ed95e29f29e74824c93` FOREIGN KEY (`statisticsId`) REFERENCES `article_statistics_entity` (`id`),
  CONSTRAINT `FK_3b151817ce909c2ef790028096b` FOREIGN KEY (`userId`) REFERENCES `user_entity` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=77 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article_entity`
--

LOCK TABLES `article_entity` WRITE;
/*!40000 ALTER TABLE `article_entity` DISABLE KEYS */;
INSERT INTO `article_entity` VALUES (1,'山高路远','2018-07-06 23:39:25','','angular中的变更检测','','用过angularJs的同学应该都知道一个词叫脏检查，其实它就是angularJs的变更检测机制，也是经常被诟病的地方，这次我们来看看angular中的变更检测机制。\n\n## angular应用结构\n\nangular应用实质上就是一个组件树，如下图：\n\n![change_detection_01539753981565.jpeg](http://pghicsch6.bkt.clouddn.com/change_detection_01539753981565.jpeg)\n\n\n组件树上的某个节点的变化可能会影响其它节点的变化，也就是说其它节点需要知道如何对变化作出响应，这时就需要有相应的检测机制来检测变化。对于每个组件来说，都有一个检测器来检测组件上绑定的属性的变化。如下图：\n\n![change_detection_11539754012319.jpeg](http://pghicsch6.bkt.clouddn.com/change_detection_11539754012319.jpeg)\n\n\n{{todo.text}}就是绑定在组件上的属性，由Todo_ChangeDetector负责检测它的变化。另外检测器在检测组件变化时，是由根组件开始，采用深度优先的原则，检测各个组件状态的变化。angular并没有为双向数据绑定实现其独有的机制（当然双向绑定还是可以使用），因此并没有像angularJs的脏检查机制中的那个 digest 循环，angularJs中，为了避免脏检查掉入死循环的尴尬，还默认的设置了循环的次数（10次），而在angular中根本不存在循环检查。显然这种检测机制的变更除了性能上的优势外，还可以使系统变的更加稳定，更加可预测。\n\n默认情况下，变更检测会在所有的节点的发生，这听起来有点糟糕，实际并没有那么坏，况且这也是一种保守的做法，毕竟在javascript语言层面上我们并不能知道接收到的对象是否发生了变化，比如：\n\n```ts\n    function test(a) {\n        console.log(a.name);\n    }\n\n    test({name: \'a\'});\n\n    test({name: \'b\', age: 8});\n```\n\n对于test函数来说，每次运行时，它并不知道收到的对象和前一个是否还是一样（引用地址相同）的。尽管如此，我们还是可以通过绑定属性来获得这种变化，例如上面的例子中，test运行时可以知道 name 变化了，age也变化了。另外，如果使用不可变对象或者Observable时，也可以确定数据状态是否发生了变化。\n\n## 不可变对象\n\n如果一个组件仅仅依赖于它的输入属性，并且这些属性都是不可变对象，那么组件的变化仅仅只在输入属性发生变化时才发生。因此，在变更检测中就可以跳过这种组件，在变化未发生的时候，angular会禁用它的变更检测，变化发生后，再开启它的变更检测，如下图，灰色的组件代表了变更检测被禁用。\n\n![change_detection_21539754024610.jpeg](http://pghicsch6.bkt.clouddn.com/change_detection_21539754024610.jpeg)\n\n\n这样优势就很明显了，通过使用不可变对象我们可以组件变更检测次数大大减少。在angular中实现这一点很简单，只需要把变更检测的策略设置成OnPush。\n\n```ts\n    @Component({changeDetection:ChangeDetectionStrategy.OnPush})\n    class ImmutableTodoCmp {\n        todo:Todo;\n    }\n```\n\n值得注意的是，组件依然可以使用私有的可变对象，检测策略改变的仅仅是发生检测的时机，当检测发生时，私有的可变对象也会被检测。\n\n## Observable\n\n如果一个组件仅仅依赖于它的输入属性，并且这些属性是通过Observable来获取的话，那么变更检测只会在这些Observable上发出了值的时候才会发生。因此这种组件在变更检测中也可以被跳过，和使用不可变对象一样，先禁用，新的值到来时检测，检测完成再禁用。不同的是，使用不可变对象在变化发生时，检测必须由根组件开始向下遍历所有的组件，而使用Observable时并非如此。\n\n```ts\n    type ObservableTodo = Observable<todo>;\n    type ObservableTodos = Observable<todo>[];\n\n    // Todos组件\n    @Component({\n        selector:\'todos\',\n        <todo *ngFor=\"let t of todos\" todo=\"t\"></todo>\n    })\n    class ObservableTodosCmp {\n        todos:ObservableTodos; //...\n    }\n\n    //TODO组件\n    @Component({selector:\'todo\'})\n    class ObservableTodoCmp {\n        @Input() todo:ObservableTodo; //...\n    }\n```\n\ntodos组件只是保持了一个 Observable 数组的引用，它并不能感知到每一个Observable上的数据变化。变更检测系统要做的是，在todo   Observable上有值发出时，检测从根组件到Todo 组件上的变化。假设我们的应用中只使用 Observable，应用启动时首先检测各组件的状态：\n\n![change_detection_31539754046953.png](http://pghicsch6.bkt.clouddn.com/change_detection_31539754046953.png)\n\n\n通过第一次检查之后：\n\n![change_detection_41539754177705.png](http://pghicsch6.bkt.clouddn.com/change_detection_41539754177705.png)\n\n\n当第一个todo组件中的Observable 发出值时\n\n![change_detection_51539754193915.png](http://pghicsch6.bkt.clouddn.com/change_detection_51539754193915.png)\n\n\n当检测完成后，状态会恢复到 状态2\n![change_detection_41539754177705.png](http://pghicsch6.bkt.clouddn.com/change_detection_41539754177705.png)\n\nObservable 在复杂系统中可能导致状态间的级联更新，但这在angular中却不是问题，Observable发出事件时，只是标记从当前组件到根组件的路径以便下次检查，接着正常的检查机制执行，因此组件的更新顺序并不会受 Observable 的影响，所以使用 Observable 是一种很简单的优化方式。\n\n## 并非强制\n\n当然，我们并不需要在应用中都使用不可变对象和 Observable，事实上也不可能。最常见情形是混合使用它们，比如在一个普通组件中使用不可变对象的组件，在不可变对象组件中使用 Observable 组件，这在 angular 中都是允许的。\n\n## 总结\n\n1. angular应用实际就是一个大的响应式的系统。\n2. 变更检测机制从根结节点开始深度优先遍历所有结点。\n3. 和angularJs完成不同的是检测沿树状进行而非循环。\n4. 使用不可变对象或者Observable 时，可以跳过部分不必要的检测，只进行必要检测。\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',1,1),(2,'山高路远','2018-10-15 12:49:31','','Angular 重载当前路由','','之前有同学在群里问到过，为什么url已经变化了，但是页面却没有刷新，这个问题一般都会涉及到路由重载。这在angularJs里实现起来是比较直接的，只需要调用路由服务的reload方法就可以了。\n但是在angular里可能没有那么直接。\n\n## 糟糕的解决方案\n1. 跳出去，再跳回来。为了重载A页面，这种解决方式采用 A --> B --> A的方式使A页面重新加载。\'hack\'的味道非常浓重。\n2. 让浏览器刷新整个页面。这对于单页应用来讲实在是非常糟糕的方法，因为它会重新加载应用，如果应用比较大，加载时间过长，用户体验极差。\n\n## angular Style的解决方案\n其实在angular5.1版本中就可以通过onSameUrlNavigation解决这个问题，不幸的是官方的文档中并没有清楚的提到这个配置以及如何使用。下面我们来看下如何配置它。\n\n### 路由启动配置\n首先需要在项目的根路由，一般是app.routing.ts 或 app.routing.module.ts中，当然这得看你的项目是如何命名根路由的。onSameUrlNavigation的配置有2个可选值，\'ignore\' 和 \'reload\'。默认ignore，当路由请求被要求导航到当前的活动路由中时页面是不会reload的，因此不会发生任何改变的。我们希望的是reload，因此需要手动配置它的值为\'reload\'；\n```ts\n    const routes: Route[] = [...];\n    @ngModule({\n        imports: [RouterModule.forRoot(routes, {onSameUrlNavigation: ‘reload’})],\n        exports: [RouterModule],\n    })\n    export class AppRoutingModule.ts { }\n```\n值得注意的是，\'reload\'并不会真正的执行加载工作，它只是重新触发了路由上的events事件循环。\n\n### Route配置\n接下来要解决的是，这一系列的路由事件在何种情况下应该被触发，此时我们需要配置 runGuardsAndResolvers 选项，它有3个可选值。\n\n* paramsChange 只有当参数变化时才重新启动，例如 \'article/:id\'，参数指的就是这里的id。\n* paramsOrQueryParamsChange 当参数或查询参数变化时重新启动。例如：\'article/:category?limit=10，参数指 \'category\'，查询参数指\'limit\'；\n* always 无论何种情况都重新启动\n\n这里我们使用 \'paramsChange\'\n```ts\n    export const routes: Routes = [\n        {\n            path: \'article/:id\',\n            component: ArticleComponent,\n            runGuardsAndResolvers: \'paramsChange\',\n        }\n    ]\n```\n### 组件中处理路由事件\n路由上的配置完成后，我们需要在组件中处理路由上的事件，在特定的事件到达时执行需要的操作，如从后台加载数据等，路由上的事件很多，\'特定事件\'指的是你希望处理的事件。这里我们选择NavigationEnd事件\n```ts\n    export class ArticleComponent implement OnInit, OnDestroy {\n        subscription: Subscription;\n\n        constructor(private router: Router) { }\n\n        ngOnInit() {\n            this.subscription = this.router.events.pipe(\n                filter(event => event instanceOf NavigationEnd)\n            )\n            .subscribe(_ => {...}) // 执行业务操作\n        }\n\n        ngOnDestroy() {\n            this.subscription.unsubscribe(); // 不要忘记处理手动订阅\n        }\n    }\n````\nOK，到这里所有的工作就结束了，假如路由处于 \'article/2\'，业务逻辑需要在这里重新定位到 \'article/3\' 时，这下就不仅仅是url发生变化了，页面也会随之被更新。\n\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',1,2),(3,'山高路远','2018-07-24 08:35:01','','小心你的angular service','','angular中的服务是分离数据层和视图层的重要环节，也是提高代码复用，共享数据的重要工具，因此在项目中必须对创建的service有足够的信心，不能有丝毫差错。\n\n## 单例 service\n\nservice通常应该是单例模式，也就是说在整个应用中，同一个service应该只被创建一次，这对数据共享有着非常重要的意义。在angular中，除非你非常明确的想让某一个服务被创建多次，否则应该始终保持服务是单例。\n\n## 如何保证单例\n\nangular 6 中，最简单的办法就是在 Injectable 装饰器中添加属性 provideIn: \'root\'：\n\n```ts\n    @Injectable({ provideIn: \'root\'})\n    export class YourClassNameService { }\n```\n\n这是否能保证服务是单例呢？\n\n## 实验\n\n假设现在我们要创建一个服务，它继承自另一个服务，直接上图：\n![single_service_01539759872737.jpeg](http://pghicsch6.bkt.clouddn.com/single_service_01539759872737.jpeg)\n\n\n基本服务：\n\nconstructor 中的 console 帮助我们看清服务到底被创建了几次；另外注意，我们使用了 provideIn:\'root\'\n\n另一个服务继承自它：\n![single_service_11539759928991.png](http://pghicsch6.bkt.clouddn.com/single_service_11539759928991.png)\n\n\n接下来创建两个分别使用这两个服务的组件：\n![single_service_21539759952268.jpeg](http://pghicsch6.bkt.clouddn.com/single_service_21539759952268.jpeg)\n\n\nHelloComponent 中我们注入了 First服务，并且访问了它的person数据，但它本身没有person，而是继承了BaseService的 person。\n![single_service_31539760008300.jpeg](http://pghicsch6.bkt.clouddn.com/single_service_31539760008300.jpeg)\n\n\nChildComponent 中我们注入了 Base服务，并且访问它的person数据，同时在 ngOnInit 中调用服务的方法来改变person的名字。\n\n现在设置我们AppModule:\n![single_service_appmodule1539760244733.jpeg](http://pghicsch6.bkt.clouddn.com/single_service_appmodule1539760244733.jpeg)\n\n\n一切 Ok, 运行一下:\n![single_service_41539760277625.png](http://pghicsch6.bkt.clouddn.com/single_service_41539760277625.png)\n\n\n开始时，它们的数据都一样，显示如图：\n\n但是2秒过后\n![single_service_51539760286557.png](http://pghicsch6.bkt.clouddn.com/single_service_51539760286557.png)\n\n\n一个变了，另一个却没变，你肯定知道为什么了，BaserService被实例化了2次，如何验证？好在我们有log：\n![single_service_61539760307061.png](http://pghicsch6.bkt.clouddn.com/single_service_61539760307061.png)\n\n\n验证了我们的想法，FirstService 继承的那个 BaseService 和注入到 ChildComponent 的那个BaseService 并不是同一个对象。\n\n## 解决方案\n\n取消BaseService 的 Injectable装饰器，把它单纯的当作一个class来使用，同时在 appModule 的 providers中删除它。\n\n如果的更好的解决方案，敬请留言！\n\n文中使用的[demo](https://stackblitz.com/edit/angular-ystrfc?file=src%2Fapp%2Fbase.service.ts)\n\n\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',1,3),(4,'山高路远','2018-09-03 12:55:08','','自定义操作符','','rxjs提供了数量众多的操作符帮助我们解决大多数的场景，但实际项目中仍然有可能需要造一些‘轮子’以适应更加具体的需求。从5.5版本开始pipe操作符的加入使用这些需求变的异常简单。\n\n## 自定义操作符的方法\n\n[官方仓库](https://github.com/ReactiveX/rxjs/blob/master/doc/operator-creation.md)里提供了两种方法，第一种通过扩展Observable类实现，第二种通过纯函数的方式实现。比较推荐的是第二种方法，因为比较简单，你不需要去弄明白lift方法是在做什么，也不需要担心原型上的方法被重写等，函数嘛，接收输入，产生输出，仅此而已。\n\n在自定义操作符之前，必须谨记的是：\n\n- 操作符的返回值必须是Observable类型，没有第二种可能。\n- 一定要管理好subscription，这样订阅生产的资源才能及时被释放。\n- 处理好异常，因为你无法保证用户传进来的逻辑永远都可以正确运行。\n- 在合适的时间，处理好其它你需要释放的资源，例如流结时，或抛出错误时。\n\n### 尝试一下\n假设我们需要一个操作符，它可以把输入的字符串的字母都变在大写，代码如下：\n\n```js\n    const toUpperCase = () => source => Observable.create(subscriber => {\n        const subscription = source.subscribe(\n            value => { subscriber.next(value.toUpperCase()) },\n            err =>  { subscriber.error(err) },\n            () => { subscriber.complete()}\n        )\n        return subscription;\n    });\n```\n\n非常简单，我们定义了一个高阶函数，它的入参为空，返回的函数的行参source就是即将被传入的observable，在这个函数内部我们使用Observable的静态方法create创建出了一条流，当然也可以写成：\n\n```js\n    new Observable(subscribe => { ... });\n```\n\ncreate方法实际就是去 new 了一个Observable。之后我们订阅了输入流，并将这些值传递给订阅者。先看一下效果：\n\n```js\n    const obs = of(\'hello\');\n\n    obs.pipe(toUpperCase()).subscribe(console.log); // HELLO\n```\n\n但是我们似乎忘记了什么，toUpperCase方法是字符串的方法，如果流上传入的值类型不是string，这个地方势必报错，要处理这个错误也很简单：\n\n```js\n    const toUpperCase = () => source => Observable.create(subscriber => {\n        const subscription = source.subscribe(\n            value => {\n                try {\n                    subscriber.next(value.toUpperCase());\n                }catch(error) {\n                    subscriber.error(\'Some error occur: \' + err.toString());\n                }\n            },\n            err =>  { subscriber.error(err) },\n            () => { subscriber.complete()}\n        )\n        return subscription;\n    });\n```\n\n这下我们把逻辑放在了try catch块中，一旦发生错误，通过error通知，将错误信息传送出去。\n\n```js\n    const obs = of(3);\n\n    obs.pipe(toUpperCase()).subscribe(console.log, console.error); // Some error occur: TypeError: value.toUpperCase is not a function\n```\n\n这下错误被捕获了。如果再仔细想一下，source本身就是Observable，我们大可借助rxjs内置的操作符来简化一下代码\n\n```js\n    const toUpperCase = () => source => source.pipe(\n        map(value => value.toUpperCase()),\n        catchError(err => of(\'Some error occur: \' + err.toString()))\n    );\n```\n\n### 加入自定义逻辑\n\n上面的操作符缺少的一个最关键的东西，就是操作符的行参，这里能过另一个操作符演示，流程和前面是一模一样的。\n\n```js\n    const obs = of(5);\n\n    const calculate = fn => source => source.pipe(\n        map(value => fn(value)),\n        catchError(err => of(err))\n    );\n\n    obs.pipe(calculate(value => Math.pow(value, 2))).subscribe(console.log); // 输出 25;\n```\n\n代码很简单，但是用途却不小，这下你可以把项目中大量需要重复的逻辑抽象成一个操作符，在需要的时候丢到pipe里，赶快试一下吧。\n\n\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"rxjs\"]',1,4),(5,'山高路远','2018-09-23 18:55:32','','Decorator简介','','angular中经常可以见过@Module({...})，@Component({})，@Injectable()等等，也许你知道它的名字---装饰器，但装饰器究竟是什么，有什么用处，可以解决哪些问题？\n\n## 装饰器的本质\n装饰器实质是上就是一段功能函数，但不同于普通函数的是，它的执行是在代码的编译阶段，而普通函数的执行需要等到代码运行时，使装饰器时实质是在对编程语言进行编程，因此它属于元编程的一种思想。\n\n## 装饰器出现的原因\n在ES5中，对于装饰器的需求并不那么迫切，然而随着ES6中类和继承的出现，多个类往往需要实现相同的功能，此时就需要有一种更方便的方法来解决这个问题，例如在angular中，每一个组件都是一个类，但作为组件来说，这些类都具体一个相同的功能，那就是连接数据和视图，所以出现了@Component()装饰器。\n装饰器提案的出发点：旨在通过声明式的语法，在代码的设计阶段对javascript的类，对象的属性进行修饰，以对代码功能进行增强。它接受需要装饰的目标作为参数，如类，属性，参数等，通过函数的运行给目标增加新的功能。\n装饰器的使用方法，在需要装饰的目标前使用‘@’符号作为前缀，调用写好的装饰器函数。例如：\n```ts\n    @Injectable() // MyService 这个类可被angular实例化后注入到其它类中\n    export class MyService { \n\n    }\n\n    {\n        @Input() name = \'\'; // name 属性可以作为输入属性来接收外部输入的数据。\n    }\n```\n可见使用装饰器后，可以使用很明确的表达出代码的意图，因此除了给代码添加额外的功能外，它还有一定的注解作用。\n\n## 装饰器的使用\n前面的示例其实已经展示了，而且在angular中时刻都会见到装饰器，下面大致演示下修饰的过程：\n\n### 装饰属性\n假设我们有一个类\n```ts\n    Class Cat {\n        breed() { return `The breed of this cat is ${this.type}`; }\n    }\n```\n转换成ES5的结果\n```js\n    function Cat() { }\n\n    Object.defineProperty(Cat.prototype, \'breed\', {\n        value: someCustomFunction,\n        enumerable: false,\n        configurable: true,\n        writable: true,\n    });\n```\n假如我们想改变属性的特性，例如把bread方法变为不可写，即writable变为false，我们需要实现下面这个函数：\n```js\n    function readonly(target, key ,descriptor) {\n        descriptor.writable = false;\n        return descriptor;\n    }\n```\n前面说过，装饰器在代码的编译阶段进行，此时我们需要做的就是告诉编译器，在生成这个属性的时候需要调用一下我们写好的函数：\n```js\n    Class Cat {\n        @readonly // 注意这里没有括号\n        breed() { return `The breed of this cat is ${this.type}`; }\n    }\n```\n括号呢？这貌似和angular中见到的不一样啊，实际上，装饰器就是一个函数，因此，你可以想象在angular中Input, Injectable等这些装饰器应该是一个高阶函数，它执行的结果必定是返回一个函数，这个函数在编译阶段交给编译器执行。有兴趣的可以看下源码，如Input装饰器：packages/core/src/metadata/directives.ts 第807行，代码运行后返回了一个叫 PropDecorator的内部函数。\n\n当装饰器被加上后，在编译阶段就有机会来修改属性的特性，过程大致如下：\n```js\n    let descriptor = {\n        value: someCustomFunction,\n        enumerable: false,\n        configurable: true,\n        writable: true,\n    }\n\n    descriptor = readonly(Cat.prototype, \'breed\', descriptor) || descriptor;\n    Object.defineProperty(Cat.prototype, \'breed\', descriptor);\n```\n代码运行后，如果尝试去修改这个方法，就会报错：\n```js\n    const tom = new Cat();\n\n    tom.breed = function() { console.log(this.breed); } // Exception: Attempt to assign to readonly property\n```\n### 装饰类\n装饰类的过程和装饰属性大致相似，所要用的道具也基本相同，装饰器函数运行时接收的第一个参数就是要装饰的目标类。\n```js\n    // 需要装饰的类\n    Class SuperMan() { }\n\n    // 需要添加的能力\n    function AddAbility(target) {\n        target.fly = true;\n        return target;\n    }\n```\n使用装饰器\n```ts\n    @AddAbility\n    Class SuperMan() { }\n\n    const superMan1 = new SuperMan();\n\n    console.log(superMan1.fly) // true;\n```\n如果想更加灵活，我们只需要将装饰器函数修改为高阶函数：\n```ts\n    function AddAbility(ability) {\n        return function(target) {\n            target[ability] = true;\n            return target;\n        }\n    }\n\n    // 使用新的装饰器\n\n    @AddAbility(\'biubiubiu\')\n    Class SuperMan { }\n\n    const superMan2 = new SuperMan();\n\n    console.log(superMan2.biubiubiu) // true;\n```\n现在你可能思考一下在项目中哪些地方可以使用装饰器，纵然语言的发展会带来更多的新特性，如果这些新特性可以使用编程体验更回愉快，为何不尝试使用一下呢。\n\n\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\",\"javascript\"]',1,5),(6,'山高路远','2018-09-13 21:11:09','','为什么angular会抛出ExpressionChangedAfterItHasBeenCheckedError错误','','程序运行难免会出错，忘了哪会大神说的作为程序员首先要学会和错误做朋友。ts的到来让angular避免了很多错误，但仍有一些错误是会经常遇到的，ExpressionChangedAfterItHasBeenCheckedError这个错误相信大多数写angular的同学都遇到过，今天我们就来聊一下它。\n\n## 它不是bug\n首先需要说明的一点是，这个错误并不是因为angular或者你的应用有bug了，它和can\'t read property of undefined 这种错误的性质不同，我们可以把它视为一种预警。angular作为一种mvc框架，不管mvc还是mv啥东西吧，总之它有model和view这两层，保证数据模型可以正确的同步到视图是非常重要的，而这个错误就是在向我们预警----应用的数据模型和视图之间可能没有同步。\n\n## 变更检测操作\n要同步数据模型和视图，必然要进行变更检测，angular应用实质上是一棵组件树，组件的变化可能引起其它组件发生变化，变化发生时angular对组件树的检测是有一定顺序和规则的：\n\n1. 更新所有绑定属性的子组件或子指令。\n2. 调用所有的子组件或子指令的ngOnInit，ngOnChanges，ngDoCheck钩子函数。\n3. 更新当前组件的DOM。\n4. 接下来在每一个子组件上运行以上检测过程。\n5. 在每一个子组件或指令上调用ngAfterViewInit钩子函数。\n   \n这一过程完成后，angular会把检测到的值存储起来(保存在component 实例的oldValues属性上)，接下来angular进入下一次检测循环，对比当前值和之前保存过的值：\n\n1. 检查传给子组件的值和当前组件上将要进行更新的值是否相同。\n2. 检查用于更新DOM元素的值是否与现在用于更新这些元素的值相同。\n3. 在所有子组件上重复上面的检查。\n\n需要注意的是，这个检查过程只会发生在开发环境中。\n\n## 代码说话\n假设有一个父组件A，它有2个属性 name 和 text，同时有一个子组件B，B组件的某个数据来自于A组件的text属性。\n```ts\n    @Component({\n        selector: \'a-comp\',\n        template: `\n            <span>{{name}}</span>\n            <b-comp [text]=\"text\"></b-comp>\n        `\n    })\n    export class AComponent {\n        name = \'I am A component\';\n        text = \'A message for the child component\';\n    }\n```\n想像一下检测过程，首先检查A组件，第一步先检查绑定了的属性，即text，此时它的值是 A message for the child component，把它传给B组件并将其保存下来：\n```ts\n    view.oldValues[0] = \'A message for the child component\';\n```\n第二步，调用钩子函数：ngOnInit，ngOnChanges，ngDoCheck；\n\n第三步，更新A组件的DOM，对模板上的表达式进行求值，这个时候name的值是 I am A component。将其保存起来：\n```ts\n    view.oldValues[1] = \'I am A component\';\n```\n第四步，在B组件上同样执行上面的过程。\n\n第五步，当B结束以上过程后，当前的检测循环就结束了。调用ngAfterViewInit钩子。\n\n如果此时在开发环境中将会进行上面列出的第二个检测循环。试想一下，如果在A组件把text传给B组件后，text的值因为某些原因又发生了变化(假设变成了updated text)，那么在跑第二个循环的时候就尴尬了:\n```ts\n    AComponentView.instance.text === view.oldValues[0]; // false\n    \'A message for the child component\' === \'updated text\'; // false\n```\n此时主角登场：ExpressionChangedAfterItHasBeenCheckedError。\n\n对于第三步来说也一样，假设第三步完成后name的值变成了 updated name：\n```ts\n    AComponentView.instance.name === view.oldValues[1]; // false\n    \'I am A component\' === \'updated name\'; // false\n```\n这个错误同样会抛出。\n\n## 如何引发值变化\n\n引发值变化的罪魁祸首一定是子组件或指令。实验一下：\n```ts\n    export class BComponent {\n        @Input() text;\n\n        constructor(private parent: AComponent) {}\n\n        ngOnInit() {\n            this.parent.text = \'updated text\';\n        }\n    }\n```\n运行的结果如我们所愿\n\n    Error: ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. \n    Previous value: \'A message for the child component\'. Current value: \'updated text\'.\n    \n![expression_error_01539762848519.jpeg](http://pghicsch6.bkt.clouddn.com/expression_error_01539762848519.jpeg)\n\n接下来如法炮制，只不过这次我们改变的是name属性\n```ts\n    export class BComponent {\n        @Input() text;\n\n        constructor(private parent: AComponent) {}\n\n        ngOnInit() {\n            this.parent.name = \'updated name\';\n        }\n    }\n```\n然而并没有任何错误。\n![expression_error_11539762928360.jpeg](http://pghicsch6.bkt.clouddn.com/expression_error_11539762928360.jpeg)\n\n此时我们回顾下前面说的检测过种会发现：ngOnInit的执行是先于DOM更新的，这就是原因所在。假如我们将代码改成下面这样：\n```ts\n    export class BComponent {\n        @Input() text;\n\n        constructor(private parent: AComponent) {}\n\n        ngAfterViewInit() {\n            this.parent.name = \'updated name\';\n        }\n    }\n```\n这下得偿所愿：\n\n    AppComponent.ngfactory.js:8 ERROR Error: ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked.\n    Previous value: \'I am A component\'. Current value: \'updated name\'.\n![expression_error_21539762943841.jpeg](http://pghicsch6.bkt.clouddn.com/expression_error_21539762943841.jpeg)\n\n\n当然实际项目中的情况更加复杂，导致值变更的原因可能间接的来自于某一个服务或者Observable，但根本原因如上所述，这里归纳了几种情况：\n1. 服务共享，子组件和父组件共同引用了同一个服务，子组件通过改变服务上的某个值间接的影响到了父组件上的值。\n![expression_error_31539763033584.jpeg](http://pghicsch6.bkt.clouddn.com/expression_error_31539763033584.jpeg)\n\n![expression_error_51539763045696.jpeg](http://pghicsch6.bkt.clouddn.com/expression_error_51539763045696.jpeg)\n\n![expression_error_41539763041422.jpeg](http://pghicsch6.bkt.clouddn.com/expression_error_41539763041422.jpeg)\n\n2. 父子组件之间的事件传递，子组件发出一个事件，父组件监听这个事件后改变了某个值，而这个值又通过Input传递给了子组件。\n![expression_error_61539763120004.jpeg](http://pghicsch6.bkt.clouddn.com/expression_error_61539763120004.jpeg)\n\n![expression_error_71539763126647.jpeg](http://pghicsch6.bkt.clouddn.com/expression_error_71539763126647.jpeg)\n\n3. 动态生成组件，这种情况大多情况下是由DOM引发，也就是之前描述的第二种发生错误的情况。\n\n## 如何修复\n\nangular在错误信息中已经给出了提示\n\n    Expression has changed after it was checked. Previous value:… Has it been created in a change detection hook ?\n注意看最后一句。这在解决动态生成组件时引发此错误时尤为适用，此时建议将相关逻辑放置在ngOnInit钩子中。\n\n除此之外，还有异步更新，最典型的就是使用setTimeout\n```ts\n    export class BComponent {\n        @Input() text;\n\n        constructor(private parent: AComponent) {}\n\n        ngAfterViewInit() {\n            setTimeout(() => {\n                this.parent.name = \'updated name\';\n            },0);\n        }\n    }\n```\n强制angular进行检测：\n```ts\n    export class AppComponent {\n        name = \'I am A component\';\n        text = \'A message for the child component\';\n\n        constructor(private cd: ChangeDetectorRef) {\n        }\n\n        ngAfterViewInit() {\n            this.cd.detectChanges();\n        }\n    }\n```\n后面这两种其实根本不能称之为解决方案，它们只是让的应用看起来没有问题而已，Hack的味道非常浓重。\n\n最佳解决方案：重新设计你的代码逻辑。\n\n\n\n\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',1,6),(7,'山高路远','2018-08-26 22:59:57','','angular中的懒加载和预加载','','实际的项目中，业务可能被化分在不同的模块中，随着项目的发展，模块可能越来越多，有些模块的的代码可能非常宠大，此时我们希望这些模块只在必要的时候，或者用户可能需要的时候再加载进来，这样可以大大提高应用的速度。\n\n## 懒加载的场景\n\n应用在启动时，有些模块可能根本就用不上，比如在一个商场系统中，用户打开首页时，只需要向用户展示商品，支付模块此时根本没用，因此对于支付模块就可以使用懒加载。\n\n- 优点：使用懒加载后，只加载必须的模块，因此首次加载的包体积大大减小，这样就可以加快应用的启动速度。\n- 缺点：或者说懒加载还是不能解决的是，如果某一个懒加载的模块体积过大，当加载时还是可能发生加载速度慢的情况，用户的页面被阻塞，体验下降。\n\n可见，懒加载解决了请求额外资源导致的性能消耗，加载速度过慢的问题。\n\n## 预加载的场景\n\n当应用启动后，后续功能可能会被使用到，因此在用户可以使用基础的功能后，再去加载可能使用到的模块，比如前述中的支付模块。这样一旦用户需要对某个商品付费时，支付模块可以立即使用页无需等待。\n\n通过预加载，可以弥补懒加载中的缺点，应用基本功能可用后在后台加载那些体积较大，加载耗时较长的模块。\n\n## 代码实现\n\n以商场系统为例，假设我们有以下几个模块\n\n- AppModule: 应用的根模块，angular脚手出来的项目都有这么一个模块，作为整个项目的根模块，启动应用，进行全局配置等。\n- HomeModule: 应用主页模块，应用启动后就需要展示的模块。\n- BookModule: 应用内的一个和书籍相关的模块，只有当用户查看此部分内容时才加载，需要懒加载。\n- AuthModule: 用户登录，注册等功能所处的模块，需要预加载。\n- PayModule: 应用的支付模块，所有和支付相关的功能都在此模块内，体积较大，需要预加载。\n\n### AppModule\n\n在AppModule中导入我们定义好的AppRoutingModule。\n\n```ts\n    import { HomeComponent } from \'./home/home.component\';\n\n    @NgModule({\n        ...\n        imports: [\n            ...\n            HomeModule,\n            AppRoutingModule,\n            ...\n        ]\n        ...\n    })\n    export class AppModule { }\n```\n\nAppRoutingModule里定义项目的根路由。\n\n```ts\n    import { RouterModule, Routes } from \'@angular/router\';\n    import { HomeComponent } from \'./home/home.component\';\n\n    const appRoutes: Routes = [\n        { path: \'home\', component: HomeComponent },\n        { path: \'book\', loadChildren: \'./book/book.module#BookModule\' },\n        { path: \'pay\', loadChildren: \'./pay/pay.module#PayModule\' },\n        { path: \'auth\', loadChildren: \'./auth/auth.module#AuthModule\' },\n        { path: \'\', redirectTo: \'/home\', pathMatch: \'full\' },\n    ];\n\n    @NgModule({\n        imports: [\n            RouterModule.forRoot(appRoutes),\n        ],\n        exports: [\n            RouterModule,\n        ],\n    })\n    export class AppRoutingModule { }\n```\n\n在AppModule中直接导入了HomeModule，因此HomeModule在应用启动时就会加载进来。\n在AppRoutingModule中我们配置了路由规则，home没什么说的，直接把用户导向到主页，对应的HomeComponent在HomeModule中被声明和导出。\nbook，pay，auth这三个模块都使用了懒加载，写法就像上面那样，和直接加载的模块最大的区别是不声明具体的组件，而是使用loadChildren来指导路由加载所需的模块，在其它模块内再次配置模块的子路由。\n最后一个空路由，重定向路由，没有提供路径时定向到主页。\n\n### 添加预加载策略\n\n目前为止这些代码和预加载还没有发生任何关系，我们来加上：\n\n```ts\n    import { PreloadAllModules } from \'@angular/routes\';\n\n    RouterModule.forRoot(\n        appRoutes,\n        {preloadingStrategy: PreloadAllModules}\n    )\n```\n\n在这里，我们告诉angular,预加载使用的策略是：预加载所有的懒加载模块。显然，这不是我们想要的，既然 angular 需要一个预加载的策略，我们来看一下这个策略。\n\n```ts\n    export declare class PreloadAllModules implements PreloadingStrategy {\n        preload(route: Route, fn: () => Observable<any>): Observable<any>;\n    }\n```\n\n从这个声明文件上看，这个策略实现了 PreloadingStrategy 接口，声明文件中很容易找到，就在这个声明的上面：\n\n```ts\n    export declare abstract class PreloadingStrategy {\n        abstract preload(route: Route, fn: () => Observable<any>): Observable<any>;\n    }\n```\n\nOk，这下明白了，要改写预加载策略，我们只需要提供这么一个类，同时实现 PreloadingStrategy 接口（这里把类作为接口使用了）。\n\n### 自定义预加载策略\n\n首先在路由设置上加个属性\n\n```ts\n    ...\n    { path: \'pay\', loadChildren: \'./pay/pay.module#PayModule\', data: { preload: true} },\n    { path: \'auth\', loadChildren: \'./auth/auth.module#AuthModule\', data: { preload: true} },\n    ...\n```\n\n然后实现自定义的预加载策略\n\n```ts\n    @Injectable()\n    export class SelectivePreloadingStrategyService implements PreloadingStrategy {\n        constructor() { }\n\n        preload(route: Route, load: () => Observable<any>): Observable<any> {\n            if (route.data && route.data[\'preload\']) {\n                return load();\n            } else {\n                return of(null);\n            }\n        }\n    }\n```\n\n在AppModule的providers中加入这个策略\n\n```ts\n    ...\n    providers: [SelectivePreloadingStrategyService],\n    ...\n```\n\n需要预加载的模块，我们返回了load方法调用的结果，不需要预加载时简单的返回一个发出null的Observable。如果深究这里的load方法和route是怎么回事，可以看一下angular的源码部分。源码位置：packages/router/src/router_preloader.ts\n\n修改RoutingModule上的预加载策略：\n\n```ts\n    import { SelectivePreloadingStrategyService } from \'./providers/selective.preloading.strategy.ts\';\n\n    RouterModule.forRoot(\n        appRoutes,\n        {preloadingStrategy: SelectivePreloadingStrategyService}\n    )\n```\n\n现在，只有auth和pay两个模块可以被预加载进来，而book模块只有在用户访问这个模块的相关页面时才加载。\n\n当然还有个问题，pay模块体积较大，我们还想推迟它的加载时间，因为实际情况可能是只有当用户登录以后才可以使用支付功能，那么这个时候我们就要预判用户是否有登录的可能性，假定用户导航到了登录页面后我们认为有可能登录，此时我们只要改造加载策略，修改配置就可以了。\n\n此时不能把预加载的条件写死在配置中：\n\n```ts\n    ...\n    { path: \'pay\', loadChildren: \'./pay/pay.module#PayModule\' }, // 删除data\n    ...\n```\n\n在策略的preload函数中添加一些额外的条件：\n\n```ts\n    preload(route: Route, load: () => Observable<any>): Observable<any> {\n        if (route.data && route.data[\'preload\'] || location.href.includes.(\'auth\') ) { // 如果当前的href中有auth时，再加载payModule。\n            return load();\n        } else {\n            return of(null);\n        }\n    }\n```\n\n当然新加入的条件可能不够严谨，你当然可以设置另外的条件，或者通过注入其它服务来提供需要的条件，只要记得需要预加载时返回 load()，否则返回of(null)就可以了。\n\n\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',1,7),(8,'山高路远','2018-07-29 18:44:04','','ES6中promise的实现原理','','这个很早以前写的，今天看群里有人问关于promise的问题，在这里重新发一下。偷懒的同学可以直接拉到最后有完整的代码。\n\n顾名思义，promise中文意思就是承诺，也就是现在实现不了将来·····，但是将来这玩意谁说的准呢。就像你去泡妞，你可能许下各种诺言，但能不能实现，完全取决于你这人靠不靠谱。好在计算机不是人，不是人，不是人，····正因为不是人，所以它许下的承诺，它就一定会给你一个结果。 等待承诺实现的过程中很漫长，所以你可以做一些其它的事情，没必要老是堵在这一条道上，也就是异步。打个比方，你打电话给饭店老板叫了个外卖，老板告诉你，10分钟后送过去，也就是说老板给了你一个承诺，于是你等啊等，这中间又去上了个厕所，玩了会手机······，这就是异步，老板给的承诺并没有妨碍你干其它的事情。OK，扯淡结束。\n\n## promise这妞有啥好\n\n为了实现异步，一般要设置一个回调函数\n```js\nsetTimeout(function(){\nconsole.log(1);\nsetTimeout(function(){\nconsole.log(2);\nsetTimeout(function(){\nconsole.log(3);\nsetTimeout(function(){\nconsole.log(4);\nsetTimeout(function(){\nconsole.log(5);\n},500)\n},400)\n},300)\n},200)\n},100);\n```\n······有没有一种想死的感觉！ promise最大优势就是第一消灭了这种回调地狱，第二增加了错误捕获，像下面这种，\n```js\npromise.then(function (response) {\n//do something;\n}, function (reason) {\n//get error\n}).then(function (response) {\n//do something;\n}, function (reason) {\n//get error\n}).then(function (response) {\n//do something;\n}, function (reason) {\n//get error\n});\n```\n如果不做错误处理则更清晰\n```js\npromise.then(function (response) {\n//do something;\n}).then(function (response) {\n//do something;\n}).then(function (response) {\n//do something;\n}).then(function (response) {\n//do something;\n});\n```\n它使得异步的代码看起来像是在同步执行，大大增强了代码的可读性。\n美中不足的是你得写一堆的.then(function(){},function(){})，但是和回调地狱相比，忍了。\n在ES7中会有号称是异步的终极解决方案，async和await，那是后话。\n\n## 这妞性格怎么样\n\n前面说了，计算机不是人，所以它许下的承诺，它一定会给你一个结果，不管这个承诺的结果是接受还是拒绝。\n所以，第一，promise一定会返回一个结果。\n第二，这个结果是不可逆的，你只能接受，本质是因为promise的状态不可逆，一旦它变成了resolve或者reject，你休想再让你变成pending，否则，它要会说话，肯定回你的只有一个字，滚！\n第三、promise的结果什么时候返回，你说了不算，你去泡妞的时候，妞也不一定当场就答应你吧，或许想个三、五天也说不定，这个主动权不是掌握在你手中的。\n第四、ES6的promise执行过程中，你是无法获得执行的进度的，到底它现在是pending还是resolve，还是reject。就好像妞和她的闺蜜探讨要不要接受你，你是打听不到的。当然并不是完全不能，例如angularjs的$q实现一个notify方法，可以获取到执行进度的通知。\n最后说一点儿你的权力，你能决定的是在什么时候去取promise的结果，也就是调用then方法的时间，就好像你每天追着妞问，你想好没有······，妞这个时候会有三种回答，一是答应你，二是拒绝你，三是还得再想想，XXXX时候再告诉你····，也就说这TMD又是一个承诺·····。\n咳、咳，现在开始必须严肃点，毕竟技术是一件严肃的事情。\n\n## 漂亮的妞，是个男人就会有想法\n\n说白了，promise就是一个对象，一个只能通过then方法来取得它上面的值的对象。\n在es6中，你只要大喊一句，妞，给我个承诺，它就会给你一个promise，就像下面这样：\n```js\nvar promise = new Promise(function(resolve,reject){\n//do something;\n})\n```\n然后你就可以调用它的then方法去取值，那么从这个角度看，这个构造函数一定是返回了一个带有then方法的对象。另外还有状态，状态的变化不可逆。再加上些其它的方法，如all、catch···，不过不要着急，我们一步一步来意淫出这个漂亮的妞····\n\n通常情况，我们使用回调一个函数内执行另外一个函数：\n```js\nfunction doSomething(callback){\nconsole.log(\"do something\");\ncallback();\n}\ndoSomething(function(){\nconsole.log(\"a\");\n});\n```\n但是在使用promise时，我们是用then方法去取结果，而promise就是个对象，那么上面的代码看起来应该这样写：\n```js\nfunction doSomething(){\n	console.log(\"a\");\n	return {\n		then: function(callback){\n				var value = 1;\n				callback(value);\n			}\n		}\n}\ndoSomething().then(function(res){\nconsole.log(res);\n});\n```\n在这里，我们调用dosomething函数时，返回了一个带有then方法的对象，然后在then方法回调中去执行，现在看来是不是有那么点样子了，时刻记得两件事，对象， then方法。\n\n在ES6中Promise是一个构造函数，这简单，给这个dosomething换个名字，\n```js\nfunction Promise(){\n	this.then = function(callback){\n	var value = 1;\n	callback(value);\n	}\n}\n```\n在实例化promise的时候，要传一个函数进去，这也简单\n```js\nfunction Promise(fn){\n	this.then = function(callback){\n	callback();\n	}\n}\n```\n实例化传入的函数fn中，下文中的fn都是指代这个匿名函数，你会传入2个参数，一个叫resolve，另一个叫reject，为了简单起见，我们不考虑reject，它的道理和resolve是一样的。那么就像这样：\n```js\nvar promise = new Promise(function(resolve){\n	var value = 1;\n	resolve(value);\n})\n```\n即然传了一个fn函数进去，那么在实例化过程中，这个函数一定会在某个时刻执行。执行时，它又会接收到一个参数resolve，这个resolve一定是一个函数，这点从上面就可以很明显的看出来，resolve在实例化时执行了，而且接收到了一个参数，在这里是变量value。那么Promise函数内部很可能是这样：\n```js\nfunction Promise(fn){\n    function resolve(value){\n    }\n    this.then = function (onResolved) {\n    };\n    fn(resolve);\n}\n```\n为了看起来更直接，这里我们把调用then方法传的第一个函数就叫做onResolved，那么接下来我们应该考虑在实例化的时候，还有什么事情要做，在then方法的回调函数中我们希望得到promise的值，这个值是在fn函数调用后被resolve函数运算后得到的，最终要在onResolved函数中拿到，也就是说，我们必须在resolve中将这个值传递给onResolved，迂回一下：\n```js\nfunction Promise(fn) {\n    var callback = null;\n    function resolve(value) {\n    	callback(value);\n    }\n    this.then = function(onResolved) {\n    	callback = onResolved;\n    };\n    fn(resolve);\n}\n```\n但是这里有一个问题，就是我们调用resolve方法时，还没有调用过then方法，因此callbak是null，浏览器报错：callback is not a function，这里hack下，让resolve方法的执行在then之后。\n```js\nfunction Promise(fn) {\n    var callback = null;\n    function resolve(value) {\n        setTimeout(function(){\n            callback(value);\n        },0)\n    }\n    this.then = function(onResolved) {\n    	callback = onResolved;\n    };\n    fn(resolve);\n}\n```\n执行一下，\n```js\nvar promise = new Promise(function(res){\n        var value = 2;\n        res(2);\n    });\n    promise.then(function(res){\n    console.log(res);\n})\n```\nOK，成功的输出。目前为止，promise的轮廓算是被我们意淫出来了。\n\npromise是有状态的，而且状态不可逆，同样的为了简单起见，我先来搞定从pending变到resolved，那么rejected也一样。仔细想下，执行了resolve方法后可以得到一个resolved状态的值，那么必然在resolve方法中会去改变promise的状态，并且得到这个值，那么代码貌似应该这样写：\n```js\nfunction Promise(fn) {\n    var state = \'pending\';\n    function resolve(newValue) {\n        state = \'resolved\';\n        callback(newValue);\n    }\n    this.then = function(onResolved) {\n    	callback = onResolved;\n    };\n    fn(resolve);\n}\n```\n这里我们先把setTimeout这家伙给干掉了，因为我们加入了状态，也就意味我们是想通过状态的变化来知道能不能得到值，那么问题来了，我们不知道状态啥时候变，就像你不知道你要泡的妞啥时候答应你一样，你只能追问，万一妞没想好，她很可能再给你一个承诺，就是那个该死的XXX时候再告诉你，不过好歹她也算给了你一个等待的机会，而我们现在要做的就是创造这么个机会。\n```js\nfunction Promise(fn) {\n    var state = \'pending\';\n    var value;\n    var deferred;\n    function resolve(newValue) {\n        value = newValue;\n        state = \'resolved\';\n        if(deferred) {\n        	handle(deferred);\n        }\n    }\n    function handle(onResolved) {\n        if(state === \'pending\') {\n        deferred = onResolved;\n        return;\n    }\n    onResolved(value);\n    }\n    this.then = function(onResolved) {\n    	handle(onResolved);\n    };\n    fn(resolve);\n}\n```\n这里引入了另外一个函数handle，至此可以说promise的最关键的东西我们已经看到了，妞的身材逐渐显现。又扯远了·····\n仔细看下除了handle我们还引入两个变量value和deferred，先从最简单的来：\nvalue的作用很简单，在构造函数内它是一个全局变量，起到一个桥梁作用，就是为了在handle函数内能取到newValue的值，而newValue就是fn函数里的那个结果。\nhandle我们估且可以认为它是妞的一个管家，它会去替我们询问妞有没有想好，也就是去判断当前这个承诺的状态，再决定怎么做。\ndeferred我们估且可以这样理解，它就是管家的一个记事本，你隔三差五的去问，它老人家不得记下来，如果一不小心忘了，那就悲催了。\n这下不管是同步还是异步，我们随时可以在then方法中去取值，如果值没有被resolve，也就是说状态没发生变化，deferred将给我们记录下这件事，等到resolve的那个时间点把值传给then方法中那个回调函数，onResolved。\n在这里请默念一百遍handle，defer，再接着往下看，我保证他们会让你困惑。\n\n回到最初，为什么要用promise，想想回调地狱，再想想promise是怎么解决的，那就是then方法链式调用。\n能够实现链式调用，也就是说then方法返回的值也一定是个promise，这样你才能.then，.then的一直写下去。废话不说，没代码说个毛：\n```js\nfunction Promise(fn) {\n    var state = \'pending\';\n    var value;\n    var deferred = null;\n\n    function resolve(newValue) {\n        value = newValue;\n        state = \'resolved\';\n        if(deferred) {\n        	handle(deferred);\n        }\n    }\n\n    function handle(handler) {\n        if(state === \'pending\') {\n        deferred = handler;\n        return;\n    }\n    if(!handler.onResolved) {\n        handler.resolve(value);\n        return;\n    }\n    var ret = handler.onResolved(value);\n    	handler.resolve(ret);\n    }\n\n    this.then = function(onResolved) {\n            return new Promise(function(resolve) {\n            handle({\n                onResolved: onResolved,\n                resolve: resolve\n            });\n    	});\n	};\n	fn(resolve);\n}\n```\n这下换个姿势，我们先啃硬货。我们让then方法返回了一个promise，而且这个promise实例化时传入的函数里调用了handle函数，传入了一个对象，onResolved很显然就是then方法里第一个函数，没什么可说的。关键是这handle和resolve是哪个？思考1分钟。\n这里我们用setTimeout简单模拟一个异步，拿一个then看下，发生了什么：\n```js\nvar promise = new Promise(function(resolve){\n    setTimeout(function(){\n    	resolve(1);\n    },3000)\n});\n\npromise.then(function(res){\n	console.log(res);\n})\n```\n首先我们去new一个promise，在实例化的过程中，调用了传进的那个函数，3秒后才能执行到resolve，紧接着调用了它的then方法，这个时候由于promise的状态没变，肯定取不到值，好在then方法会返回个promise，于是又执行了一次promise的实例化过程。这里无法回避的就是作用域的问题，这个关系到handle函数执行在哪个环境中，参数的到底从哪个地方获取到，另外就是强大的闭包。相关知识不解释。\n为了看的更清楚，我们加入一些标记，到chrome的控制台中调试下:\n```js\nlet count = 0;\n\nfunction Promise(fn) {\n    let state = \'pending\';\n    let value;\n    let deferred = null;\n    let scope = ++count;\n\n    function resolve(newValue) {\n        value = newValue;\n        state = \'resolved\';\n        console.log(\'resolve: I am in \' + scope);\n        if(deferred) {\n        	handle(deferred);\n        }\n    }\n\n    function handle(handler) {\n        console.log(\'handle: I am in \' + scope);\n        if(state === \'pending\') {\n        deferred = handler;\n        return;\n    }\n\n    if(!handler.onResolved) {\n    	handler.resolve(value);\n    	return;\n    }\n    const ret = handler.onResolved(value);\n    	handler.resolve(ret);\n    }\n    this.then = function(onResolved) {\n        console.log(\'then: I am in \' + scope);\n        return new Promise(function(resolve) {\n            console.log(\'then promise: I am in \' + scope);\n            handle({\n                onResolved: onResolved,\n                resolve: resolve,\n            });\n        });\n    };\n    fn(resolve);\n}\n\nconst promise = new Promise(function(resolve) {\n    setTimeout(function() {\n    	resolve(1);\n    }, 3000);\n});\n\npromise.then(function(res) {\n	console.log(res);\n}\n```\n## 看一看到底发生了什么\n\n上面代码加入的scope是为了监视作用域的变化，以间接反应出我们调用handle时是在哪个作用域上查询到的，此外我们还需要监视state和deferred的变化。\n主要看then调用之后，废话不说上图：\n\n1. 在执行then方法的时候，scope=1，state，deferred不可用。由于模拟了异步，这个时候第一个promise的resolve方法并没有执行，这里模拟了3秒，实际情况下，比如ajax取数据时，我们并不知道这个准确的时间，就像开始时说的，这妞啥时候答应你，主动权不在你手中，由妞说了算。\n![promise_1](https://image-static.segmentfault.com/246/028/2460286437-5826eaf7e86dc)\n\n2. 接下来去实例化then方法创建的这个promise，scope = 2，state=”pending”，deferred=null。\n![promise_2](https://image-static.segmentfault.com/979/952/979952274-5826eb1d2379a)\n\n3. 在实例化完成之后，此时去执行fn函数，scope=1，state，deferred不可用。\n![promise_3](https://image-static.segmentfault.com/243/978/2439787213-5826eb491e609)\n\n第一，函数的作用域是在定义时就生成的，而不是在调用的时候。第二个promise定义的时候，是在第一个promise作用域上，这样即使它被return了出去，由于闭包的特性，仍读取的是第一个作用域上值，所以这里的handle必定是第一个promise的handle。而resolve则不同，它是作为行参传递了进来，所以这里的resolve是第二个promise的resolve。\n\n4. 进入handle时，scope = 1，state =” pending”，deferred保存了参数。\n![promise_4](https://image-static.segmentfault.com/153/005/1530052229-5826eb5b65669)\n\n5. 3秒时间到，第一个promise里的resolve被执行了，也就是说拿到了结果，这时候，scope=1,state = “resolved”，deferred保存着刚才传进来的那个对象，再次进入handle函数。\n![promise_5](https://image-static.segmentfault.com/314/752/3147522148-5826eb6481cb0)\n\n6. scope=1,state = “resolved”，deferred求值为true，因此肯定会继续执行。下面添加的这段代码在这里也就很清楚了，假如then方法中没有传进来的onResolved函数，这里的value将直接交给下一个then方法中的onResolved函数使用，避免一些无聊的人像这样去调用：\npromise.then().then().then(function(res){console.log(res);})\n正常人都会让value在onResolved函数中接收到， 然后ret就是onResolved函数的返回值， 这里没有return回的值， 所以ret肯定是undefined。\n![promise_6](https: //image-static.segmentfault.com/270/692/2706927490-5826eb6f41aa6)\n\n7. scope=2,state = “resolved”，deferred=null。这里的resolve是第个promise的resolve，所以定义的时候就是在作用域2上，如果后面再调用then方法，生成新的promise，这时就会将undefined作为第二个promise的值传递下去。\n![promise_7](https://image-static.segmentfault.com/419/457/4194574283-5826eb7fe7842)\n\n这里再次强调一下，handle方法和deferred是核心所在，其背后的精髓无非还是作用域和闭包的巧妙设计。变量的读取必定先从自身所处作用域开始，如果自身作用域上读不到，才会一级一级向上访问。\n\n## 完整代码：\n```js\nfunction Promise(fn) {\n    var state = \'pending\';\n    var value;\n    let deferred;\n    this.then = function (onResolved, onRejected) {\n        return new Promise(function (resolve, reject) {\n            handle({\n                onResolved: onResolved,\n                onRejected: onRejected,\n                resolve: resolve,\n                reject: reject,\n            });\n        });\n    };\n    function resolve(newValue) {\n        if (newValue && typeof newValue.then === \'function\') {\n            newValue.then(resolve);\n            return;\n    	}\n        state = \'resolved\';\n        value = newValue;\n        if (deferred) {\n            handle(deferred);\n        }\n    }\n    function reject(reason) {\n        state = \'rejected\';\n        value = reason;\n        if (deferred) {\n        	handle(deferred);\n        }\n    }\n\n    function handle(handler) {\n        if (state === \'pending\') {\n            deferred = handler;\n            return;\n    	}\n        var handlerCallback;\n        if (state === \'resolved\') {\n            handlerCallback = handler.onResolved;\n        }else {\n            handlerCallback = handler.onRejected;\n        }\n        if (!handlerCallback) {\n            if (state === \'resolved\') {\n                handler.resolve(value);\n            } else {\n                handler.reject(value);\n            }\n            return;\n        }\n        var ret;\n        try {\n        	ret = handlerCallback(value);\n        }catch (e) {\n        	handler.reject(e);return;\n        }\n        handler.resolve(ret);\n    }\n    fn(resolve);\n}\n```\n情况基本和resolve是一样的，resolve函数中加的if判断只为了对付返回值是promise的情况下仍然可以通过后续的then方法取到值，handle中的try/catch块的加入使得可以捕获到promise及then方法回调中的错误，至于then方法的改变，看不懂的话自宫吧，你是女人当我没说。\n\n## 其它\n当然这个promise只是一个基本的实现，依然很脆弱，但基本上可以说有了一轮廓，剩下的部位各位看官自己添加，比如promise的all ，race，catch等。某种意义上说，它们也只是then方法的语法糖。 http://www.mattgreer.org/articles/promises-in-wicked-detail/，本文代码出处，有兴趣的同学可以看下。\n\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"javascript\"]',1,8),(9,'山高路远','2018-05-20 18:28:05','','从命令式到响应式（一）','Rxjs系列','\n\nangular2中内置了rxjs，虽然框架本身并没有强制开发者使用响应式风格来组织代码，但是从框架开发团队的角度可以看出他们必然是认同这种编程风格的。rxjs本质是基于函数式编程的响应式风格的库，函数式相对于面向对象来说更加抽象，响应式的思维方式和命令式的思考方式又截然相反，所以导致大多数的开发者开始接触时觉得非常不适应，认为门槛太高，其实不然，只要思维方式能转变，你会觉得响应式是更加顺其自然的事情。响应式涉及的知识点很多，这篇文章只能做到管中窥豹，让大家在感性上对它有一个认识。\n\n## 面向对象 vs 函数式\n\n抽象层级不同：简单来说，面向对象抽象了物，而函数式抽象了行为。最简单的例子: \n```js\n    function Person(name, age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    Person.prototype.ageAfterYears = function(years) {\n        console.log(this.age + years);\n    }\n\n    var john = new Person(\'John\', 18);\n```\n面向对象的方式\n```js\n    john.ageAfterYears(5) // 23;\n```\n函数式的方式：\n```js\n    function getAge(baseAge) {\n        return (obj) => console.log(obj.age + baseAge);\n    }\n\n    const ageAfterYears = getAge(5);\n\n    ageAfterYears(john); // 23；\n```\n这段代码很简单，但足以说明问题，使用面向对象的方式时，我们直接调用person类的方法，计算出实例的年龄，我们会很在乎这个对象上是否提供这么一个方法。但使用函数式时，ageAfterYears函数并不在乎传入的对对象上是否有那个方法，只需要传入的对象有上age属性，它就可以得一个结果，我们更在乎的是这种行为是否正确，例如计算函数的行为是加，而不是减，或者其它。\n\n## 响应式 vs 命令式\n\n这两种编程风格的思维方式是完全相反的。假设一个生产手机的过程，第一种方式是工人 A 先处理零件，然后交给工人 B， 工人 B 接收后生产出一台手机。第二种方式是工人 B 主动去找工人 A 索取生产手机所要的零件，然后生产一台完整的手机，这两种方式就对应的响应式和命令式。可以看出，响应式更适合于流水线式的生产，因为它节省了大量的沟通成本。尤其重要的一点是工人 B的行为是‘懒’的，它不会主动的去争取任务，而是一直在等待任务的到来。在程序中，数据就是我们产品的零件，因此也适合这种流水线式的处理。假如我们需要控制用户在一个按钮上每秒最多只能点击一次，看下面这段代码：\n\n使用命令式:\n```js\n    var count = 0;\n\n    var rate = 1000;\n\n    var lastClick = Date.now() - rate;\n\n    var button = document.querySelector(\'button\');\n\n    button.addEventListener(\'click\', () => {\n        if(Date.now() - lastClick >= rate) {\n            console.log(`Clicked ${++count} timers`);\n            lastClick = Date.now();\n        }\n    });\n```\n使用响应式：\n```js\n    var button = button.querySelector(\'button\');\n\n    Rx.Observable.fromEvent(button, \'click\')\n        .throttleTime(1000)\n        .scan(count => count + 1, 0)\n        .subscribe(count => console.log(`Click ${count} times`));\n```\n从代码上可以看出，命令式的代码量更大，而响应式的只有区区几行，当然你可以说这是因为使用了rxjs封装的库，但更为重要的是在命令式的代码中变量的数量更多，尤为糟糕的是这些变量相对于主逻辑来说处于‘全局‘的位置，而javascript中全局变量是魔鬼，我们不得不随时小心这些定时炸弹。\n\n上面已经提到过响应式的处理过程是’懒‘的，除此之外，它的优点可以概括如下\n\n1. 所有数据处理的过程使用操作符的全部都是纯函数，它们只是单纯的接收输入，产生输出，并不会对输入的值做出任何改变。\n\n2. rxjs实现的 Observable 是一个可以产生多个值序列，是一个 push 类型的系统，这和 pull 类型的函数系统有很大的不同。\n\n## push vs pull\n\n这里使用 pull 和 push 来描述值的生产者和消费者之间是如何发生联系的，它们是两种完全不同的协议。\n\n在pull的系统中，值的消费决定什么时间从生产者上获取数据，生产者本身并不关心数据什么时间分发给消费者。\n\n每一个javascript函数都可以看作一个 pull 类型的系统。函数可以产生值，但这是通过调用者主动调用函数，函数运行产生出值返回给调用者的方式进行的，所以可以理解为调用者主动去函数上拉取了值。\n\nES2015中介绍另外两种 pull 类型的系统，generator函数 和 iterator。对于它们来讲，遍历器对象的 next 方法可以视作值的消费者，通过iterator.next()可以获取到多个值。\n\n|      | Producer                 | Consumer               |\n| ---- | :----------------------: | ---------------------: |\n| pull | 被动：当被调用时产生值   | 主动：决定何时发起调用 |\n| push | 主动：按自身的设置产生值 | 被动：响应接收到的值   |\n\n在push的系统中，生产者决定什么时候发送值给消费者，消费者并不知道什么时候可以接收到值。\n\nES6中的 promise 就是一个非常典型的 push 系统，promise 将 resolve 的结果传递给注册在它内部的回调函数，这与普通的函数有很大的不同，回调函数何时可以接收到数据完全取决于 promise 什么时间向它传递数据。\n\nrxjs的 Observable 也是一种 push 类型的系统，一个 Observable 可以产生多个值，然后推送给它的订阅者。\n\n* Function 是一个 ‘懒’ 的求值过程，只有在被调用时它才会同步的返回一个值给调用者。\n* generator 也是一个 ’懒‘ 的求值过种，在遍历的过程中同步的返回0个或多个值给调用者。\n* Promise 经过运算后可能产生一个值，当然也可能产生一个错误。\n* Observable 也是一个‘懒’的求值过程，当它被订阅后可以同步或者异步的产生出0个或者无限多个值给调用者，这个过程将一直持续到订阅被取消或者流结束。\n\n今天先写到这里，没有过多的代码， 更没有涉及到angular中如何去应用响应式，个人认为写代码的过程其实不难，难的是思维方式的转换，希望能从文字的描述上给大家一点启发。\n\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"rxjs\"]',1,9),(10,'山高路远','2018-06-03 14:23:26','','从命令式到响应式（二）','Rxjs系列','知识点回顾，上次主要说了函数式和面向对象，命令式和响应式，push 系统和 pull 系统的差别。在编程范式，风格之外，设计模式也是在程序设计中时时刻刻都在使用的东西，今天主要就讨论一下设计模式这个东西。\n\n## 什么是设计模式\n\n模式是一种可复用的解决方案，它有三大好处：\n\n1. 模式是已经得到验证的解决方案，因此我们可以在适合的场景中放心的使用它。\n2. 模式很容易被复用，是一种立即可用的解决方案，而且可以对其适当的修改以满足个性化的需求。\n3. 模式富有表达力，它通常有很良好的结构及已经设置好的表达方案的词汇，可以非常轻松的表达出程序员的意图。\n\n其实我们每天都在接触模式，从最简单的facade（外观模式，jQuery，lodash为代表）到 singleton，再到MVC，模式可以说无处不再，当然还有rxjs中使用观察者模式等。有模式，就有反模式，既然模式可以带来好处，相应的反模式就会带来坏处，在javaScript中，以下就是我们经常见到的反模式：\n\n1. 在全局上下文中定义大量的变量来污染全局命名空间。这里的全局我们应该以相对的思维考虑，而不是特指window对象。例如：在angularjs 中一个controller 作为封闭的作用域，对于它内部定义的各种变量来说，这个作用域就是全局的，写过angularjs的同学应该遇到过，在一个controller中定义很多的变量，然后随着功能的增加，越来越难以维护。\n2. 修改类的原型，尤其是Object类，比修改更过份的是直接替换。\n3. 以内联的形式使用javaScript。\n4. 给setTimeout 或 setInterval传递字符串而不是函数，这会触发内部 eval 的执行。\n\n## 响应式中的设计模式\n\n### 观察者模式\n\n在这种模式中，一个对象维持一系列依赖于它的对象，将有关的状态变更自动的通知给它们。当我们不再希望某个特定的观察者获取注册目标的对象时，它可以从目标的观察者列表中移除。代码如下：\n\n观察者列表类，我们利用这个类来维护观察者的增删改查\n```js\n    class ObserverList {\n        constructor() { };\n\n        list = [];\n\n        add(observer) {\n            this.list.push(observer);\n        }\n\n        count() {\n            return this.list.length;\n        }\n\n        get(index) {\n            if(index > -1 && index < this.list.length) {\n                return this.list[index];\n            }else {\n                return null;\n            }\n        }\n\n        indexOf(observer, startIndex) {\n            let i = startIndex;\n\n            let pointer = -1;\n\n            while( i< this.list.length) {\n                if(this.list[i] === observer) {\n                    pointer = i;\n                }\n                i++;\n            }\n\n            return pointer;\n        }\n\n        removeIndexAt(index) {\n            if(index === 0) {\n                this.list.shift();\n            }else if (index === this.list.length - 1) {\n                this.list.pop();\n            }\n        }\n    }\n```\n主题类，利用这个类来维护一个观察目标，使用观察者列表类来维护其自己的观察者，通过观察者提供的接口向外发送目标上发生的变化。\n```js\n    class Subject {\n        constructor() {\n            this.observers = new ObserverList();\n        }\n\n        addObserver(observer) {\n            this.observers.add(observer);\n        }\n\n        removeObserver(observer) {\n            this.observers.removeIndexAt(this.observers.indexOf(observer, 0));\n        }\n\n        notify(context) {\n            const count = this.observers.count();\n\n            for(let i = 0; i< count; i++) {\n                this.observers.get(i).update(context);\n            }\n        }\n    }\n```\n观察者类，为目标发生变化时需要获得通知的对象提供一个更新接口。\n```js\n    class Observer {\n        constructor() { }\n\n        update() {\n          // 获取通知的接口， 不同的observe 可以针对性的设置更新逻辑\n        }\n    }\n```\n然后我们就可以利用定义好的这些类，实现一些功能，例如，一个主checkbox，当它的状态变化时通知页面上其它的checkbox检查状态，代码大致如下：\n\nHTML代码\n```HTML\n    <button id=\"button\">Add Observer</button>\n    <input id=\"box\" type=\"checkbox\">\n    <div id=\"container\"></div>\n```\njavaScript代码\n```js\n    const box = document.getElementById(\'box\');\n    const btn = document.getElementById(\'button\');\n    const container = document.getElementById(\'container\');\n\n    // 工具函数\n    function extend(source, target) {\n        for (let key in source) {\n            target[key] = source[key];\n        }\n    }\n\n    // 利用工具函数来扩展DOM元素\n    extend(new Subject(), box);\n\n    // 将点击事件通知给观察者\n    box.onclick = function {\n        box.notify(box.checked);\n    }\n\n    btn.onclick = function addNewObserver() {\n        const check = document.createElement(\'input\');\n\n        check.type = \'checkbox\';\n\n        extend(new Observer(), check);\n\n        // 重写自定义的更新行为\n        check.update = (value) => this.checked = value;\n\n        // 为subject的观察者列表中添加新的观察者\n        box.addObserver(check);\n\n        // 将观察者附加到容器上\n        container.appendChild(check);\n    }\n```\n## 发布/订阅模式\n\n观察者模式要求希望接收通知的观察者必须订阅内容改变的事件，而发布/订阅模式中添加了一个事件通道，此通道介于订阅者和发布者之间，这样设置的主要目的是促进发布者和接收者之间的松散耦合，避免订阅者和发布者产和直接的联系，如图：\n```bash\nObserver Pattern\n          /----<--Subscribe--<--\\\n        Subject             Observer\n          \\--->--Fire Event-->--/\n\nPublish/Subscribe Pattern\n                                        /----<--Subscribe--<--\\\n        Publisher-->--publish-->---Event Channel         Subscriber\n                                        \\--->---fire event-->--/\n```\n在实际的应用中， 这两种模式可以结合使用，它们都鼓励开发者思考应用程序之间不同部分之间的关系，将应用程序分解为更小，更松散耦合的块以提高代码的复用。\n\n## 这两种模式的优缺点\n\n优点\n\n1. 只需要维护各个对象之间的通信接口的一致性，而无需紧密耦合。\n2. 观察者和目标之间可以建立起一种动态的关系，这提供了很大的灵活性，在程序的各部分紧密耦合时，要实现这种动态关系是非常不容易的。\n\n缺点\n\n1. 在发布/订阅模式中，由于解耦了发布者和订阅者，有时会难以保证程序按照我们的预期进行。例如，发布者会假设有人在订阅它们，当订阅者发生错误后，由于系统的解耦，发布者并不会看到这一点。\n2. 订阅者之间非常无视彼此的存在，对于变换发布者产生的成本视而不见，由于它们之间动态的关系，难以跟踪依赖更新。\n\nrxjs的实现就是建立在这两种模式的基础之上，预先要了解的基本知识通过这两篇基本上介绍完了，当然都是走马观花式的，基中任何一个点拿出来都可以长篇大论，各位如有兴趣可以找资料深入研究。\n\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"rxjs\"]',1,10),(11,'山高路远','2018-06-15 19:02:59','','从命令式到响应式（三）','Rxjs系列','上次说了响应式中使用的设计模式，今天我们主要来看rxjs中实现响应式的三大件，Observable, subject 和 Subscription;\n\n## Observable--可观测序列\n\n在第一节中介绍过 push 类型的系统和 pull 类型的系统，它们都可以产生值：\n\n|      | 产生单个值 | 产生多个值 |\n| ---- | :--------: | ---------: |\n| pull | function   | iterator   |\n| push | promise    | ？         |\n\n在es6中promise已经被原生支持了，但是并没有一种原生的方法来实现push系统中产生多个值，于是Observable添补了这一空白。\n```js\n    // 创建一个observable\n    const observable = Rx.Observable.create(function(observer) {\n        observer.next(1);\n        observer.next(2);\n        observer.next(3);\n        setTimeout(() => {\n            observer.next(4);\n            observer.complete();\n        },1000);\n    });\n\n    console.log(\'just before subscribe\');\n\n    // 通过 subscribe 方法来获取 observable 上的值\n    observable.subscribe({\n        next: x => console.log(\'got value \' + x),\n        error: err => console.error(\'something wrong occurred: \' + err),\n        complete: () => console.log(\'done\'),\n    });\n\n    console.log(\'just after subscribe);\n```\n这段代码执行后将会得到如下结果：\n\n    just before subscribe\n    got value 1\n    got value 2\n    got value 3\n    just after subscribe\n    got value 4\n    done\n\n从结果可以看出通过一次订阅我们就可以拿到一个observable上所有推送过来的值，另外请注意看输出的顺序，1，2，3在 after之前，而4在after之后，这说明observable发出的值不一定都是异步或都是同步，什么时间可以取到值完全取决于以哪种方式发出。\n\n上面代码中还有几个地方可能需要解释下：\n\n- create：它实际上是Observable 的构造函数的别名，换句话说可以用 new Rx.Observable(...) 取代。\n- observer：观察者，顾名思义，这个东西就是我们上一节讲过的观察者模式中的观察者，这里它是由rxjs负责给我们传递进来，实际上它就是我们在subscribe()中传入的那个对象。它有三个方法，next用来通知下一个值是什么；error 方法在 observable 上产生错误时通知观察者，complete方法用来通知观察者当前流上的值已经发射完毕。\n- subscribe: 它就是Observable类提供的方法，用来获取可观测序列上发出的值，接收一观察者作为参数。当然，上面的代码可以写成:\n```js\n    observable.subscribe(\n        x => console.log(\'got value \' + x),\n        err => console.error(\'something wrong occurred: \' + err),\n        () => console.log(\'done\'),\n    );\n```\n第一个参数处理next通知，第二个参数处理error通知，第三个参数处理complete通知，我们还可以选择是否处理 error 通知和 complete通知，也就是说第二，三个参数还可以省略。当然rxjs内部还会把我们传入的参数处理成那个观察者对象。\n\n以上代码中，我们实际已完成了observable 的创建（通过create），订阅（通过subscribe），执行（调用 next 和 complete）过程。除此之外在我们不需要订阅时，观察者还应该能够安全的退出。\n\n## subscription\n\n这就是我们取消订阅时的所要用到的东西，上面的订阅代码完整的写法应该是：\n```js\n    const subscription = observable.subscribe({...});\n```\n它是我们订阅一个observable后获取到的，也就是subscribe方法的返回值，它上面有3个重要的方法。\n\n- unsubscribe 顾名思义，取消订阅。\n- add 添加另外一个subscription。在有多个subscription时我们可以通过这个方法将它们都链接起来，这样取消时只需要取消一个，而不必调用每个 subscription 的unsubscribe 方法。\n- remove 当然能添加必然可以移除。从当前的 subscription 上移除另一个 subscription\n```js\n    // 取消之前的订阅\n    subscription.unsubscribe();\n\n    //重新订阅之前我们创建的observable，取消订阅时逐个调用它们的unsubscribe方法\n    const subscription1 = observable.subscribe({...});\n    const subscription2 = observable.subscribe({...});\n    const subscription3 = observable.subscribe({...});\n\n    //重新订阅之前我们创建的observable，取消订阅时只调用一次unsubscribe\n    const sub$$ = observable.subscribe({...})\n        .add(observable.subscribe({...}))\n        .add(observable.subscribe({...}));\n```\n## subject\n\n它即是observable，也是observer，所以它即可以被 subscribe 又可以通过next，error，complete发射值。下面的例子中，我们给 Subject 添加了两个观察者，然后给它添加一些值：\n```js\n    const subject = new Rx.Subject();\n\n    subject.subscribe({\n        next: v => console.log(\'observerA: \' + v)\n    });\n\n    subject.subscribe({\n        next: v => console.log(\'observerB: \' + v)\n    });\n\n    subject.next(1);\n    subject.next(2);\n```\n执行后的输出：\n\n    observerA: 1\n    observerB: 1\n    observerA: 2\n    observerB: 2\n    \n由于 Subject 也是一个 Observer ，所以你可以把他传递给一个 Observable 的subscribe方法：\n```js\n    var subject = new Rx.Subject();\n\n    subject.subscribe({\n        next: v => console.log(\'observerA: \' + v)\n    });\n\n    subject.subscribe({\n        next: v => console.log(\'observerB: \' + v)\n    });\n\n    var observable = Rx.Observable.from([1,2,3]);\n\n    observable.subscribe(subject); // 通过 Subject 来订阅这条 Observable\n```\n执行后输出：\n\n    observerA: 1\n    observerB: 1\n    observerA: 2\n    observerB: 2\n    observerA: 3\n    observerB: 3\n\n通过上面的方法，我们基本上就借助 Subject 把一个单播的 Observable 转换成了多播的。这个示例仅仅是演示了一种将一个执行上下文分享给多个观察者的方法。\n\n上面代码中有一个from方法，它的作用就是来创建一个可观测序列，类似于之前的create方法，但更加简洁，在rxjs中，它有个专门的名称叫个操作符，通过各种各样的操作符我们就可以实现可观测序列的创建，以及对序列中的数据进行各种各样的转换，可以说使用rxjs时我们大部分的时候都在使用各种各样的操作符。\n\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"rxjs\"]',1,11),(12,'山高路远','2018-06-21 08:44:27','','从命令式到响应式（四）','Rxjs系列','上期介绍过了rxjs中的三大件，Observable，subscription，subject，但是在开发过程我们最常接触到的东西非操作符莫属。比如上期代码中曾出现过的from就是一个操作符。rxjs中的操作符大致上可以分为几类，创建类，组合类，转换类，过滤类，条件类，聚合类，错误处理类，多播类及工具类，其中前四类是数据处理时使用频率非常高的，在本节及下一节中将介绍其中一些使用频率非常高的操作符。rxjs一共提供了120个左右操作符，合理的使用这些操作符会使我们获取愉快的编码体验。\n\n## 如何学习操作符\n\n首先需要分清的是操作符是属于实例方法还是静态方法，实例方法的实例当然指的是Observable类的实例，通常情况会在数据转换的过程中使用；而静态方法当然指的是Observable类的静态方法，只能通过Observable类来调用，大部分创建类型的操作符都是静态方法，在rxjs5中区别非常明显，例如：\n\n```ts\n    import \'rxjs/Observable\';\n    import \'rxjs/add/operator/map\';\n\n    // 这里的interval 是静态方法，而map就是实例方法。\n    Observable.interval(1000).map(num => num * num);\n```\n在rxjs6中还可能这样写：\n```ts\n    import { interval } from \'rxjs/observable/interval\';\n    import { map } from \'rxjs/operators/map\';\n\n    // 引入的位置是不一样的。\n    interval(1000)\n        .pipe(\n            map(num => num * num)\n        );\n```\n最直观的描述操作符的行为的方式就是弹珠图，在官网上重要的操作符基本上都给出了相应的弹珠图。从现在开始为了表达的简洁，我们把可观测序列称之为流，弹珠图各部分的含义如下：\n\n    // 这条从左到右的横线代表随时间的推移，输入流的执行过程。\n    // 横线上的值代表从流上发射出的值\n    // 横线尾部的竖线代表complete通知执行的时间点，表示这条流已经成功的执行完成。\n    ----------4------6--------------a-------8-------------|---->\n\n                multipleByTen // 使用的操作符\n\n    // 这条从左到右的横线代表经过操作符转换后的输出流。\n    // 横线尾部的X代表在这个时间点上流发生了错误，至此之后不应该再有 Next 通知或 Complete 通知从流上发出。\n    ---------40-----60--------------X--------------------------->\n\n前面说过操作符会把我们的数据进行转换，在响应式编程中，我们应该尽量保持数据在流中进行转换，而不是时刻想着去subscribe一条流，取出数据，再转换数据。尤其在angular中，能不手动的subscribe的流，一定要力求不主动订阅，最典型的就是页面上需要显示的数据，我们完全可以交给async管道来进行订阅。OK，啰嗦了一大堆，下面主角登场。\n\n## 创建类操作符\n\n1. from\n\n----\n静态方法\n\n将数组、类数组对象、promise、部署了遍历器接口的对象或类 Observable 对象转换成Observable，它\n几乎可以将任何东西都转换成流，并且将原数据上的值依次推送到流上，字符串被当成由字母组成的数组进行转换。\n\n                from([1,2,3])\n\n        1--------------2--------------3|\n\n示例\n```js\n    from([1,2,3,4,5]).subscribe(v => console.log(v));\n\n    function* generatorDoubles(seed) {\n        var i = seed;\n\n        while(true) {\n            yield i;\n\n            i = i*2\n        }\n    }\n\n    const iterator = generatorDoubles(3);\n    from(iterator).take(5).subscribe(v => console.log(v));\n```\n2. of\n----\n静态方法\n\n创建一个流，把传入此函数的参数从左到右依次推送到流上，然后发出结束通知。\n\n                of(1,2,3);\n\n        1-------------2--------------3|\n\n示例\n```js\n    of(10,20,30).subscribe(v => console.log(v));\n```\n3. timer\n\n----\n静态方法\n\n创建一个输出流，在指定的延迟时间到达后开始发射值，在指定的间隔时间到达后发射递增过的值。类似于interval，但是这个操作符允许指定流开始发射值的时间，\n\n                timer(3000, 1000);\n\n        ------0--1--2--3--4--5--------->\n\n第一个参数代表等待时间，第二个参数代表时间间隔，这些值是一些数字常量。等待时间可以是一个毫秒数，也可以是一个日期对象。如果没有指定时间周期，输出流上只会发射0，反之，它会发出一个无限的数列。\n\n示例\n```js\n    Rx.Observable.timer(3000, 1000)\n        .subscribe(v => console.log(v));\n\n    Rx.Observable.timer(5000)\n        .subscribe(v => console.log(v));\n```\n## 过滤类操作符\n\n1. filter\n----\n实例方法\n\n创建一个流，它的值是使用判定函数对输入流发出的值进行过滤后的值。\n\n        --0--1--2--3--4--5----|-->\n\n                filter(v => v % 2 === 0);\n\n        --0-----2-----4-------|>\n\n和数组的filter方法行为一样，从输入流上获取值，使用判定函数对值进行过滤，只有符合过滤条件的值才会在输出流上发出。\n\n返回值 Observable 通过判定函数检测的值组成的流。\n\n示例\n```js\n    from([1,2,3,4,5,6])\n        .filter(num => num %2 === 0)\n        .subscribe(v => console.log(v));\n```\n2. first\n----\n实例方法\n\n发送输入流上的第一个值，或者第一个符合某些条件的值。\n\n        ---------a-------b------c---------d-->\n\n                first\n\n        ---------a|\n\n在不传入任何参数时，这个操作符仅发出输入流上的第一个值，然后立即发出结束通知。如果传入一个判定函数，则发出第一个通过判定函数检测的值。它还可以接受一个结果控制函数来转化输出的值，或一个在输入流没有发出符合条件的值情况下使用的默认值。如果没有提供默认值，并且在输入流上也没有找到符合条件的值时，输出流将会抛出错误。\n\n返回值 Observable 第一个符合条件的值。\n\n异常 EmptyError 在结束通知发出前如果没有发出过有效值，将会发送一个错误通知给观察者。\n\n示例\n```js\n    from([2,3,4])\n        .first()\n        .subscribe(v => console.log(v));\n\n    from([2,3,4])\n        .first(num => num === 5)\n        .subscribe(v => console.log(v)); // EmptyError;\n```\n3. skip\n----\n实例方法\n\n返回一个跳过指定数量的值的流。\n\n    ---a---b---c---d---e---|->\n\n                skip(3);\n\n    ---------------d---e---|>\n\n返回值 Observable 跳过了一定数量值的流。\n\n示例\n```js\n    from([1,2,3,4,5,6])\n        .skip(3)\n        .subscribe(v => console.log(v));\n```\n4. take\n----\n实例方法\n\n从第一个值开始发出指定数量的值，然后发出结束通知。\n\n        ---a------b------c------d-----e---|-->\n\n                take(3);\n\n        ---a------b------c|\n\n输出流仅仅发出了输入流上从第一个值开始的n个值。如果输入流上值的个数小于n，那么所有的值都会被发出。值发射完成后，不管输入流有没有发出结束通知，输出流都会立即发出结束通知。\n\n返回值 Observable 发出输入流上从第一个值开始的n个值，或者输入流发出值的个数小于n时发出所有的值的流。\n\n异常 ArgumentOutOfRangeError 在给此操作符传入负数时给观察者发出的错误。\n\n示例\n```js\n    interval(1000)\n        .take(5)\n        .subscribe(v => console.log(v));\n```\n5. takeUntil\n----\n实例方法\n\n在通知流发出通知之前，持续发射输入流上的值。在通知流发出值之前，输出流完全就是输入流的镜像。此操作符会一直监视传入的通知流，如果通知流发出了值或结束通知，输出流就会停止发射输入流上的值，并发出完成通知。\n\n返回值 Observable 持续发出输入流上的值，直到通知流上发出值为止。\n\n示例\n```js\n    Rx.Observable.interval(1000)\n        .takeUntil(Rx.Observable.fromEvent(document, \'click\'))\n        .subscribe(v => console.log(v));\n```\n学习操作符时，我们还要关注的一点是，这个操作符是否会发出结束通知，一方面订阅发出结束通知的流时，在库的底层会帮助我们释放资源可以省去手动取消订阅，比如 angular 中 http 服务上的方法，另一方面结束通知可能会影响接下来你使用的操作符，典型的如reduce 和 scan，在一个不发出结束通知的流上使用reduce时你将永远不会得到结果。\n\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"rxjs\"]',1,12),(13,'山高路远','2018-06-24 23:28:01','','从命令式到响应式（五）','Rxjs系列','接着上一节的操作符继续，让我们直奔主题。\n\n## 组合类操作符\n\n组合类的操作符可以将不同流数据按一定的规则进行合并，从而获得所需要的完整数据。\n\n1. combineLatest\n----\n实例方法\n\n将多个输入流组合成一个输出流，输出流上的数据是由每一条输入流上的最后一条数据组合成的数据。\n\n无论什么时间只要输入流上发出了数据，它就会把所有输入流上的最新数据组合成一条新的数据推送到输出流上。关键点在于任意一条被组合的流发出数据，输出流上都将有新的数据产生。\n\n        -a------b----c-----d------e---|\n\n        --1--2-----3--4-----5---6---|\n\n                combineLatest\n\n        --a1-a2-b2--b3-c3-c4----d4-d5---e5-e6-|\n\n另外它可以接受一个映射函数作为最后一个参数，所有输入流的值会依次传入映射函数作为它的参数。\n\n返回 Observable 一条包含所有输入流最新值的流，或者是所有最新值的映射值的流。\n\n示例\n```js\n    const weight = of(70,72,76,79,75);\n\n    const height = of(1.76,1.77,1.78);\n\n    const bmi = weight.combineLatest(height, (w, h) => w/h*h);\n\n    bmi.subscribe(x => console.log(\'BMI is \' + x);\n```\n2. withLatestFrom\n----\n实例方法\n\n将多个输入流组合成一个输出流，输出流上的数据是由每一条输入流上的最后一条数据组合成的，但是组合动作只在源 Observable 发出值时发生，这里的源 Observable 指的是调用withLatestFrom的实例。也就是说只有当源 Observable 产生值时，才会产生新的值。\n\n        -a-----b--------------c------------d--e---|-->\n\n        ----1-----2-----3--4--------5----|---->\n\n                withLatestFrom\n\n        ------b1------------c4-----------d5--e5---|-->\n\n返回值 Observable 一条包含所有输入流最新值的流，或者是所有最新值的映射值的流。\n\n和combineLatest一样它也可以接受映射函数作为参数。\n\n示例\n```js\n    const clicks = fromEvent(document, \'click\');\n    const timer = interval(1000);\n    const result = clicks.withLatestFrom(timer)\n\n    result.subscribe(x => console.log(x));\n```\n3. zip\n----\n实例方法\n\n如果所有的输入都是流，那么将所有输入流对应位置上的值组合成一个新值，将这个新值作为输出流上的值。此外zip操作符还可以直接使用可转化为流的数据作为参数，比如数组，promise，字符串等。\n\n    --a------b------c------d---2--|->\n\n    -----e------f------g-----h--|->\n\n                zip\n\n    ----ae------fb-----gc----hd-|->\n\n返回值 Observable 将各输入流上对应的值组合成新的值发送给输出流或者先经过映射函数处理后再发送给输出流。\n\n它也可以接受映射函数作为参数。\n\n示例\n```js\n    const obs1 = from([1,2,3,4]);\n    const obs2 = from([\'a\',\'b\',\'c\']);\n\n    obs1.zip(obs2)\n        .subscribe(v => console.log(v));\n\n----\n\n    const obs = interval(1000);\n    const promise = new Promise(resolve => {\n        setTimeout(() => resolve(\'hello\'), 2000);\n    });\n\n    obs.zip(promise, (obs, promise) => promise + obs)\n        .subscribe(v => console.log(v));\n```\n4. merge\n----\n实例方法\n\n创建一条可以同时把所有输入流的值推送出去的流。它把多条输入流合并成一条输入流，所有输入流的值都可以在这条输出流上得到。\n\n        -a----------b----------c---|----->\n\n        ------d---------e----------e----|-->\n\n                    merge\n\n        -a----d----b----e-----c----e----|-->\n\n合并所有输入流的订阅，不管是源 Observable 还是作为参数输入的 Observable，只是把值依次推送到输出流上，不作任何额外的更改。输出流只有在所有的输入流都完成以后才能完成，任何一条输入流上的错误都将立即推送到输出流上。\n\n返回值 Observable 可以发送所有输入流上的值的Observable。\n\n示例\n```js\n    const clicks = fromEvent(document, \'click\');\n    const timer = interval(1000);\n    const clicksOrTimer = clicks.merge(timer);\n\n    clicksOrTimer.subscribe(x => console.log(x));\n```\n5. forkJoin\n----\n静态方法\n\n将输入流的最后一个值合并后传给输出流。它的效果等同于Promise.all()，因此在你需要多个并发请求都返回结果时可以使用它。\n\nforkJoin可以以参数或数组的形式接收任意数量的输入流。如果没有转入输入流，输出流将会立即发出结束通知。\n\n它会等所有的输入流发出结束通知，然后发出一个包含所有输入流发出的最终值组成的数组，因此，传入n条输入流，得到的数组中将包含n个元素，每一个元素都是从对应顺序的输入流上取到的最后一个值。这也就意味着输出流只会发出一个值，紧接着就会发出结束通知。\n\n为了使用输出流上获取到的数组的长度与输入流的数量保持一致，如果某一个输入流在发出结束通知之前没有发出过任何有效值，那么输出流也将会立刻结束并且不再发出任何值，尽管其它的输入流上可能会发出有效值。反过来，假如有一条输入流一直没有发出结束通知，输出流也不会发出值，除非另外一条输入像之前描述的那样只发了结束通知。总的来说就是为了让输出流发出值，所有的输入流都必须发出结束通知而且在此之前必须至少发出一个有效值。\n\n如果输入流中的某一条发出了错误通知，输出流将会立即发出这个错误通知，并且立即取消对其它流的订阅。\n\n        ----2---3------4----5--|-->\n\n        ----a----b------------d---|-->\n\n                    forkJoin\n\n        --------------------------5d|\n\n返回值 Observable 以数组形式获取到的每一个输入流的值，或者来自映射函数的值。\n\n可以接收映射函数作为参数。\n\n示例\n```js\n    const observable = forkJoin(\n        of(1, 2, 3, 4),\n        of(5, 6, 7, 8)\n    );\n\n    observable.subscribe(\n        value => console.log(value),\n        err => {},\n        () => console.log(\'This is how it ends!\')\n    );\n\n----\n\n    const observable = forkJoin(\n        interval(1000).take(3),\n        interval(500).take(4)\n    );\n\n    observable.subscribe(\n        value => console.log(value),\n        err => {},\n        () => console.log(\'This is how it ends!\')\n    );\n```\n## 转换类型操作符\n\n这里我们主要介绍那些可以处理高阶流的操作符。\n\n1. map\n----\n实例方法\n\n输出流上的值是使用一个映射函数将输入流上的值映射后得到新的值。\n\n        --------1-----------2----------3----------|--->\n\n                map(v => v * 10);\n\n        --------10----------20---------30---------|---->\n\n返回值 Observable 发出映射后的值的流。\n\n示例\n```js\n    fromEvent(document, \'click\')\n        .map(event => event.clientX)\n        .subscribe(v => console.log(v));\n```\n2. mergeMap\n----\n实例方法\n\n将所有输入流的值都合并到一条流上。\n\n        -1-----2-----3---------|-->\n\n        ---2----2----2--|-----> //第一次时的内部流，第2，3次的一样，这个流是直正的输入流\n\n                mergeMap(v => Observable.of(v + 1).repeat(3));\n\n        -2--2--2--3--3--3--4--4--4----|-->\n\n输出流会把所有从映射函数中返回的内部流打平到一条流上。映射函数可以使用输入流的值来生成内部流。\n\n返回值 Observable 一条合并了所有映射函数生成的内部流的流，内部流上的值都会在这条流上发出。\n\n示例\n```js\n    of(\'a\',\'b\',\'c\')\n        .mergeMap(v => Rx.Observable.interval(1000).map(x => x + v ))\n        .subscribe(v => console.log(v));\n\n----\n\n    const source = of(\'Hello\');\n\n    const createPromise = v => new Promise(resolve => resolve(`I got ${v} from promise`));\n\n    source.mergeMap(\n        v => createPromise(v),\n        (outValue, innerValue) => `Source: ${outValue},${innerValue}`\n    )\n    .subscribe(v => console.log(v));\n```\n3. switchMap\n----\n实例方法\n\n在输入流发出值时，把它映射成一条内部流，然后把这条内部流打平成到输出流上，输出流上只会发出最近的内部流上的值。\n\n        -1---------3-----5----|->\n\n        -10---10---10-| // 内部流\n\n                switchMap(v => Observable.from([10,10,10]).map(x => x * v))\n\n        -10---10---10-30---30-50---50---50-|\n\n输出流上的值是由映射函数在输入流的值的基本上生成的内部流所发出的，输出流只允许观察一条内部流，当有新的内部流到达时，输出流将会取消对之前的内部流的订阅，转而订阅这个最新的内部流，并发出它上面的值。\n\n返回值 Observable 仅从最新的内部流上取值的流。\n\n示例\n```js\n    fromEvent(document, \'click\')\n        .switchMap(event => interval(1000))\n        .subscribe(v => console.log(v));\n```\n4. concatMap\n----\n实例方法\n\n将多个流合并到一条流上，需要等待当前的流完成后才能开始合并下一个，合并过程按传入的顺序进行。\n\n        --1------------3---------5-----------|-->\n\n        --10---10---10--|-->\n\n                    concatMap(i => 10*i----10*i---10*i)\n\n        --10---10---10-30---30---30-50---50---50--|->\n\n返回值 Observable 把输入的值经过映射成流后再连接起来的流。\n\n示例\n```js\n    fromEvent(document, \'click\')\n        .concatMap(event => Rx.Observable.interval(1000).take(3))\n        .subscribe(v => console.log(v));\n```\n5. groupBy\n----\n实例方法\n\n将输入流上的值按一定的规则分组成不同的流，然后把这些流发送给输出流，每一条流上都是一组符合相同条件的值。\n\n    ----1----2----3----4----5----|->\n\n                groupBy(v => v%2);\n\n    -----------------------------|->\n        \\   \\\n         \\   2---------4---------|\n          1------3----------5----|\n\n返回值 Observable 发出分组后的流的高阶流，分组的流都有一个唯一的key，并且该流中的值都是输入流上符合某一条件的值。\n\n示例\n```js\n    of(\n        {id: 1, name: \'aze1\'},\n        {id: 2, name: \'sf2\'},\n        {id: 2, name: \'dg2\'},\n        {id: 1, name: \'erg1\'},\n        {id: 1, name: \'df1\'},\n        {id: 2, name: \'sf2\'},\n        {id: 3, name: \'qfs3\'},\n        {id: 2, name: \'qsg\'}\n    )\n    .groupBy(v => v.id)\n    .mergeMap(group => group.reduce((acc,cur) => [...acc, cur],[]))\n    .subscribe(v => console.log(v))\n```\n## 聚合类操作符\n\n1. reduce\n----\n实例方法\n\n在源 Observable 上应用一个累积函数，当源 Observable 结束时把累积的值推送给输出流，可以接受一个初始的累积值。\n\n        --------1-------2-------3---|-->\n\n                reduce((acc,cur) => acc + cur, 0);\n\n        ----------------------------4|\n\n这个操作符的行为与数组的reduce方法相同。使用一个累积函数来处理流上的每一值，前一次累积后的值将作为下一次累积的初始值，把通过累积得到的最终值推送给输出流。注意，reduce操作符只会在源 Observable 发出结束通知后发出一个值。\n\n源 Observable 上发出的值都会被累积函数处理。如果提供了初始值，这个值将成为整个累积过程的初始值，如果没有提供的话，从源 Observable 发出的第一个值就是整个累积过程的初始值。\n\n返回值 Observable 把源 Observable 上的值都经过累积函数计算后得到的值作为值发送的流。\n\n示例\n```js\n    const clicksInFiveSeconds = fromEvent(document, \'click\')\n                                .takeUntil(interval(5000));\n    const ones = clicksInFiveSeconds.mapTo(1);\n    const seed = 0;\n    const count = ones.reduce((acc,cur) => acc + cur, seed);\n\n    count.subscribe(v => console.log(v));\n```\n2. scan\n----\n实例方法\n\n在输入流上应用一个累积函数，每一次累积的结果都发送给输出流，累积时可以接受一个可选的初始值。 和reduce操作符类似，不同的是会把每一次累积的结果都发送出去。\n\n返回值 Observable<R> 输出累积值的流。\n\n示例\n```js\n    fromEvent(document, \'click\')\n        .mapTo(1)\n        .scan((acc,cur) => acc + cur, 0)\n        .subscribe(v => console.log(v))\n```\n操作符就介绍到这里，都是一些非常非常非常常用的，另外一些没有介绍到的并非没有用，需要的请自行搜索，通过操作符之间的相互组合我们可以实现非常高效便捷的数据处理。\n\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"rxjs\"]',1,13),(14,'山高路远','2018-06-26 23:56:26','','从命令式到响应式（六）','Rxjs系列','从这个系列的第一章开始到第五章，基于rxjs的响应式编程的基础知识基本上就介绍完了，当然有很多知识点没有提到，比如 Scheduler, behaviorSubject，replaySubject等，不是他们不重要，而是碍于时间、精力等原因没办法一一详细介绍。从这章开始将把响应式放在angular的大环境中，看如何在实际项目中去使用，当然这些都是个人在使用中的一些经验，如有不妥，欢迎指正。\n\n另外本章开始的示例代码可能只是一些片段，或思路，正式要跑起来需要各位自己将代码放入正确的环境中。\n\n## angular中响应式接口无处不在\n\n既然 angular 中内置了rxjs，必须有好多地方都能找到响应式的影子，客官请看：\n\nActivatedRoute - 经常用它来获取路由上的信息，比如传递的参数等。\n```js\n    export interface ActivatedRoute {\n        url: Observable<UrlSegment[];>\n        params: Observable<Params>;\n        queryParams: Observable<Params>;\n        fragment: Observable<string>;\n        data: Observable<Data>;\n        get paramMap: Observable<ParamMap>;\n        get queryParamMap: Observable<ParamMap>;\n        toString(): string;\n    }\n```\nAbstractControl - FormControl的基类，尤其响应式表单中，你一定见过它。\n```js\n    export abstract class AbstractControl {\n        get valueChanges: Observable<any>;\n        get statusChanges: Observable<any>;\n    }\n```\nHttp - 这个更不用说，使用Http通信的项目离了它简直了没法干活。\n```js\n    export class Http {\n        get(url: string, options?: RequestOptionsArgs): Observable<Response>;\n        post(url: string, body: any, options?: RequestOptionsArgs): Observable<Response>;\n        head(url: string, options?: RequestOptionsArgs): Observable<Response>;\n    }\n\nEventEmitter - 组件向外传递数据时，你一定用过吧？\n\n    export class EventEmitter<T> extends Subject {\n        subscribe(generatorOrNext?: any, error?: any, complete?: any): any;\n    }\n```\n没有发现Observable？仔细看，它继承自Subject，那Subject呢？接着看：\n```js\n    export declare class Subject<T> extends Observable<T> implements ISubscription {\n        ...省略\n    }\n```\nSubject 最终还得继承自 Observable。当然还有很多其它的，总而言之请记住响应式的世界里everything is Observable，不管是输入还是输出。\n\n## 搭建响应式的组件\n\n输入和输出是编程中两个无处不在的东西，只要涉及到交互的东西，都可以把它抽象成输入和输出。\n\n最明显的，当我们使用 @Input 和 @Output 无疑是在和输入和输出打交道，除此之外呢。如果我们把定义component的 Class看作一部分，那么它给template 传递的数据也可以认为是一种输出，而它从各service获取的数据也可以当作一种数据输入。基于这种想法，我们可以认为一个组件就是连接数据和模板的桥梁，它最主要的功能就是获取服务中的数据作为输入输出给模板，当然也可以获取模板中产生的数据作为输入输出给服务。于是我们可以抽象出这样一个组件：\n```js\n    export abstract class BaseComponent {\n\n        abstract subscription$$: Subscription; // 用于在组件销毁时取消不得不手动订阅的一些流。\n\n        abstract launch(option?: any): void;  // 给服务输出数据\n\n        abstract initialModel(option?: any): void; // 从服务中获取数据输入\n    }\n```\n- initialModel 所有组件中要用到的数据都在这个方法中获得，再分发给数据的使用者。\n\n- launch 所有组件中需要向服务传递的数据都会在这个方法中向外传递。\n\n- subscription$$ 在实际项目中，无法避免会手动订阅一些流，其中的某一些流可能需要我们手动释放，这个变量可以全权负责，而且它的初始化基本上会被固定在 launch 方法中。\n\n假设我们需要实现一个带有图片验证码的登录功能，我们来实现它的数据交互。\n\n```js\n    @Component({\n        ...\n    })\n    export class LoginComponent extends BaseComponent implements OnInit, OnDestroy {\n        subscription$$: Subscription;\n\n        randomCode: Observable<string>; // 随机码，在页面上展示给用户\n\n        generateCode$: Subject<boolean> = new Subject(); // 和服务交互，通知服务我们需要一个随机码。\n\n        // 这里我们没有定义这个接口，你可以想像它就是登录表单的值，例如： { username： string; password: string; randomCode: string}; 它的功能就是发出登录请求的数据。\n        login$: Subject<LoginFormValue> = new Subject();\n\n        constructor(private auth: AuthService) { } // 这个服务随后实现\n\n        ngOnInit() {\n            this.initialModel();\n\n            this.launch();\n\n            this.goTo(); // 初始化时就调用跳转函数。\n        }\n\n        initialModel() {\n            this.randomCode = this.auth.getRandomCode();\n        }\n\n        launch() {\n            this.subscription = this.auth.login(this.login$)\n                .add(this.auth.generateRandomCode(this.generateCode$));\n        }\n\n        goTo() {\n            this.subscription.add(\n                this.auth.isLoginSuccess().subscribe(success => {\n                    // 跳转逻辑等等。\n                })\n            )\n        }\n\n        ngOnDestroy {\n            this.subscription$$.unsubscribe();\n        }\n    }\n```\n通过阅读以上代码，我们的核心关注点只需要放在 initialModel 和 launch 两个方法上，一个告诉我们获取了哪些数据，一个告诉我们输出了哪此数据。另外你会发现，登录动作和获取验证码的动作在组件初始化时就已经告诉了服务，这种命令式的是完全不同的两种风格，在命令式的风格中我们都是在等到用户点击登录按钮时才去调用login函数，发起登录动作。下面来看服务代码:\n```js\n    @Injectable()\n    export class AuthService {\n\n        login$: BehaviorSubject = new BehaviorSubject();\n\n        constructor(private http: Http) { }\n\n        login(data: Observable<LoginFormValue>): Subscription {\n            // url: 请求的url; Response: angular 定义的http响应接口。\n            return this.http.post(url)\n                    .map((res: Response) => {\n                    // 假设登录成功会后台会返回token，这里我们利用 BehaviorSubject 来保存这个 token;\n                        const body = res.json();\n\n                        return body.data.token;\n                    })\n                    .subscribe(this.login$);\n        }\n\n        generateRandomCode(signal: Observable<boolean>): Observable<string> {\n            return this.http.get(url)\n                .map((res: Response) => {\n                    // 假设数据保存在random 字段下\n                    const body = res.json()；\n\n                    return body.data.random;\n                });\n        }\n\n        isLoginSuccess(): Observable<boolean> {\n            return this.login$.mapTo(true);\n        }\n    }\n```\n基于开始说到的思路，我们基本搭建好了一个完全基于响应式风格的登录组件的骨架，可以说基本的套路出来了，暂时先到这里。各位可以先想一下可以扩展哪些功能，比如实现30秒换一次验证码，用户点击时立即更换验证码等，下次继续。\n\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"rxjs\"]',1,14),(15,'山高路远','2018-07-01 16:53:55','','从命令式到响应式（七）','Rxjs系列','上回搭建了一个组件以及它所依赖的服务的基本结构，这节接着它继续。另外从本节开始，统一采用rxjs6的风格，6和5在写法上最大的不同就是弃用链式调用，而采用pipe的方法，当然也有一些其它的变更，请自行翻阅文档。\n\n## 响应式组件\n\n上节中错误的把generateRandomCode 添加到了 subscription中，实际中它返回的是一个Observable，先调整过来。\n```js\n    initialModel() {\n            this.randomCode = this.auth.generateRandomCode(this.generateCode$);\n    }\n```\n删除 launch方法中的 .add(this.auth.generateRandomCode(this.generateCode$));\n\n## 服务代码\n\n验证码变更的逻辑有两处，第一是程序设定好的时间周期到达后，第二是用户点点击时。我们的组件中已经设置了一个subject来获取用户的输入，并且已经传给了服务，现在我们来完善服务中获取验证码的逻辑，也就是那个generateRandomCode方法。\n```js\n    generateRandomCode(signal: Observable<boolean>): Observable<string> {\n        // 每30秒向后台获取一次验证码\n        const period = timer(0, 1000 * 30) // 第一个参数延迟时间，第二个参数间隔周期。\n                .pipe(\n                    mapTo(true)\n                );\n\n        // 将这两条流合并成一条请求流。\n        const request = merge(signal, period);\n\n        // 修改返回，当请求流中产生数据后，向服务器请求并将结果返回。\n        return request.pipe(\n            switchMapTo(this.http.get(url)),\n            map((res: Response)) => {\n                // 假设数据保存在random 字段下\n                const body = res.json()；\n\n                return body.data.random;\n            }\n        )\n    }\n```\n随便码请求的过程就完成了，当然还可以添加其它逻辑，如限制用户10秒内最多可以获取一次，可以给传入的 signal 加 debounce time\n```js\n    const signal2 = signal.pipe(\n        debounceTime(10 * 1000)\n    )\n```\n另外还有对于错误的处理等，可以参照之前 前端大耍 的那篇 《Angular Http 请求出错后重试》。\n\n既然说到了http的失败重试，其实websocket也一样。\n\n## websocket的响应式\n\n首先我们实现一个建议websocket连接的方法，代码如下：\n```js\n    // url 和 protocols 不需要解释; input: 请求数据的流，通过它来向服务端发送数据。\n    function connect(url, input, protocols) {\n\n        const connectionStatus = new BehaviorSubject(0); // 用来查看当前连接的状态。\n\n        const messages = new Observable(function (observer) {\n            \n            const socket = new WebSocket(url, protocols);\n\n            const inputSubscription;\n\n            const open = false;\n\n            const forcedClose = false;\n\n            const closed = () => {\n                if (!open) return;\n                connectionStatus.next(connectionStatus.getValue() - 1);\n                open = false;\n            };\n\n            socket.onopen = () => {\n                open = true;\n                connectionStatus.next(connectionStatus.getValue() + 1);\n                inputSubscription = input.subscribe( data => socket.send(data));\n            };\n\n            socket.onmessage = message => observer.next(message.data);\n\n            socket.onerror = error => {\n                closed();\n                observer.error(error);\n            };\n\n            socket.onclose = event => {\n                closed();\n                if (forcedClose)\n                    observer.complete();\n                else\n                    observer.error(new Error(event.reason));\n            };\n\n            return function () {\n                forcedClose = true;\n                \n                if (inputSubscription)\n                    inputSubscription.unsubscribe();\n                if (open) {\n                    closed();\n                    socket.close();\n                }\n            };\n        });\n\n        return { messages: messages, connectionStatus: connectionStatus };\n    }\n```\n利用上面实现的方法，可以很方便的拿到响应流，即 message。\n```js\n    @Injectable()\n    export class WebSocketService {\n        inputStream: Subject<any> = new Subject(); // 和上面写好的方法进行通信\n\n        message: Observable<any>; // 暴露给调用者来获取数据\n\n        constructor() {\n            this.connect()\n        }\n\n        // 暴露给其它服务或组件来发送数据，同时获得请求对应的响应。\n        send(data) {\n            this.inputStream.next(data);\n\n            // 由于websocket 不同于http，请求和响应一一对应的很好，所以这里可能需要一定的条件来拿到请求对应的响应。\n            return this.message.pipe(\n                filter(message => message.flag === data.flag)\n            );\n        }\n\n        private connect(): void {\n            if(this.message) return;\n\n            const { message, connectStatus } = connect(youUrl, this.inputSteam);\n\n            this.message = message.pipe(\n                map(response => /*处理数据逻辑*/),\n                retryWhen(error => error.pipe(\n                    tap(err => console.log(err)),  // 打印一下错误，可以换成其它的逻辑。\n                    delay(500) // 500毫秒后发起重试\n                )),\n                share() // 将这个流变为hot，至于流的hot 和 cold可能需要单独的文章来解释。\n            );\n\n            connectStatus.subscribe(status => console.log(\'当前连接的状态:\' + status))\n        }\n    }\n```\n可以看出在响应式的代码中，很少需要维护一些中间数据状态，数据都是在流中获取，转换和传递，订阅者对数据最好可以实现开箱即用，无需另外的加工。\n\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"rxjs\"]',1,15),(16,'山高路远','2018-07-10 23:55:22','','从命令式到响应式（八）','Rxjs系列','最近有同学在使用rxjs时总是不能如愿拿到自己想要的数据，说到底还是没有能把思维从命令式的习惯中转换过来。\n\n## Observable !== 异步 && Observable !== 同步\n\n如题，请默念几遍！在（一）里面其实就提到过，Observable里的数据到底是同步的还是异步取决于你如何使用，这和promise是完全不同的，promise不论你如果使用，它始终是异步的。上代码：\n\n```js\n    dataSource: DataSource<Stock>;\n\n    ngOnInit() {\n        this.getDataSource()\n            .subscribe(data => {\n                console.log(\'in subscribe: \',data);\n\n                this.dataSource = data;\n            })\n\n        console.log(\'after subscribe:\', this.dataSource);\n    }\n\n    getDataSource(): Observable<DataSource<Stock>> {\n        return this.stockService.getStocksMat()\n            .pipe(\n                map(stocks => new StockTbDataSource(this.paginator, this.sort, stocks))\n            );\n    };\n```\n\n请问，以上2个console，哪个先输出，哪个后输出？正确答应该是，鬼知道！仔细分析代码，这个数据是从stockService上获取到的，那么数据是同步还是异步就取决于这个服务的 getStocksMat 方法。\n\n```js\n    import { of } from \'rxjs\';\n\n    export class StockService {\n        getStocksMat(): Observable<DataSource<Stock>> {\n            return of({name: \'a\', price: 100});\n        }\n    }\n```\n\n现在呢，毫无疑问，这个时候数据是同步的，因为服务的方法中使用of操作符创建了一个 Observable，of操作符的行为是会把传入它的参数依次推送到流上，最后发出完成通知。所以，以上两个console的输出顺序应该是 inner 先输出，after 后输出。\n\n注意：也不要把操作符和同步异步划等号，同样也和你如何使用它有关系，这个系列里一直没有提到的一个东西叫 scheduler，也就是调度器，它可以调节流上的值如何发射\n\n```js\n    import { asyncScheduler } from \'rxjs\';\n\n    of({name: \'a\', price: 100}, asyncScheduler); // 此时流上的数据将被异步发出。\n```\n\n假如service上的代码变成：\n\n```js\n    export class StockService {\n        constructor(private http: HttpClient) { }\n\n        getStocksMat(): Observable<DataSource<Stock>> {\n            return this.http.get(someUrl).pipe(\n                map(res => res.data)\n            );\n        }\n    }\n```\n\n很显然，我们是想从服务器上取一段数据回来，那么这个过程肯定是异步的，所以那2个console的输出顺序就应该是 after 先输出，而inner 后输出。\n\n## 尽量不要主动订阅流\n\n这里指的是在angular里，因为angular给我们提供了取数据的 pipe - async。它可以帮助我们在模板中把数据取出来，当然就是订阅我们给它的 Observable。不主动订阅的原因如下：\n\n1. 当订阅流时，会产生 subscription，当然使用 async pipe 时也会有，但此时框架会帮我们管理它，当不需要再订阅时取消订阅，如模板销毁时。\n2. 如果我们手动订阅的是一个会发出结束通知的流时，rxjs的底层会帮我们在流上的数据发送完成时取消订阅，反之则不会。也就是说第一，你需要准确判断订阅的流是否会发出结束通知。第二，你可能需要在合适的时机手动取消订阅。\n3. 响应式的编程风格中，数据应该在流内完成转换，合并，过滤，而不是取出来，一顿操作再丢回流里。\n\n如下\n\n```js\n    export class StockService {\n        constructor(private http: HttpClient) { }\n\n        getStocksMatArr(): Observable<DataSource<Stock>[]> {\n            return this.http.get(someUrl).pipe(\n                map(res => res.data)\n            );\n        }\n\n        // 只要价格大于某个值的股票\n        getStocksThatPriceLargeThan(price: number): Observable<DataSource<Stock>[]> {\n            return this.getStocksMatArr().pipe(\n                filter(stocks => stocks.filter(stock => stock.price > price))\n            )\n        }\n\n        // 和另外一些流上的数据组合，比如购买人数；\n        getStocksWithBuyCount(): Observable<{stocks: DataSource<Stock>[]; count: number}> {\n            const count$ = of(2000);\n\n            return this.getStocksMatArr().pipe(\n                withLatestFrom(count$, (stocks, count) => ({stocks, count}))\n            );\n        }\n\n        // 当然还可以更复杂\n        showExample(): Observable<any> {\n            return this.getStocksMatArr().pipe(\n                mergeMap(stocks => from(stocks)), // 先把stock逐个放到流上\n                filter(stock => stock.price < 50), // 过滤出来\n                take(10), // 拿前10支股票\n                withLatestFrom(obs), // 和另一条流的上数据组合\n                bufferCount(2), // 两两组合\n                reduce((acc, cur) => [...acc, cur], []) // 再合并起来\n                delay(2000), // 延迟2秒再发\n                ...  等等， 一切取决于你的需求。\n            )\n        }\n    }\n```\n\n只要保持数据一直在流中，你就不必时时惦记着它到底是同步还异步，数据来了就消费，没来就一直等。刚开始时建议强迫自己不去订阅，这样才能很快的理解和适应响应式的风格。\n\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"rxjs\"]',1,16),(17,'山高路远','2018-08-04 22:31:55','','从命令式到响应式（九）','Rxjs系列','使用rxjs时什么时候取消订阅是我们必须要关心的，这个系列的前面几篇也提到过，原则是尽量不去手动订阅流，但手动订阅终究是无法避免的，今天主要总结下如何适时的取消订阅。\n\n## 让angular帮我们取消\n\n这个不用多说了，主要是采用 async pipe，在HTML模版本中让angular自已去取数据，再自动的取消。\n\n## 在component中管理subscription\n\n思路是，在component中订阅的流，在合适的生命周期中取消，最常见就是在OnDestroy的时候。两种方式，第一种组件维护一个subscription，其它的subscription通过add方法添加至这个subscription上，取消的时候调用这个subscription的unsubscribe方法，第二种，组件维护一个subscription数据，取消的时候遍历数组，调用每一个subscription的unsubscribe方法。\n\n假设我们有一个服务，可以发送websocket的请求，处理请求的错误，同时还可以提供一些公共逻辑的处理，大概像下面这样：\n\n```js\n    // service.ts\n    @Injectable()\n    export class MyService {\n        constructor(public websocket: WebsocketService) {}\n\n        // 发送websocket请求\n        request(paramObs: Observable<MyInterface>): Subscription {\n            return paramObs.subscribe(params => this.websocket.send(params));\n        }\n\n        // 处理响应的错误\n        handleError(): Subscribe {\n            return this.websocket.message.pipe(\n                filter(res => res.flag === \'request flag\') // 取这个上面请求的结果\n            ).subscribe(res => ...)\n        }\n\n        // 其它需要在服务中订阅后处理的逻辑\n        otherLogic(params: Observable<any>): Subscription {\n            return params.subscribe(...) \n        }\n    }\n```\n\n第一种思路：\n\n```js\n    @Component({...})\n    export class MyComponent implement OnInit, OnDestroy {\n        subscription: Subscription;\n\n        constructor(private ser: MyService) { }\n\n        ngOnInit() {\n            this.subscription = this.ser.request(paramsObs1) // 参数是包含请求数据的流\n                .add(this.otherLogic(paramsObs2)) // 参数是需要处理的数据流\n                .add(this.ser.handleError())\n        }\n\n        ngOnDestroy() {\n            this.subscription.unsubscribe();\n        }\n    }\n```\n\n第二种思路：\n\n```js\n    @Component({...})\n    export class MyComponent implement OnInit, OnDestroy {\n        subscriptions: Subscription[] = [];\n\n        constructor(private ser: MyService) { }\n\n        ngOnInit() {\n            this.subscriptions = [\n                this.ser.request(paramObs1), // 参数是包含请求数据的流\n                this.ser.handleError(),\n                this.otherLogic(paramsObs2) // 参数是需要处理的数据流\n            ];\n        }\n\n        ngOnDestroy() {\n            this.subscriptions.forEach(sub => sub.unsubscribe());\n        }\n    }\n```\n\n除了写法上的不同外，最大的不同在于采用第一种写法时，你可能需要注意添加的顺序，假如例子中的paramsObs2参数流会出完成通知则会导致handleError也被取消掉，这种场景大家可以自己写个demo试下，第二种写法则不会，但可能重复去取消一些已经被取消过的流，好在这并不会导致错误的发生。\n\n## 使用rxjs的操作符管理订阅\n\n思路是使用那些可以让流发出结束通知的操作符，将其添加到需要管理的流上，让rxjs自动取消订阅。常用的有下面这些：\n\n### take操作符\n\n此操作符会上当前流上取指定数量的值，然后发出完成通知，使用只想让otherLogic处理前3个数据，\n\n```js\n    ngOnInit() {\n        this.ser.otherLogic(paramsObs2.take(3)); // 不再需要理会订阅产生的subscription了，处理3个值后自动取消订阅；\n    }\n```\n\n类似的操作符还有first，from，of等都会发出完成通知。\n\n### takeWhile操作符\n\n此操作符添加到流上后，每一次发出值时都要检查操作符中传入的判定函数返回的结果是否为true，一旦返回false，输出流将会被取消掉，不再发出值，假设我们的paramsObs2的数据来自于一个formControl：\n\n```js\n    @Component({\n        ...\n        template: `<input type=\"text\" [formControl]=\"control\">`\n    })\n    export class MyComponent implement OnInit, OnDestroy {\n        control = new FormControl(\'xxx\');\n\n        isAlive = true; // 添加一个变量控制流的结束\n\n        ...\n\n        ngOnInit() {\n            ...\n            this.ser.otherLogic(this.control.valueChanges.pipe(\n                takeWhile(() => this.isAlive) // 传入了一个判定函数\n            ))\n        }\n\n        ngOnDestroy() {\n            this.isAlive = false; // 这里变为false；\n        }\n    }\n```\n\n### takeUntil操作符\n\n此操作符和takeWhile不同，第一，接受的参数不是判定函数，而是Observable， 第二，传入的observable一旦发出值，输入流将会被取消订阅，不管发出的值是true还是fasle，或者是其它值。\n\n```js\n    @Component({\n        ...\n        template: `<input type=\"text\" [formControl]=\"control\">`\n    })\n    export class MyComponent implement OnInit, OnDestroy {\n        control = new FormControl(\'xxx\');\n\n        constructor(\n            ...\n            private router: Router\n        ){}\n\n        ngOnInit() {\n            ...\n            this.ser.otherLogic(this.control.valueChanges.pipe(\n                takeWhile(this.router.events) // 把router的事件流传了进去，只要router上有事件发出输出流就被取消\n            ))\n        }\n\n        ...\n    }\n```\n\n这几种方法各有各有的特点，有的需要额外的变量但用起来简单粗爆，有的简洁明了但你需要花心思在其它条件上，在项目中可以根据实际情况选择最适合的使用。\n\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"rxjs\"]',1,17),(18,'山高路远','2018-08-17 23:09:25','','从命令式到响应式（十）','Rxjs系列','这个系列不知不觉已经写到10了，单纯从使用上来说的话，大部分的知识点也都讲过了，本来不打算写了，刚好今天有同学在群里说希望能总结一下常用的操作符，那就用这篇文章给这个系列画一个句号吧。\n\n## 已经提到过的\n\n早在这个系列的第4，第5章的时候就提到过了操作符，有兴趣的同学可以翻一下，这里简单的回顾一下：\n\n- 创建类：3个，分别是 from，of 和 timer；\n- 过滤类：5个，分别是 filter， first， skip，take 和 takeUntil；\n- 组合类：5个，分别是 combineLatest， withLatestFrom， zip， merge， forkJoin；\n- 转换类：5个，分别是 map， mergeMap，switchMap， concatMap， groupBy；\n- 聚合类：2个，分别是 reduce，scan；\n\n另外在其它的章节的示例中用到过的还有delay，retryWhen，share，switchMapTo，mapTo，bufferCount，delay，takeWhile，如果看到这些名字你就能清楚的说出它们的作用的话，那么恭喜你，数据处理中要面临的多数场景其实你都已经可以应付了。\n\nrxjs的操作符大致有120个左右（5.x版本），除了上面那28个，我们再来看下还有哪些会经常用到。\n\n## 其它一些常用的操作符\n\n这章里就不详细的解释每一操作符了，只简单提一下功能，关于如何学习它们可以参照第4章的内容。\n\n1. x 到 xMap 再到 xMapTo。xMap，这类操作符大都是在基础功能上增加 map 功能。加上To以后的操作符xMapTo大都是直接将输入流映射到一个输出流，并且它们都不关心输入流上的值。\n    - concat 连接流，需要注意被连接的流需要发出完成通知。\n    - concatMapTo 和concatMap类似，只不过连接的流始终是相同行为的流。\n    - mergeMapTo 和mergeMap类似，只不过内部流始终是相同行为的流。\n  \n2. 使代码更好的保持响应式风格的操作符\n    - never 一条永远不会发出任何通知的流。\n    - empty 一条只发出，并且立刻发出完成通知的流。\n    - defaultIfEmpty 如果输入流没发出任何值，只发出完成通知，那么发出一个默认值。\n3. 与错误相关的一些操作符，如已经提到的retryWhen\n    - retry 当输入流上有错误时，可以发出重试，传入的参数就是重试的次数。\n    - catchError 5.x版本里叫 catch，毫无疑问就是用来捕获流上的错误的。\n    - throwError 一条只发出，并且立刻发出错误通知的流。\n4. 用来周期性发出值的流，如已经提到的timer\n    - interval 只看名字就知道它就是一个计时器，参数就是发出值的周期。\n5. 一些降低数据发出频率的操作符 或者 防止值重复的操作符\n    - distinct 用来鉴别值是否应该被认为是相同的，可以接受一个可选的函数作为参数。\n    - distinctUntilChanged 这个操作符最大的优势在于，传入它的函数，可以接收当前值和前一个值作为参数。\n    - distinctUntilKeyChanged 这个就简单粗暴多了，通过一个key来判断值是否发出了改变。\n    - debounceTime 控制表单字段的数据发出频率时经常会用到，比如输入值改变时自动发出请求去服务器拉取数据的场景。\n    - auditTime 在一定时间内忽略输入流上的值，只发出时间过后的输入流上最后发出的值。\n    - throttleTime 和auditTime差不多，只是发出时间过后输入流上最先出出的值。\n6. 其它\n    - partition filter 只能让你拿到\'true\'或\'false\'的数据流，而这个操作符可以让你同时拿到两个条，一条完全发出\'true‘值，另一条完全发出’false‘值。\n    - iff 在订阅的那一瞬间再决定使用哪条一条流，第一个参数是判断函数，第二个参数是判定结果为true时使用的流，第三个参数当然就是false时使用的流。\n    - timeout 通俗的说就是’我只想等xxx时间，这段时间内没有发出值的话，我认为over了。’，就是用来设置超时时间而已。\n    - tap 5.x的版本里也就做do，意思就是在数据处理的过程中开个小差做点其它事情，比如调试时你会经常需要它把数据log到控制台上。\n    - find 找到流上符合某个条件的第一个值。\n    - every 流上的值是不是都符合某一个条件。\n\n加上之前的28个，一共总结了49个操作符，如果这些不能满足你的业务需求，可以仔细研究一下[官网](https://rxjs-dev.firebaseapp.com/api)上公布的其它操作符，相信总有一款适合你！\n\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"rxjs\"]',1,18),(19,'山高路远','2018-07-18 23:33:19','','如何把JSON转化成Typescript的接口','','刚开始使用Typescript的时候，编辑器或IDE时不时的就会在代码下面给你划很多红线，告诉你这个地方有错误，那个地方不匹配，甚至有时候代码都按预期运行正确了，可错误提示就是不消失。此时，有些同学就会用“any”大法来解围，其实这是非常不正确的做法，个人认为这根本不能算是一种解决方案，最起码不是正确的解决方案。其实这个问题的根源在于typescript的类型检查，这也是ts区别于js的最大的不同，在ts中区别类型的最常用的就是接口。\n\n## 什么是接口\n\n通俗的讲，接口就是一种约定，是数据交换者之间对于使用的数据类型的约定。如果使用货币来解释文章开头的问题的话，大概是这么一种情景：在js中，你拿100块钱去超市买东西，收银员根本不会去检查这个100元到底是真是假，等到发现是假币时，收银员大概会骂句娘；在ts中，同样的100块，收银员会非常在意它的真假，如果他认为钱有问题就会提示你，不要忽悠我。那么收银员凭什么去辨别钱的真钱？水印，金线，图案等等共同标识了这张钱是真的还是假的。你可以想像，这100元就是交易双方定义的接口，水印，金线，图案等就是接口上的标识。\n\n## 如何定义接口\n\n### 先上数据\n\n先来看一段数据，这个我最近项目中后台返回的json数据中截取的一部分\n```json\n\n    {\n        \"finished\": true,\n        \"loadBytes\": 22461,\n        \"profitLogs\": [[15137999000, 2983.3, \'a\'], [1511382980000, 220, true, 2938]],\n        \"snapshots\": [{\n            \"balance\": 10000.0,\n            \"baseCurrency\": \"BTC\",\n            \"symbols\": {\n                \"BTC_USD_OKCoin_EN\": 7350.0\n            },\n            \"tradeStatus\": {\n                \"sell\": 9,\n                \"buy\": 8\n            }\n        }],\n        \"task\": {\n            \"end\": 1531882800,\n            \"exchanges\": [{\n                \"fee\": [0.15, 0.2],\n                \"label\": \"OKCoin_EN\",\n                \"showBar\": true,\n            }],\n            \"options\": {\n                \"period\": 900000,\n                \"retFlags\": 208,\n                \"snapshotPeriod\": 300000,\n            },\n            \"start\": 1531756800\n        }\n    }\n```\n乍一看很复杂，实际比这个更复杂，字段更多，但是再复杂也不怕，从最外层开始，我们一步步把它定义出来。\n```ts\n    interface Response {\n        finished: boolean;\n        loadBytes: number;\n        profitLogs: any;\n        snapshots: any;\n        task: any;\n    }\n```\n总的来看，就这5个字段，但里面的any显然不是我们想要的。\n\n### profitLogs\n\n这个字段中，数组子元素中的数据类型是不确定的，可能是字符串，数字，布尔值，因此这里使用联合类型\n```ts\n    export type ProfitLog = Array<string | number | boolean>;\n\n    interface Response {\n        finished: boolean;\n        loadBytes: number;\n        profitLogs: ProfitLog[];\n        snapshots: any;\n        task: any;\n    }\n```\n### snapshots\n\n这段数据里，balance 和 baseCurrency很简单，一个是数字，一个是字符串。symbols字段的特点是，它的key不固定，但key的类型总是一个字符串，value简单就是 number 类型。tradeStatus字段的特点是，它上面的这两个字段可能有，也可能没有。因此定义后就像这样：\n```ts\n    interface Symbol {\n        [key: string]: number;\n    }\n\n    interface TradeStatus {\n        sell?: number;\n        buy?: number;\n    }\n\n    interface Snapshot {\n        balance: number;\n        baseCurrency: string;\n        symbols: Symbol;\n        tradeStatus: TradeStatus;\n    }\n\n    interface Response {\n        finished: boolean;\n        loadBytes: number;\n        profitLogs: ProfitLog[];\n        snapshots: Snapshot;\n        task: any;\n    }\n```\n### task\n\n这个字段中比较特殊只有fee这个字段，它的长度是固定的，因此使用tuple来定义，其它的也很简单。\n```ts\n    type Fee = [number, number];\n\n    interface Exchange {\n        fee: Fee;\n        label: string;\n    }\n\n    interface Options {\n        period: number;\n        retFlags: number;\n        snapshotPeriod: number;\n    }\n\n    interface Task {\n        end: number;\n        exchanges: Exchange[];\n        options: Options;\n        start: number;\n    }\n\n    // 完整的接口\n    interface Response {\n        finished: boolean;\n        loadBytes: number;\n        profitLogs: ProfitLog[];\n        snapshots: Snapshot;\n        task: Task;\n    }\n```\n## 定义后的好处\n\n接口定义好以后，编辑器自然就知道这个数据长什么样了，首先它可以提示你这个字段上都有哪些属性可以用，再次一数据类型不匹配时，它也会提示我们。如图：\n![ts_interface_01539765821988.png](http://pghicsch6.bkt.clouddn.com/ts_interface_01539765821988.png)\n很明确知道res上有哪些字段\n![ts_interface_11539765861061.jpeg](http://pghicsch6.bkt.clouddn.com/ts_interface_11539765861061.jpeg)\n提示这种数据类型上可以使用哪些方法\n![ts_interface_21539765884125.jpeg](http://pghicsch6.bkt.clouddn.com/ts_interface_21539765884125.jpeg)\n\n再也不会忘记一些比较特殊的数据类型是什么样子了\n![ts_interface_31539765899808.jpeg](http://pghicsch6.bkt.clouddn.com/ts_interface_31539765899808.jpeg)\n\n\n最后，这里只是为了演示，实际中数据一大我们压根没有必要手动的定义，一切可以交给机器来做，请参照：JSON 转 TypeScript Interface\n\n\n\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"typescript\"]',1,19),(20,'山高路远','2018-07-16 00:16:28','','为什么使用Typescript','','typescript 是javaScript 的超集，在ts中可以使用js中的所有语法，也就是说js代码是完全合法的ts代码，这也导致了好多前端同学习惯了js，而不愿意按ts的规则进行开发。但是angular从2版本开始官方推荐的编程语言就是typescript，node重构项目 deno 也采用ts作为官方开发语言，那究竟为什么要使用typescript？\n\n## 排行榜\n\n这是权威编程语言排行网站 [TIOBE](https://www.tiobe.com/tiobe-index/)最近首页上的一段话：\n\n>> Last month we announced that TypeScript entered the TIOBE index top 100 for the first time. TypeScript appears to keep growing in popularity. This month it entered the top 50. TypeScript is slowly becoming the new and improved JavaScript. One of the trends that was not mentioned in my last post is the rising popularity of Angular. Angular is the successor of AngularJS. The latter platform was based on JavaScript, but the new Angular is completely focusing on TypeScript. The other large JavaScript platform, React, didn\'t adopt TypeScript yet, but this seems to be a matter of time.\n\n6月份首次进100，7月份到50。如它所说，react采用typescript也许只是时间问题。目前看来ts正成为一种趋势，也许未来的某一天浏览器可以直接运行ts代码也说不定。\n\n## 理性看待\n\n使用typescript 时编译器会在coding时就检查一些可能出错的地方并进行提示，这样我们可以在代码未运行时就发现一些错误，但是这并不代表使用ts 编写的代码就一定没有bug，或者一定可以按照你的预期运行，我想没有任何一种语言可以做到如此地步，否则程序员也不会每天都在处理bug了。如下：\n```ts\n    interface Person {\n        id: string;\n        name: string;\n    }\n\n    function sayHello(person: Person) {\n        console.log(person.name);\n    }\n\n    sayHello({} as any); // 注意这行；\n```\n虽然函数的参数上加入的类型，但在传入参数时显式的使用any，这将导致编译通过，但等到真正运行的时候结果似乎并非所愿。在ts中尽量避免使用any类型，因为它违背使用ts的初忠。\n\n尽管如此，它还是可以帮助我们减少bug的发生，有人研究过，具说可以减少15%左右，[传送门](https://blog.acolyer.org/2017/09/19/to-type-or-not-to-type-quantifying-detectable-bugs-in-javascript/)在这里有兴趣的同学可以看下。代码量上，使用ts开发的项目在代码量上可能要比js开发的大出大约30%。\n\n还有非常重要的一点，ts的本质还是js，所以\'我用的是ts所以不必学习js\'这种观点极不可取，尤其对于掌握了 c#, java之类的开发者来说，如果想使用ts进行开发，js仍然是绕不过去的，即使它们很像。\n\n## 开粉\n\n### ts可以帮助开始者更好的协同作战\n\n这对于一个大型项目来说尤其重要。当项目变的越来越大时，不论是维护还是扩展，我们都不希望再重复阅读之前的代码以弄明白它们是在做什么，尤其是当有新的成员加入进来时。typescript允许开发者聚焦于api上，而不必要去弄明白每一行代码究竟在做什么。试想下，如果一个项目有多个人在协同开发，每一个开发者关心的只是其它开发者给它暴出的接口，假如接口发生了变更，在声明良好的ts文件中，无论开发人员的水平处于哪一阶段，都很容易发现需要修改的地方以及可能出现的问题。另一方面，ts还可以帮助减少一些因为注意力不集中引起的一些低级错误，比如 \"can\'t read property \'xxx\' of undefined\"，相信只要是js开发者，一定遇到过这个错误信息。\n\n### 活跃的社区\n\n目前ts社区的开发者为ts的发展贡献了大量的代码，并且微软也在积极的推动ts的发展，相比coffeeScript来说这也许就是有一个好爹的优势。微软在ts上使用了开放语言服务协议，在github找到各种关于ts的工具都是开源的，同时微软了大力推动ts工具的标准化，这使得为ts开发的工具可以在多种编辑器或IDE中使用。这种推广策略使得社区的开发者积极的贡献自己的力量，开发出很多非常好用的工具，如tsLint等。同时对于流行的js库，几乎都有开发者为它们完成了ts的类型声明工作。说起开发工具，vscode也是微软开源的编辑器，它支持所有的ts语言特性，可以帮助开发者更愉快的书写和重构ts代码，相信用的人都有感受。\n\n### TypeScript 使得抽象清晰可见\n\n一个好的设计就是定义良好的接口。而且，用支持它们的语言来表达接口的想法要容易得多。\n\n例如，假设有一个图书销售应用程序，可以通过一个注册用户通过UI或通过某种API通过外部系统进行购买。\n\n![why_ts1539766161526.png](http://pghicsch6.bkt.clouddn.com/why_ts1539766161526.png)\n\n\n正如您所看到的，这两个类都扮演着购买者的角色。尽管对于应用程序非常重要，但购买者的概念在代码中并没有明确表达出来。没有名为购买者.js的文件。因此，修改代码的人可能会忽略这个角色的存在。\n```ts\n    function processPurchase() { }\n\n    class User { }\n\n    class ExternalSystem { }\n```\n仅仅通过查看代码来判断哪些对象可以扮演购买者的角色，以及该角色的方法是困难的。\n我们不确定，也不会从我们的工具中得到很多帮助。我们必须手动推断这些信息，这是缓慢且容易出错的。\n\n现在，将它与我们明确定义了 Purchaser 接口 的版本进行比较。\n```ts\n    interface Purchase { }\n\n    class User implements Purchase { }\n\n    class ExternalSystem implements Purchase { }\n```\n类型化的版本清楚地说明了我们有 Purchaser 接口，而User和ExternalSystem类实现了它。所以TypeScript接口允许我们定义抽象/协议/角色。\n\n重要的是要认识到TypeScript并没有强迫我们引入额外的抽象。Purchaser 抽象在代码的JavaScript版本中，但是没有明确定义。\n在静态类型语言中，子系统之间的边界是使用接口定义的。由于JavaScript缺乏接口，所以在普通JavaScript中边界不能很好地表达。由于不能清楚地看到边界，开发人员开始依赖于具体类型而不是抽象接口，从而导致紧密耦合。\n\n### TypeScript 使代码更容易阅读和理解\n\n```js\n    jQuery.ajax(url, settings);\n```\n上面的代码中，我们唯一可以肯定的是ajax函数有两个参数。其它信息只能靠猜，也许第一个是字符串，第二个是配置对象。我们不知道什么选项进入设置对象(它们的名称和类型)，或者该函数返回什么。我们可以检查文档，但这并不是最好的开发经验——它需要额外的时间，而且文档经常过期。\n\n因此，尽管很容易阅读jQuery.ajax(url,settings)，真正理解如何调用这个函数，我们需要阅读它的实现或它的文档。以下是类型版本：\n```ts\n    ajax(url: string, settings?: JQueryAjaxSettings): JQueryXHR;\n\n    interface JQueryAjaxSettings {\n        async?: boolean;\n        cache?: boolean;\n        heads?: { [key: string]: any};\n        ...\n    }\n\n    interface JQueryXHR {\n        responseJSON?: any;\n    }\n```\n一切都很清楚，函数的第一个参数是一个字符串。settings参数是可选的。我们可以看到所有可以传递到函数中的选项，不仅是它们的名称，还包括它们的类型。函数返回一个JQueryXHR对象，我们可以看到它的属性和函数。\n\n类型化签名肯定比未类型化的签名长，但是:string，:JQueryAjaxSettings和JQueryXHR并不是混乱的。它们是提高代码的可理解性的重要文档。我们可以更深入地理解代码，而不必深入到实现或读取文档中。\n\n## 总结陈词\n\nTypeScript拥有静态语言95%的有用特性，并将其引入到JavaScript生态系统中，但不会强迫你离开JavaScript生态系统，因为开发者一直都在使用相同的标准库、相同的第三方库、相同的习语和许多相同的工具(例如:Chrome开发工具)，它只是让你拥有了构建更健壮的js应用的能力。\n\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"typescript\"]',1,20),(21,'山高路远','2018-02-07 16:54:41','','Rxjs概述','','## 简介\n\n----\n\nrxjs是一个使用观察者模式来整合异步操作和事件系统的js库，通过一系列可观测的流（observable）将它们串联起来。Observable是这个库的核心类型，此外还包括诸如Observer，Schedulers，Subject等类型。还包括一些和数组方法类似或经过演化的操作符，用来协助处理数据。\n\n* <font face=\"仿宋\">_可以把 rxjs 想像成一个可以发射事件的 lodash 库。_</font>\n\n响应式设计结合了观察者模式，迭代模式和基于集合的函数式编程风格，从而提供了一种处理事件序列的理想方式。\n\n在rxjs中用来处理异步事件的核心概念包括：\n\n* observable: 代表了未来可能会产生的一系列的值或事件的集合；\n* observer: 回调函数的集合，它知道如何去处理observable上产生的值或者事件，当然也包括异常。\n* subscription: 代表当前正在订阅的observable，主要作用是用来取消订阅行为。\n* operators: 纯函数，以函数式的风格通过各种各样的操作符相互配合对observable上产生的数据集合进处理。\n* subject: 相当于一个事件发射器，允许将相同的值传递给多个订阅者。\n* schedulers: 协调observable上数据的发射方式。\n\n### 示例\n\n----\n\n在javascript中通常使用以下方式来注册事件：\n\n```js\n    var button = document.querySelector(\'button\');\n\n    button.addEventListener(\'click\', () => console.log(\'Clicked\'));\n```\n\n使用rxjs的方式实现如下：\n\n```js\n    var button = document.querySelector(\'button\');\n\n    Rx.Observable.fromEvent(button, \'click\')\n        .subscribe(() => console.log(\'Clicked\'));\n```\n\n#### 纯度\n\n----\n\n使用不纯的函数时，函数可能会改变外部数据的状态，比如：\n```js\n    var count = 0;\n\n    var button = document.querySelector(\'button\');\n\n    button.addEventListener(\'click\', () => console.log(`Clicked ${++count} times`));\n```\n当使用rxjs时，必须把这些状态隔离出去，比如：\n```js\n    var button = document.querySelect(\'button\');\n\n    Rx.Observable.fromEvent(button, \'click\')\n        .scan(count => count + 1, 0)\n        .subscribe(count => console.log(`Clicked ${count} times`));\n```\n这里的scan操作符的行为和数组的reduce方法的行为非常类似，它提供一个初始值给迭代函数，迭代函数运行后的值将作为下一次迭代的初始值。\n\n#### 流\n\n----\n\nrxjs 提供了一套非常丰富的操作符来帮助用户控制数据或事件如何在observable中进行流动。假如我们需要控制用户在一个按钮上每秒最多只能点击一次\n\n使用普通的javascript代码:\n```js\n    var count = 0;\n\n    var rate = 1000;\n\n    var lastClick = Date.now() - rate;\n\n    var button = document.querySelector(\'button\');\n\n    but****ton.addEventListener(\'click\', () => {\n        if(Date.now() - lastClick >= rate) {\n            console.log(`Clicked ${++count} timers`);\n            lastClick = Date.now();\n        }\n    });\n```\n使用rxjs：\n```js\n    var button = button.querySelector(\'button\');\n\n    Rx.Observable.fromEvent(button, \'click\')\n        .throttleTime(1000)\n        .scan(count => count + 1, 0)\n        .subscribe(count => console.log(`Click ${count} times`));\n```\n诸如此类对流进行控制的操作符还有：filter, delay, debounceTime, take, takeUntil, distinct, distinctUntilChanged等等。\n\n#### 值\n\n----\n\n你可以对流中的数据进行转换，当我们需要得到每一次鼠标点击时的x轴坐标时，\n\n使用普通的javascript代码:\n```js\n    var count = 0;\n\n    var rate = 1000;\n\n    var lastClick = Date.now() - rate;\n\n    var button = document.querySelector(\'button\');\n\n    button.addEventListener(\'click\', (event) => {\n        if(Date.now() - lastClick >= rate) {\n            count += event.clientX;\n            console.log(count);\n            lastClick = Date.now();\n        }\n    });\n```\n使用rxjs：\n```js\n    var button = button.querySelector(\'button\');\n\n    Rx.Observable.fromEvent(button, \'click\')\n        .throttleTime(1000)\n        .map(event => event.ClientX)\n        .scan((count,clientX) => count + clientX, 0)\n        .subscribe(count => console.log(count));\n```\n诸如此类可以产生新值的操作符还有：pluck，pairwise，sample等等。\n\n## 可观测序列-Observable\n\n----\n\n可观测序列可以推送多个值，并且它的推送方式是‘懒’的，它满足下面表格中列出的条件\n\n|      | single   | multiple   |\n| ---- | :------: | ---------: |\n| pull | function | iterator   |\n| push | promise  | observable |\n\n下面这个例子中的observable在被订阅时可以立即推送出1，2，3这个三个值，1秒以后推送第四的值4，然后立即结束。\n```js\n    var observable = Rx.Observable.create(function(observer) {\n        observer.next(1);\n        observer.next(2);\n        observer.next(3);\n        setTimeout(() => {\n            observer.next(4);\n            observer.complete();\n        },1000);\n    });\n```\n为了获取到这个observable上的值， 我们需要对它进行订阅：\n```js\n    var observable = Rx.Observable.create(function(observer) {\n        observer.next(1);\n        observer.next(2);\n        observer.next(3);\n        setTimeout(() => {\n            observer.next(4);\n            observer.complete();\n        },1000);\n    });\n\n    console.log(\'just before subscribe\');\n\n    observable.subscribe({\n        next: x => console.log(\'got value \' + x),\n        error: err => console.error(\'something wrong occurred: \' + err),\n        complete: () => console.log(\'done\'),\n    });\n\n    observable.subscribe(v => console.log(\'......\'));\n\n    console.log(\'just after subscribe);\n```\n这段代码执行后将会得到如下结果：\n\n    just before subscribe\n    got value 1\n    got value 2\n    got value 3\n    just after subscribe\n    got value 4\n    done\n\n### pull vs push\n\n----\n\n这里使用 pull 和 push 来描述值的生产者和消费者之间是如何发生联系的，它们是两种完全不同的协议。\n\n在pull的系统中，值的消费决定什么时间从生产者上获取数据，生产者本身并不关心数据什么时间分发给消费者。\n\n每一个javascript函数都可以看作一个 pull 类型的系统。函数可以产生值，但这是通过调用者主动调用函数，函数运行产生出值返回给调用者的方式进行的，所以可以理解为调用者主动去函数上拉取了值。\n\nES2015中介绍另外两种 pull 类型的系统，generator函数 和 iterator。对于它们来讲，遍历器对象的 next 方法可以视作值的消费者，通过iterator.next()可以获取到多个值。\n\n|      | Producer                  | Consumer               |\n| ---- | :-----------------------: | ---------------------: |\n| pull | 被动：当被调用时产生值    | 主动：决定何时发起调用 |\n| push | 主动：按自身的设置产生值 | 被动：响应接收到的值   |\n\n在push的系统中，生产者决定什么时候发送值给消费者，消费者并不知道什么时候可以接收到值。\n\nES6中的 promise 就是一个非常典型的 push 系统，promise 将 resolve 的结果传递给注册在它内部的回调函数，这与普通的函数有很大的不同，回调函数何时可以接收到数据完全取决于 promise 什么时间向它传递数据。\n\nrxjs的 Observable 也是一种 push 类型的系统，一个 Observable 可以产生多个值，然后推送给它的订阅者。\n\n* Function 是一个 ‘懒’ 的求值过程，只有在被调用时它才会同步的返回一个值给调用者。\n* generator 也是一个 ’懒‘ 的求值过种，在遍历的过程中同步的返回0个或多个值给调用者。\n* Promise 经过运算后可能产生一个值，当然也可能产生一个错误。\n* Observable 也是一个‘懒’的求值过程，当它被订阅后可以同步或者异步的产生出0个或者无限多个值给调用者，这个过程将一直持续到订阅被取消或者流结束。\n\n### Observable 概述\n\n----\n\n很多人认为 Observable 就是一个事件发射器或可以产生多个值的 promise，实际上这种观点是不正确的。在某些情况下Observable的行为可能与事件发射器的行为类似，例如使用Subject来发射值时，但通常情况下它们的行为与事件发射器有很大的不同。\n\n* <font face=\"仿宋\">_可以把 Observable 想像成一个不接受参数的函数，但是它却可以产生出很多的值。_</font>\n\n请思考以下代码：\n```js\n    function foo() {\n        console.log(\'hello\');\n        return 42;\n    }\n\n    var x = foo.call();\n\n    console.log(x);\n\n    var y = foo.call();\n\n    console.log(y);\n```\n运行后的输出：\n\n    \"hello\"\n    42\n    \"hello\"\n    42\n\n使用rxjs的方式：\n```js\n    var foo = Rx.Observable.create(function(observer) {\n        console.log(\'hello\');\n        observable.next(42);\n    });\n\n    foo.subscribe(function (x) {\n        console.log(x);\n    });\n\n    foo.subscribe(function (y) {\n        console.log(y);\n    });\n```\n运行后的输出依然是：\n\n    \"hello\"\n    42\n    \"hello\"\n    42\n\n首先，函数和Observable的求值过程都是‘懒’的，如果你不调用foo函数，console.log(\'hello\')将不会执行，这对于Observable也是一样的，只要不订阅，console.log(\'hello\')同样也不会执行。另外，每一次的订阅（subscribe）和调用（call）都是互不干扰的，两次函数调用会触发两次执行过程，产生两次副作用，同样，两次订阅也会触发两次订阅过程。对于事件发射器来说却不同，它产生的副作用会传递给每一个事件接收者，它并不理会有没有接收者接收事件，都会把事件发射出去，这与Observable有很大的不同。\n\n* <font face=\"仿宋\">_订阅一个Observable与调用一个函数的过程类似。_</font>\n\n你可能会认为Observable都是异步的，事实上并不是这样，我们看一下函数的调用过程：\n\n    console.log(\'before\');\n    console.log(\'foo.call()\');\n    console.log(\'after\');\n\n执行后的输出：\n\n    \"before\"\n    \"hello\"\n    42\n    \"after\"\n\n然后以同样的顺序，但是使用Observable：\n```js\n    console.log(\'before\');\n    foo.subscribe(function(x) {\n        console.log(x);\n    });\n    console.log(\'after\');\n```\n你会发现结果是相同的：\n\n    \"before\"\n    \"hello\"\n    42\n    \"after\"\n\n这个结果证明了 foo 这个 Observable 完全是同步执行的，和调用一个函数没有什么两样。\n\n* <font face=\"仿宋\">_Observable传递值的方式可以是同步也可以是异步的。_</font>\n\n那么Observable与函数之间有什么样的区别？**Observable被订阅后可以返回多个值**，这是普通的函数所无法做到的。例如，你无法像下面这样去实现一个函数：\n```js\n    function foo() {\n        console.log(\'hello\');\n        return 42;\n        return 100; // 这句永远不会执行\n    }\n```\n因为函数只能返回一个值，return 100; 会被解释器忽略，如果是在typescript中，编译器会告诉你这里有一个错误。然而这对于Observable来说却不是问题：\n```js\n    var foo = Rx.Observable.create(function (observer) {\n        console.log(\'hello\');\n        observer.next(42);\n        observer.next(100); // \'返回‘另外一个值\n        observer.next(200); // 同上\n    });\n\n    console.log(\'before\');\n    foo.subscribe(function(x) {\n        console.log(x);\n    });\n    console.log(\'after\');\n```\n上面的代码执行后会以同步的方式输出：\n\n    \"before\"\n    \"Hello\"\n    100\n    42\n    200\n    \"after\"\n\n当然， 你也可以让它以异步的方式来返回值：\n```js\n    var foo = Rx.Observable.create(function (observer) {\n        console.log(\'hello\');\n        observer.next(42);\n        observer.next(100); // \'返回‘另外一个值\n        observer.next(200); // 同上\n        setTimeout(() => {\n            observer.next(300);\n        },1000);\n    });\n\n    console.log(\'before\');\n    foo.subscribe(function(x) {\n        console.log(x);\n    });\n    console.log(\'after\');\n```\n执行后的输出：\n\n    \"before\"\n    \"Hello\"\n    42\n    100\n    200\n    \"after\"\n    300\n\n总结：\n\n* func.call() 表示以同步的方式返回一个值。\n* observable.subscribe() 表示以同步或者异步的方式返回一些值。\n\n### Observable详解\n\n----\n\n我们可以使用Rx.Observable.create方法或者那些可以**创建** Observable 的操作符来创建 Observable，然后使用一个观察者来**观察** Observable，当 Observable 被**订阅**时它就会通过 next/error/complete/ 方法来通知观察者，当观察者放弃观察行为时如何**处理** Observable 运行产生的数据。这四个动作都被编码在一个可观察的实例中，但其中一些动作与其它动作是相关的，如观察和订阅。\n\n使用Observable时要关注的核心问题：\n\n* 如何创建\n* 被谁订阅\n* 怎么去执行\n* 废弃时如何处理\n\n#### 创建Observable\n\n----\n\nRx.Observable.create方法实际是 Observable 类的构造函数的别名，它接受一个参数——订阅函数。下面这个示例会创建一个observable，它会每秒发一个 string 类型的值‘hi’ 给它的观察者。\n```js\n    var observable = Rx.Observable.create(function subscribe(observer) {\n        var id = setInterval(() => {\n            observer.next(\'hi\');\n        },1000);\n    });\n```\n* <font face=\"仿宋\">_可以通过 create 方法来创建 Observable，但实际情况下我们使用更多的是那些可以创建出 Observable 的操作符，例如：from, interval 等。_</font>\n\n上面代码中的 subscribe 函数对于解释 Observable 来说是非常重要的一部分，接下来解释如何去理解它。\n\n#### 订阅Observable\n\n----\n\n上面例子中的observable可以这样被订阅：\n```js\n    observable.subscribe(x => console.log(x));\n```\nobservable变量上有 subscribe 方法，同样 Observable.create(function subscribe(observer) { ... }) 也有subscribe 方法，这并不是一个巧合。在库的实现中，这两个subscribe是不一样的，但在实际使用中你可以认为它们在概念上是相等的。\n\n这个示例很好的展示了为什么订阅行为在多个订阅者之间是不会共享的。当我们使用一个观察者来订阅 observable 时，传入 create 方法的 subscribe 函数就会为这个观察者运行一次。每次调用 observable.subscribe 都会为给定的观察者触发它自己的独立设置。\n\n* <font face=\"仿宋\">_订阅Observable和执行一个函数很类似，都可以提供一个回调函数来接收将要产生的值。_</font>\n\n这个过程与诸如 addEventListener/removeEventListener 等事件处理API有很大的区别。在 observable.subscribe 的过程中，给定的观察者并没有注册成为 Observable 上的监听者。Observable 甚至不需要维护一个观察者名单。\n\n通过 subscribe 这种简单的方式就可以使一个 Observable 开始执行，并且将产生的数据或事件传递给当前 Observable 环境上的观察者。\n\n#### 执行Observable\n\n----\n\nObservable.create(function subscribe(observer) { ... })内部的代码代表了 Observable 的执行，一个‘懒’执行过程——仅在有观察者订阅它的时候执行，当它被执行后就可以以同步或异步的方式不断的生产值。\n\nObservable 执行后可以产生三种类型的值：\n\n* ’next‘：发送一个**正常**的值，比如String， Number 或者 Object 等。\n* ‘error’：发送一个javascript的错误或者抛出异常。\n* ’complete‘：停止发送值。\n\nnext类型的通知是最重要也是最常用的一种，它代表了将要传递给观察者的数据。error  和 complete 类型的通知在整个Observable的执行过程中只可以发生一次，并且它们是互斥的，只有一个可以发生。\n\n以正则表达式来表述三者之间的关系的话，应该是：\n\n    next*(error|complete)?\n\n* <font face=\"仿宋\">_在Observable执行的过程中，可以发生0个或无限多个next类型的通知，但是当 error 或 complete 类型的通知中有一个发生后，Observable将不会再传递任何数据。_</font>\n\n下面的代码展示了一个可以产生三个 next 类型通知的 Observable，最后发送一个 complete 通知：\n```js\n    var observable = Rx.Observable.create(function subscribe(observer) {\n        observer.next(1);\n        observer.next(2);\n        observer.next(3);\n        observer.complete();\n    });\n```\nObservable 将严格遵守上述规则，所以试图在Observable完成后继续传递值的行为是无效的。\n```js\n    var observable = Rx.Observable.create(function subscribe(observer) {\n        observer.next(1);\n        observer.next(2);\n        observer.next(3);\n        observer.complete();\n        observer.next(4); // 不会传递成功\n    });\n```\n如果Observable在执行过程中发生异常，我们可以在subscribe函数内部使用 try/catch 块来捕获它：\n```js\n    var observable = Rx.Observable.create(function subscribe(observer) {\n        try {\n            observer.next(1);\n            observer.next(2);\n            observer.next(3);\n            observer.complete();\n        } catch(error) {\n            observer.error(error); // 传递错误\n        }\n    });\n```\n#### 处理Observable\n\n----\n\n由于 Observable 可能产生出无限多个值，但观察者可能在某时间点想停止观察行为，这就需要有一种方法来取消 Observable 的执行。由于每个执行只对应一个观察者，一旦观察者完成接收值，它就需要知道如何停止执行，以避免浪费计算或内存资源。\n\n当我们调用 observable.subscribe 时，观察者会被附加在新创建的可观察上下文中，同时这次调用会返回一个对象，它就是 Subscription 。\n```js\n    var subscription = observable.subscribe(x => console.log(x));\n```\nSubscription 代表了正在执行的上下文，它拥有一个可以取消 Observable 执行的方法——unsubscribe。调用这个方法 subscription.unsubscribe() 就可以取消执行。\n```js\n    var observable = Rx.Observable.from([10,20,30]);\n    var subscription = observable.subscribe(x => console.log(x));\n    // 一段时间以后\n    subscription.unsubscribe();\n```\n* <font face=\"仿宋\">_当你对一个 Observable 进行订阅时，就会获得一个代表当前执行的 Subscription ，只需要调用它的 unsubscribe 方法就可以取消订阅。_</font>\n\n当我们使用 Observable.create 方法来创建 Observable 时，必须定义当取消订阅时如何去释放执行时的资源，此时可以返回一个自定义的 unsubscribe 函数。\n\n我们可以给之前的例子添加上它的 unsubscribe 方法：\n```js\n    var observable = Rx.Observable.create(function subscribe(observer) {\n        var intervalID = setInterval(() => {\n            observer.next(\'hi\');\n        },1000);\n\n        return function unsubscribe() {\n            clearInterval(intervalID);\n        }\n    });\n```\n与 observable.unsubscribe 一样，我们可通过调用 unsubscribe 方法对这个流取消订阅，这两个 unsubscribe 在概念上是完全相同的。\n\n事实上在这个例子中，假如我们把响应式的外壳剥离的话，它完全就是一个普普通通的javascript函数：\n```js\n    function subscribe(observer) {\n        var intervalID = setInterval(() => {\n            observer.next(\'hi\');\n        },1000);\n\n        return function unsubscribe() {\n            clearInterval(intervalID);\n        }\n    }\n\n    var unsubscribe = subscribe({next: (x) => console.log(x)});\n```\n尽管如此，我们依然有理由去使用Rx这种响应式的编程，通过 Observable，Observer，Subscription，配合各种操作符来实现更高效安全的数据处理。\n\n## 观察者——Observer\n\n----\n\n观察者实际就是可观察序列——Observable的消费者。Observer 会设置一些回调函数来对应 Observable 的各个通知类型（next/error/complete)，从这些通知中接收值，然后对它们进行处理。\n\n这是一个很典型的 Observer：\n```js\n    var observer = {\n        next: x => console.log(\'Observer got a next value: \' + x),\n        error: err => console.error(\'Observer got an error: \' + err),\n        complete: () => console.log(\'Observer got a complete notification\')\n    };\n```\n我们可以使用它来观察一个 Observable：\n```js\n    observable.subscribe(observer);\n```\n* <font face=\"仿宋\">_观察者就是一个简单对象，拥有三个方法，每一个方法对应处理可观察序列上的相应类型的通知。_</font>\n\nRxjs中的观察者允许只实现这三个方法中的某几个，这对 Observable 的执行过程不会产生影响，仅仅是被忽略方法的对应通知无法得到处理，因为观察者想要处理相应通知上的数据时必须实现对应的方法。\n\n下面这个示例的 Observer 就没有实现处理 complete 方法：\n```js\n    var observer = {\n        next: x => console.log(\'Observer got a next value: \' + x),\n        error: err => console.error(\'Observer got an error: \' + err),\n    };\n```\n当需要订阅一个 Observable 时，可以只传入一个回调函数作为参数，而不必传入观察者对象：\n```js\n    observable.subscribe(x => console.log(\'Observer got a next value: \' + x));\n```\n实际上在库的内部实现中会根据传入的参数为我们创建出一个 Observer 对象，此时，传入的第一个函数作为next方法的回调，第二个是error回调，第三个是complete回调。也就是说我们可以这样去订阅一个 Observable ：\n```js\n    observable.subscribe(\n        x => console.log(\'Observer got a next value: \' + x),\n        err => console.error(\'Observer got an error: \' + err),\n        () => console.log(\'Observer got a complete notification\')\n    );\n```\n## Subscription\n\n----\n\nSubscription是一个代表着当前正在执行的 Observable 的对象。它有一个非常重要的方法 unsubscribe ，这个方法不接受任何参数，仅仅是用来释放 Observable 执行时的资源。在旧版本的Rxjs中，它也叫做 Disposable 。\n```js\n    var observable = Rx.Observable.interval(1000);\n    var subscription = observable.subscribe(x => console.log(x));\n    // 执行一段时间后\n\n    // 下面的操作将会取消上面已经订阅的 Observable 的执行。\n    subscription.unsubscribe();\n```\n* <font face=\"仿宋\">_Subscription本质上可以只有一个 unsubscribe 方法，用来取消已经订阅的 Observable 的执行。_</font>\n\nSubscription 可以被组合在一起，这样只要调用一次 unsubscribe 方法就可以将多个 Observable 的执行取消掉。我们可以通过 subscription 的 add 方法将它们添加在一起。\n```js\n    var observable1 = Rx.Observable.interval(400);\n    var observable2 = Rx.Observable.interval(300);\n\n    var subscription = observable1.subscribe(x => console.log(\'first: \' + x));\n\n    var childSubscription = observable2.subscribe(x => console.log(\'second: \' + x));\n\n    subscription.add(childSubscription);\n\n    setTimeout(() => {\n        // 取消上面的两次订阅****\n        subscription.unsubscribe();\n    },1000);\n```\n执行后将输出：\n\n    second:0\n    first:0\n    second:1\n    first:1\n    second:2\n\n当然，可以添加，就可以移除，Subscription 同样拥有一个 remove 方法，用来从一组subscription 中移除指定的子 subscription。\n\n## Subject\n\n----\n\nSubject 是 Observable 的一种特殊类型，它允许把值同时传播给多个 Observer，也就是说它是多播的。相比之下，普通的Observable 是单播的，每一个 Observer 在订阅 Observable 时都有其独立的执行上下文。\n\n* <font face=\"仿宋\">_Subject 类似于 Observable ，但它可以把值同时广播给多个观察者。它也类似于一个事件发射器，因此它会维护一个属于自己的监听者列表。_</font>\n\n**每一个 Subject 都是一个 Observable**。你可以提供一个订阅者来订阅 Subject，从而在它上面取值。从观察者的角度来看，并不能区分出数据是从 Subject 上获取的还是从 Observable 上获取的。\n\n在 Subject 的内部实现中，并不会产生新的执行上下文来传递数据，它仅仅是简单的将 Observer 注册在自己的监听者列表中，这与其它的库或语言中添加事件的机制是类似的。\n\n**每一个 Subject 都是一个 Observer**。每一个 Subject 上都有自己的 next，error，complete方法。当需要给 Subject 上添加一个值时，只要调用它的next方法，接下来它就会把这个值广播给注册在监听者列表中的多个监听者。\n\n下面的例子中，我们给 Subject 添加了两个观察者，然后给它添加一些值：\n```js\n    var subject = new Rx.Subject();\n\n    subject.subscribe({\n        next: v => console.log(\'observerA: \' + v)\n    });\n\n    subject.subscribe({\n        next: v => console.log(\'observerB: \' + v)\n    });\n\n    subject.next(1);\n    subject.next(2);\n```\n执行后的输出：\n\n    observerA: 1\n    observerB: 1\n    observerA: 2\n    observerB: 2\n\n由于 Subject 也是一个 Observer ，所以你可以把他传递给一个 Observable 的subscribe方法：\n```js\n    var subject = new Rx.Subject();\n\n    subject.subscribe({\n        next: v => console.log(\'observerA: \' + v)\n    });\n\n    subject.subscribe({\n        next: v => console.log(\'observerB: \' + v)\n    });\n\n    var observable = Rx.Observable.from([1,2,3]);\n\n    observable.subscribe(subject); // 通过 Subject 来订阅这条 Observable\n```\n执行后输出：\n\n    observerA: 1\n    observerB: 1\n    observerA: 2\n    observerB: 2\n    observerA: 3\n    observerB: 3\n\n通过上面的方法，我们基本上就借助 Subject 把一个单播的 Observable 转换成了多播的。这个示例仅仅是演示了一种将一个执行上下文分享给多个观察者的方法。\n\n在 Subject 类型下，还有一些比较特殊的 Subject 类型：BehaviorSubject，ReplaySubject，AsyncSubject。\n\n### 多播的Observable\n\n----\n\n一个‘多播’的 Observable 可以借助于 Subject 实现将数据通知给多个观察者，然而单播的 Observable 仅仅只能把通知发送给一个观察者。\n\n* <font face=\"仿宋\">_多播的 Observable 会使用 Subject 作为钩子来实现将同一个 Observable 的执行传递给多个观察者。_</font>\n\n这就是那些多播的操作符实现时的真实情况：观察者订阅底层的一个 Subject，使用这个 Subject 来订阅产生源数据的 Observable。\n\n下面这个例子和之前那个使用 subject 来订阅 Observable 的例子非常类似：\n```js\n    var source = Rx.Observable.from([1,2,3]);\n    var subject = new Rx.Subject();\n    var multicasted = source.multicast(subject);\n\n   // 使用 subject.subscribe({...}) 实现\n   multicasted.subscribe({\n       next: v => console.log(\'observerA: \' + v)\n   });\n   multicasted.subscribe({\n       next: v => console.log(\'observerB: \' + v)\n   });\n\n    //使用 source.subscribe(subject) 实现\n   multicasted.connect();\n```\n上面代码中的multicast方法返回的 Observable 看起来像一个普通的 Observable，但是当它被订阅时，执行的方式却和 Subject 一样是多播的，同时这个 Observable 还有一个connect方法，可以将多个流串联在一起。\n\n何时调用这个connect方法非常重要，因为它决定了这条可以共享的流什么时间开始执行。由于connect方法在内部执行了 source.subscribe(subject) ，因此它会返回一个 Subscription ，可以通过它来取消这个共享的 Observable 的执行。\n\n#### 引用计数\n\n----\n\n通过手动调用connect方法来得到 Subscription 多少显得有些笨重，通常情况下，我们希望当第一个观察者抵达时可以自动的调用connect方法，当最后一个观察者取消订阅时自动的取消这个共享 Observable 的执行。\n\n请考虑实现如以下列表所概述的订阅：\n\n1. 第一个观察者订阅多播流。\n2. 多播流被connect。\n3. 0 被传递给第一个订阅者。\n4. 第二个观察者订阅这条多播流。\n5. 1 被传递给第一个订阅者。\n6. 1 被传递给第二个订阅者。\n7. 第一个订阅者取消订阅多播流。\n8. 2 被 传递给第二个订阅者。\n9. 第二个订阅者取消订阅多播流。\n10. 取消这条多播流的订阅。\n\n为了达到这个效果，我们需要显式的调用connect方法：\n```js\n    var source = Rx.Observable.interval(500);\n    var subject = new Rx.Subject();\n    var multicasted = source.multicast(subject);\n    var subscription1, subscription2, subscriptionConnect;\n\n    subscription1 = multicasted.subscribe({\n        next: v => console.log(\'observerA: \' + v)\n    });\n\n    // 在这里我们需要显示的调用connect方法以使第一个订阅者可以开始接收值\n    subscriptionConnect = multicasted.connect();\n\n    setTimeout(() => {\n        subscription2 = multicasted.subscribe({\n            next: v => console.log(\'observerB: \' + v)\n        });\n    }, 600);\n\n    setTimeout(() => {\n        subscription1.unsubscribe();\n    },1200);\n\n    // 在这里我们需要把多播流的订阅取消掉，因为从此以后再也没有订阅者订阅它了。\n    setTimeout(() => {\n        subscription2.unsubscribe();\n        subscriptionConnect.unsubscribe();\n    },2000);\n```\n我们可以通过使用 ConnectableObservable 的refCount方法来避免显式的调用connect方法，这个方法会返回一个 Observable 用来追踪当前有多少订阅者正在订阅多播流。当订阅者的数量从0增加到1时，它帮助我们调用connect方法以开始订阅，当订阅者的数量从1变为0时，它帮助我们取消订阅以停止多播流的继续执行。\n\n* <font face=\"仿宋\">_refCount使得多播流在第一个订阅者到达时开始执行，在最后一个订阅者离开后停止执行。_</font>\n\n请看下面的例子：\n```js\n    var source = Rx.Observable.interval(500);\n    var subject = new Rx.Subject();\n    var refCount = source.multicast(subject).refCount();\n    var subscription1, subscription2, subscriptionConnect;\n\n    // 这次调用会执行connect方法\n    console.log(\'observerA subscribed\');\n    subscription1 = refCounted.subscribe({\n        next: v => console.log(\'observerA: \' + v)\n    });\n\n    setTimeout(() => {\n        console.log(\'observerB subscribed\');\n        subscription2 = refCounted.subscribe({\n            next: v => console.log(\'observerB: \' + v)\n        })\n    },600);\n\n    setTimeout(() => {\n        console.log(\'observerA unsubscribed\');\n        subscription1.unsubscribe();\n    }, 1200);\n\n    // 这里会调用多播流的unsubscribe方法\n    setTimeout(() => {\n        console.log(\'observerB unsubscribed\');\n        subscription2.unsubscribe();\n    },2000);\n```\n执行后的输出：\n\n    observerA subscribed\n    observerA: 0\n    observerB subscribed\n    observerA: 1\n    observerB: 1\n    observerA unsubscribed\n    observerB: 2\n    observerB unsubscribed\n\nrefCount方法仅存在于 ConnectableObservable 上，它返回的是一个新的 Observable 而不是另一个 ConnectableObservable 。\n\n### BehaviorSubject\n\n----\n\nBehaviorSubject 是 Subject 的一个变种上，关于它的一个重要概念是’当前值‘。它会把最后一次发送给订阅者的值保存下来，当另外一个订阅者开始订阅时，它会把这个值立即发送给新的订阅者。\n\n* <font face=\"仿宋\">_BehaviorSubject 对于表示随时间变化的值是非常有用的。例如，表示生日的事件流可以用 Subject，但是一个人的年龄的事件流可以用 BehaviorSubject。_</font>\n\n下面的例子中，BehaviorSubject初始化了一个值0，当第一个订阅者开始订阅时，这个值被发送出去。接下来当第二个订阅者开始订阅时，将会接收到值2，即使这个值已经被发送过了。\n```js```js\n    var subject = new Rx.BehaviorSubject(0);\n\n    subject.subscribe({\n        next: v => console.log(\'observerA: \' + v)\n    });\n\n    subject.next(1);\n    subject.next(2);\n\n    subject.subscribe({\n        next: v => console.log(\'observerB: \' + v)\n    });\n\n    subject.next(3);\n```\n执行后的输出：\n\n    observerA: 0\n    observerA: 1\n    observerA: 2\n    observerB: 2\n    observerA: 3\n    observerB: 3\n\n### ReplaySubject\n\n----\n\nReplaySubject 和 BehaviorSubject 很类似，它们都可以把过去的值发送给新的订阅者，不同的是它可以把 Observable 执行时产生的一部分值记录下来。\n\n* <font face=\"仿宋\">_ReplaySubject 记录 Observable 执行时的多个值，并将它们传递给新加入的订阅者。_</font>\n\n在创建 ReplaySubject 时，我们可以指定需要重复发送的值的数量：\n```js\n    var subject = new Rx.ReplaySubject(3); // 传递3个值给新加入的订阅者\n\n    subject.subscribe({\n        next: (v) => console.log(\'observerA: \' + v)\n    });\n\n    subject.next(1);\n    subject.next(2);\n    subject.next(3);\n    subject.next(4);\n\n    subject.subscribe({\n        next: (v) => console.log(\'observerB: \' + v)\n    });\n\n    subject.next(5);\n```\n执行后的输出：\n\n    observerA: 1\n    observerA: 2\n    observerA: 3\n    observerA: 4\n    observerB: 2\n    observerB: 3\n    observerB: 4\n    observerA: 5\n    observerB: 5\n\n还可以指定一个以毫秒为单位的时间，配合记录的数量共同决定究竟有个多少个值需要被重复发送。\n\n下面的这个例子，使用了一个比较大的数量，但是时间上只限制了只发送500毫秒内的值：\n```js\n    var subject = new ReplaySubject(100, 500/* windowTime */);\n\n    subject.subscribe({\n        next: v => console.log(\'observerA: \' + v)\n    });\n\n    var i = 1;\n    setInterval(() => subject.next(i++), 200);\n\n    setTimeout(() => {\n        subject.subscribe({\n            next: v => console.log(\'observerB: \' + v)\n        });\n    },1000);\n```\n第二个订阅者只能接收到最近的500毫秒内发出的值，下面是执行后的输出，\n\n    observerA: 1\n    observerA: 2\n    observerA: 3\n    observerA: 4\n    observerA: 5\n    observerB: 3\n    observerB: 4\n    observerB: 5\n    observerA: 6\n    observerB: 6\n    ...\n\n### AsyncSubject\n\n----\n\n它也是 Subject 的一个变种，AsyncSubject仅在流执行结束后把最后一个值发送给它的订阅者。\n```js\n    var subject = new Rx.AsyncSubject();\n\n    subject.subscribe({\n        next: v => console.log(\'observerA: \' + v)\n    });\n\n    subject.next(1);\n    subject.next(2);\n    subject.next(3);\n    subject.next(4);\n\n    subject.subscribe({\n        next: v => console.log(\'observerB: \' + v);\n    });\n\n    subject.next(5);\n    subject.complete();\n```\n执行后的输出：\n\n    observerA: 5\n    observerB: 5\n\nAsyncSubject 的行为与last操作符的行为非常相似，都是在等待完成后再发送一个值。你应该还记得之前提到的当 Observable 发出Complete通知或Error通知后就不能再发送值，AsyncSubject看起来违背了这个原则，其实不然，我们可以看一下它的源码：\n```js\n    constructor() {\n        super(...arguments);\n        this.value = null;\n        this.hasNext = false;\n        this.hasCompleted = false;\n    }\n    complete() {\n        this.hasCompleted = true;\n        if (this.hasNext) {\n            super.next(this.value);\n        }\n        super.complete();\n    }\n```\n这里只摘录出了AsyncSubject的构造函数和它的complete方法，首先AsyncSubject是继承自Subject的，所以这里的super类就是Subject，那么就很明显了，在AsyncSubject实例上调用complete方法时并没有违背之前提到的原则，依然是先发出了Next通知，最后才发出Complete通知。\n\n## 操作符\n\n----\n\n虽然 Observable 是构建rxjs的基石，但是真正精彩的部分应该是操作符。操作符的组合使用使得以声明式的方式解决复杂的异步场景变得非常简单，它构成rxjs必不可少的一部分。\n\n### 什么是操作符\n\n----\n\n操作符是 Observable 类上的方法，例如： .map(...)，.filter(...)，.merge(...)等。当我们调用它们时，并不会去改变已有 Observable 实例，取而代之的是创建一个全新的 Observable ，它是订阅逻辑是基于第一个 Observable 的。\n\n* <font face=\"仿宋\">_操作符是一个纯函数，它不会改变已有的 Observable 实例，而是基于当前的Observable 创建一个新的 Observable。_</font>\n\n理解操作符时非常重要的一点是时刻谨记它是一个纯函数，它接受一个 Observable 作为输入然后生成一个新的 Observable 作为输出。当订阅输出 Observable 的同时也就订阅了输入 Observable 。\n\n下面的例子中，我们自定义了一个操作函数，它将输入的每一个值都乘以10：\n```js\n    function multiplyByTen(input) {\n        var output = Rx.Observable.create(function subscribe(observer) {\n            input.subscribe({\n                next: v => observer.next(10 * v),\n                error: err => observer.error(error),\n                complete: () => observer.complete()\n            });\n        });\n\n        return output;\n    }\n\n    var input = Rx.Observable.from([1,2,3,4]);\n    var output = multiplyByTen(input);\n    output.subscribe(x => console.log(x));\n```\n执行后的输出：\n\n    10\n    20\n    30\n    40\n\n注意：我们只是订阅了输出-——output，但这同时导致input被订阅，这称之为’操作符的链式订阅‘。\n\n### 实例的操作符 VS 静态操作符\n\n----\n\n通常在提到操作符时，我们指的是 Observable 实例上的操作符。假如上面例子中我们定义的操作函数 multiplyByTen 是一个操作符的话，它看起来应该是这样：\n```js\n    Rx.Observable.prototype.multiplyByTen = function multiplyByTen() {\n        var input = this;\n        return Rx.Observable.create(function subscribe(observer) {\n            input.subscribe({\n                next: v => observer.next(10 * v),\n                error: err => observer.error(err),\n                complete: () => observer.complete()\n            });\n        });\n    }\n```\n* <font face=\"仿宋\">_实例操作符是使用this关键字来推断输入 Observable 的函数。_</font>\n\n在这里输入的 Observable 不再通过 multiplyByTen 的参数获得，而是通过this关键字来获取，这就允许我们可以像下面这样链式的调用：\n```js\n    var observable = Rx.Observable.from([1,2,3,4]).multiplyByTen();\n\n    observable.subscribe(x = console.log(x));\n```\n除了实例操作符，还有静态操作符，它们是直接定义在 Observable 类上的静态方法。静态操作符不会使用this关键字来推断输入，它的输入完全依赖于输入的参数。\n\n* <font face=\"仿宋\">_静态操作符时附加在 Observable 类上的静态函数，通常用来从头创建 Observable。_</font>\n\n常见的静态操作符都是一些可创建类型的操作符，与通常情况下操作符接收输入流，输出输出流不同，它们大多接收一些非 Observable 类型的参数，例如一个数字，然后创建出一条流。\n```js\n    var observable = Rx.Observable.interval(1000 /* 毫秒数 */);\n```\n另外的例子就是create，我们在之前的例子中已经多次使用过了。\n\n然后，静态操作符并非只是那些简单创建流的操作符，一些组合类的操作符也可以有它的静态类型，例如：merge，combineLatest，concat等。这样做的意义在于我们接收多个流作为输入而不仅仅是一个。\n```js\n    var observable1 = Rx.Observable.interval(1000);\n    var observable2 = Rx.Observable.interval(400);\n\n    var merge = Rx.Observable.merge(observable1, observable2);\n```\n#### 弹珠图\n\n----\n\n单纯靠文字可能还不足解释的清楚操作符是如何工作的，许多操作符是与时间相关的，它们可能以不同的方式来影响值的发射，比如：delay，throttle，sample等。对于这些操作符来说图表的形式会更加直观。弹珠图可以模拟出操作符是如何工作的，可以直观的表现出输入流，操作符，参数与输出流之间的联系。\n\n下面来详细解释弹珠图各部分的含义：\n\n    // 这条从左到右的横线代表随时间的推移，输入流的执行过程。\n    // 横线上的值代表从流上发射出的值\n    // 横线尾部的竖线代表complete通知执行的时间点，表示这条流已经成功的执行完成。\n    ----------4------6--------------a-------8-------------|---->\n\n                multipleByTen // 使用的操作符\n\n    // 这条从左到右的横线代表经过操作符转换后的输出流。\n    // 横线尾部的X代表在这个时间点上流发生了错误，至此之后不应该再有 Next 通知或 Complete 通知从流上发出。\n    ---------40-----60--------------X--------------------------->\n\n在整个文档中，我们都使用这种弹珠图来解释操作符是如何工作的。这种弹珠图在其它场景中也是非常有用的，比如在白板演示或者单元测试中。\n\n#### 如何选择合适的操作符\n\n----\n\n如果你明确自己需要解决的问题，但是不清楚应该使用哪一个操作符，可以在官网的 Manual > Operators > Choose an operator 中通过选择符合问题的描述来找到你所需要的操作符。\n\n#### 操作符类别\n\n----\n\n为了解决不同的问题，rxjs针对性的设计了各种各样的操作符，大体上可以分为几类：创建型、转换型、过滤型、组合型、多播型、错误处理型、工具类等等。\n\n关于操作符，将会在专门的文档中进行解释。\n\n### Scheduler\n\n----\n\nScheduler决定了subscription什么时候开始以及什么时候开始分发值。它由3个部分组成：\n\n* 一个Scheduler就是一段数据结构：它知道如何去存储数据，以及基于优先级或其它标准来排列任务的顺序。\n* 一个Scheduler就是一个执行环境：决定什么时间在什么样的环境下去执行任务， 是立即执行还是在回调中执行，亦或是在定时器到达时，还是下一次事件循环开始时执行。\n* Scheduler有自己的虚拟时钟：被调度任务的执行时间只由虚拟时钟决定。只会它的虚拟时钟的环境中执行。\n\n### Scheduler类型\n\n----\n\n* null： 按正常的规则发送值。\n* queue: 按当前事件队列中的顺序来发送值。\n* asap：按更小的单元上的事件队列中的顺序发送值。\n* async: 按异步顺序来发送值。\n\n可以传入scheduler的操作符：\n\n* bindCallback\n* bindNodeCallback\n* combineLatest\n* concat\n* empty\n* from\n* fromPromise\n* interval\n* merge\n* of\n* range\n* throw\n* timer',1,0,0,'[\"rxjs\"]',1,21),(22,'山高路远','2017-02-21 17:03:23','','angularJs 中 $scope 的生命周期','','生命周期，生命对于人而言是再重要不过的东西了，但你不太可能每天去考虑自己离生命结束还有多久，生命周期就更谈不上了，人的生命一旦结束就不会再次进行开始，如果你坚持认为生命有轮回，好吧，我们俩的淡扯不到一块去。但对于$scope来讲，它确实是有生命周期的，也就是说它可以死而复生，而且你一定希望的是在你需要它的时候它就生，不需要它的时候就让它死，听起来有些冷酷无情，但假如它在该死的时候没死，该活的时候没活，那结果可能就是你被它玩到死。生死这词大残酷了，我们还是文雅点，就叫它生命周期吧，开始正题。\n\n## 弄清楚一个问题前我们必须知道它是个什么东西\n\n1. MVC视角仰视，如果你还在认为$scope就是我们的数据模型的话，建议你再好好的温习下google大大对它的定义，必竟这个东西不同于扯淡，我们需要一个严谨的态度。$scope只是MVC中C和V的桥梁，或者官方的说法叫做glue，我觉得这个单词很传神的表达了对$scope的定位。也就是说它的存在会把MVC给贯穿起来，它是否处于生命周期之中，直接影响了MVC之间是否能够彼此互通。那么M呢，它在哪里？别这些文字弄晕，M大多数也存在于$scope上，但又不仅在这里，也可能你把它直接扔在了HTML里，或者存在于某个DOM元素的属性上。\n\n2. 很高大上么，no，no，no，说的直白点，$scope就是一个对象，和我们在js代码里看到的{}没什么不同，不要因为它和MVC厮混在一起就觉得它有多高大上，也不要觉得它名字叫作用域就觉得它好牛叉，它和js中的作用域完全是两个概念。既然是对象，那它也原型，有也在自己的原型链中所处的位置，事实就是这么一回事。\n\n## 今天的主题——生命周期\n\n既然谈周期，那必定有开始，有过程，有结束。\n\n创建——在angularJS1版本中，指令才是大boss，可以说就是它在指点的江山，所在angular应该在启动以后，第一步必须是先找到这些boss，boss能力有大小，有的可以创建scope，有的则不行，比如最常见到的ng-controller和ng-repeate都会创建自己的作用域，有些指令还会创建属于自己的隔离作用域，应用了transclude属性后还会创建隔离作用域的兄弟作用域，前面这句把angular中所有的4种作用域的类型都说了，想要弄清楚自己资料，或者等我哪天心情好了再写吧。至于创建的过程被分成了2个阶段，第一阶段是complie，第二阶段是link，那你猜scope是在哪个阶段创建？如果真的是靠猜的，还是好好查查资料。Compile的时候，angular会把指令对应的模板进行转换，并且对于一个指令的多个实例，angular只会编译一次，很显然这时候生成作用域是不合适的。这里有一个很重要的顺序就是complie从上到下，而link是从下到上的，这样的顺序保证了在进行M和V的链接时，所有的编译工作都已完成。\n\n注册监视——作用域一旦生成，指令就会在它身上注册一个监视，就像我们平时见到的$scope.$watch()，顾名思义监视什么，肯定是去监视数据有没有变化啊，难道还监视隔壁妹子洗澡不成。\n\n模型突变——以上两个过程完成之后，数据和视图之间的链接成功建议，这个时候一旦数据模型发生了变化，就应该做点什么了，当然做什么取决于你。这个时候比如用户在文本框里输入了数据，或者ajax取回的新的数据要应用在程序中，或者用户点击了东西需要我们更改一些数据。这里关键的东西是，假如数据在用户端发生了变化，如何从浏览器的js环境进入到angular的环境中操作在angular模型上的数据，这里偷个懒用下官网的图，但是请记住$scope.$apply，它是从js进入到angular的通道，在应该内置指令时，你不会去调用这个方法是因为angular帮你做了，等于没做。那么当你自己定义指令时，要更新数据时你唯一的选择就是它。\n![angularjs_lifecycle](https://image-static.segmentfault.com/360/712/3607122944-58ab131c00397)\n\n观察——有了变化，我们就要观察这个变化影响的范围到底有多大，那么在进入到angular环境后就会执行那个颇受诟病的脏值检查。既然作用域是原型继承下来的，而且和DOM结构平行，那显然最先应该检查就是rooScope，然后传播到所有的子作用域上，这个时候$watch，设置的一些函数，表达式等就会被执行，相就的改变发生的话就应用你设置好的函数等。\n\n摧毁 ——当我们不在需要一个作用域，需要将它移除掉，原则就是谁创建谁销毁，使用的方法就是$scope.$destroy()，这里如同apply一样，这个方法一要被调用，至于谁调用，参照原则。如果不做呢？good question，不做也不会被枪毙，只是在进行digest循环时，它仍然会被加入其中，增加性能的开销。执行完这个方法后，它占用的内存才能被释放，进而被当成垃圾回收掉。\n\n以上就是scope整个生命周期，请记住这几个关键词：link，regesit，mutation，apply，digest，destory。\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\",\"other\"]',1,22),(23,'山高路远','2017-02-26 10:11:32','','angularJs 中创建 service 的几种方法','','Angular 应用是由许多对象组成，这些对象根据一定的关系被关联在一起，大多数情况下我们并不需要关心它们是如何被组织在一起，以及相互之间是如何进行协作的，但想要更亲近 angular，就必须了解这一过程。\n大体上来说 angular 的对象可以被分为两类，一类是像 services 这种由开发者定义的，用来提供应用所需要的公共 API，一类是由 angular 框架定义好的具有特定用途的对象，比如 controller、filter、directive 等。那么这些对象是如何被定义出来的？除了 injector 外别无它法，但是对于 injector 来说，它需要知道如何去定义这些对象，对于内置的那些对象来说，我们当然不需要插手，angular 为此暴露了 5 个 API，分别是 value()，service()，factory()，constant()，以及最为强大的 provider()，前四个其实就是 provider()的语法糖。虽然对象的创建是由 injector 来完成，但这 5 个方法却是 angular 模块的方法，也就是说我们在调用的时候需要在模块上去调用，例 1：\n\n```js\n    var myModule = angular(“myApp”,[]);\n    myModule.value(“name”,”superMan”);\n```\n\n在 angular 中，所有的服务都是单例对象，也就是说它们只会被调用一次，之后在 injector 中会保存服务的引用，在需要的时候将其当作依赖注入进去。\n\n## value()\n\n例 1 中我们已经定义了一个服务，那么我们就可以在任何需要的时候把它注入到我们的控制器中，例 2：\n\n```js\n    myModule.controller(“myController”,[“name”,function(name){\n        this.name = name;\n    }]);\n\n    <body ng-controller = “myController as con”>\n        Name:{{con.name}}\n    </body>\n```\n\n这样我们就可以成功的拿到这个注册的名字”superMan”，并且可以在视图中正确的读到它。\n它就是如此的简单。\n\n## constant()\n\n这个方法和 value()一样的简单，唯一的不同是，constant()注册的值可以在 angular 运行的配置阶段访问到。例 3：\n\n```js\n    myModule.constant(“prefix”,”ECS”);\n    myModule.config([“prefix”,function(pre){\n        //这里的pre将会被正确的访问\n    }]);\n\n    myModule.config([“name”,function(name){\n        //这里去访问name将会抛出错误，因为此时服务都还没有被注册\n    }]);\n```\n\nangular 应用的生命周期被分为配置和运行两大阶段，在配置阶段，我们所写的服务都还没有注册进来，所以在这个时候去访问通过 value()方法注册的值，是不可访问到的。当然 constant()注册的值在运行阶段也是可以被正确的访问的。也就是说它们一个是全周期可见，一个是只有运行阶段可见。\n\n## factory()\n\n以上两个方法都非常的简单，注册的值也一样的简单，实际情况中我们需要一些更为复杂的服务来提供更加健全的功能。Factory()同它们相比具有更强的能力，1、通过依赖注入可以引用到其它的服务。2、初始化服务。3、延迟加载服务，也就是说在需要的时候 angular 才去初始化。例 4：\n\n```js\n    myModule.factory(\"name\",function nameFactory(){\n        return \"superMan\";\n    });\n```\n\n我们将例 1 中通过 value()注册的值用 factory()重写，这里我们用到了函数，这个函数可以接受一个或多个参数，只要这些参数已经被 angular 注册，它们就能被当作依赖被正确的加载进来，函数的返回值将被作为服务的实例被其引用到。这就给我们提供了更多的可能，我们可以返回一个简单值 ，当然也可以返回个对象或函数，总之看你需要。例 5：\n\n```js\n    myModule.factory(\"fullName\",[\"name\",function fullNameFactory(name){\n        var firstName = \"XX\";\n        var fn = function(f,l){\n            return f + l;\n        }\n        return {\n            name:fn(firstName,name)\n        }\n    }]);\n```\n\n在这里，函数的名字不是必须的，但是最好给它起一个能够很容易辨识的名字，这在调试程序时将会非常有用，一旦出错，你可以很轻易的在堆栈追踪中发现它。\n\n## service()\n\n在面向对象的开发中，我们经常会用到自定义的类，当然，我们可以使用 factory()方法来把这些类注册为服务，例 6：\n\n```js\n    function Person(name){\n        this.name  = name;\n        this.speak = function(){\n            console.log(\"my name is \" + this.name);\n        }\n    }\n    myModule.factory(\"person\",[\"name\",function person(name){\n        return new Person(name);\n    }]);\n```\n\n在创建服务时，service()方法和 factory()方法唯一的不同之处就是它使用 new 运算符来给我们实例化一个对象，也就是这个时候我们应该给 service()传入一个构造函数，构造函数可以接受 0 个或多个参数，这些参数从哪来？当然是依赖注入，既然在 factory()中我们都可以依赖注入，在 service()中当然也可以，用 service()来重写例 6：\n\n```js\n    myModule.service(\"person\",[“name”,Person]);\n```\n\n一目了然，无需多言。\n\n## provider()\n\n前面说过，以上 4 种方法都是 provider()的语法糖，也就是说上面 4 种方法具有的能力，provider()都具有。Providr()的能力是最强大的，但在实际开发中有时候会显的矫枉过正，永远记住，只选最适合你的。\n\n对于 provider()而言，它必须有一个$get()方法，这是区别于上面 4 种方法最为明显的地方，对于$get()的参数，可能通过依赖注入来获取，这个函数就像 factory()的工厂函数，实际上对于 factory()而言，angular 会自动给它的函数设置一个空的$get()方法。\n\n另外，前面我们提到过 angular 应用生命周期的 2 个阶段，如同 constant()方法，provider()方法当然也可以在配置阶段运行，因此，对于 provider()它最适用的场景就是在应该启动前给我们暴露一些 API，以便我们可以通过这些 API 对应用进行配置。它注册的服务应该是我们希望在不同的应用间可以重用，且服务的行为在各有应用间非常一致，或者说变化非常小。\n\n```js\n    myModule.provider(\"speakName\",function speakNameProvider(){\n    var firstName = \"\";\n    this.addFirstName = function(f){\n        console.log(“my firstName is:” + f);\n        firstName = f;\n    }\n        this.$get= [\"name\",function speakNameFactory(name){\n            var fullName = firstName + name;\n            return new Person(fullName);\n        }];\n    });\n```\n\n假如我们希望在应用配置阶段加上一个姓，那么就可以通过暴露的 API 实现\n\n```js\n    myModule.config([\"speakNameProvider\",function(speakNameProvider){\n        speakNameProvider.addFirstName(\"XXX\");\n    }]);\n```\n\n回到开头说的，angular 的对象分为两类，对于我们可以定义的，前面已经介绍完了，对于 angular 已经内置的一些对象，我们在使用时候必须遵循它的规则，比如 controller、directive、filter 等。当然我们定义好的这些服务可以被作为依赖注入到这些特殊对象中，比如：\n\n```js\n    myModule.directive(\"myName\",[\"name\",function myName(name){\n        return {\n            restrict:\"EA\",\n            scope:{},\n            link:function(scope,ele,attrs){\n                ele.text(\"name:\" + name);\n            }\n        }\n    }]);\n```\n\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\",\"other\"]',1,23),(24,'山高路远','2018-03-05 11:55:00','','官方操作符翻译（一）','聚合类','## count\n\n----\n实例方法\n\n统计流上发出的值的数量，当流结束时发出最后的统计结果。\n\n* <font face=\"仿宋\">_统计输入流上一共发出了多少值。_</font>\n\n        ------a-----------b----------c------|-->\n\n                    count\n\n        ------------------------------------3|-->\n\n此操作符将输入流转换成一个发出输入流的值的统计数量的输出流。如果输入流上发出错误，输出流将会传递这个错误而不会发出正确的统计结果。如果输入流上一直没有发出结束通知，输出流将始终不会发射值。这个操作符可以接受一个可选的判定函数，在这个种情况下，输出流的结果是输入流上判定结果为true的值的个数。\n\n| Name      | Type                                                          | Attribute | Description                                                                                                                                                                |\n| --------- | :-----------------------------------------------------------: | :-------: | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |\n| predicate | function(value: T, i: number, source: Observable<T>): Boolean | 可选      | 判定函数，用于判定输入流的值是否应该加入统计数量，为true时计入，反之不计入。这个判定函数接受3个参数，value：输入流上的值。index：输入流上值的索引，以0开始，source：输入流 |\n\n## max\n\n----\n实例方法\n\n此操作符操作一个发出数字（或者可以使用提供的函数进行比较的值）的流，当源 Observable 完成时输出流上的最大值。\n\n    ----------23---------2---------3-------34-------|-->\n\n                min\n\n    ------------------------------------------------34|>\n\n参数\n\n| Name     | Type     | Attribute | Description                |\n| -------- | :------: | :-------: | -------------------------: |\n| comparer | Function | 可选      | 比较函数，用来比较流上的值 |\n\n返回值\n\n    Observable 输出最小值的流。\n\n示例\n```ts\n    Rx.Observable.of(5, 4, 7, 2, 8)\n        .min()\n        .subscribe(x => console.log(x));\n\n    interface Person {\n        age: number;\n        name: string;\n    }\n\n    Observable.of(\n       {age: 7, name: \'Foo\'},\n       {age: 5, name: \'Bar\'},\n       {age: 9, name: \'Beer\'}\n    )\n    .min((a, b) => a.age < b.age ? -1 : 1)\n    .subscribe(x => console.log(x.name));\n```\n## min\n\n----\n实例方法\n\n此操作符操作一个发出数字（或者可以使用提供的函数进行比较的值）的流，当源 Observable 完成时输出流上的最小值。\n\n    ----------23---------2---------3-------34-------|-->\n\n                min\n\n    ------------------------------------------------2|>\n\n参数\n\n| Name     | Type     | Attribute | Description                |\n| -------- | :------: | :-------: | -------------------------: |\n| comparer | Function | 可选      | 比较函数，用来比较流上的值 |\n\n返回值\n\n    Observable 输出最小值的流。\n\n示例\n```ts\n    Rx.Observable.of(5, 4, 7, 2, 8)\n        .min()\n        .subscribe(x => console.log(x));\n\n    interface Person {\n        age: number;\n        name: string;\n    }\n\n    Observable.of(\n       {age: 7, name: \'Foo\'},\n       {age: 5, name: \'Bar\'},\n       {age: 9, name: \'Beer\'}\n    )\n    .min((a, b) => a.age < b.age ? -1 : 1>)\n    .subscribe(x => console.log(x.name));\n```\n## reduce\n\n----\n实例方法\n\n在源 Observable 上应用一个累积函数，当源 Observable 结束时把累积的值推送给输出流，可以接受一个初始的累积值。\n\n* <font face=\"仿宋\">_把源 Observable 上发出的所有值累积起来，使用一个累积函数来累积这些值。_</font>\n\n        --------1-------2-------3---|-->\n\n                reduce((acc,cur) => acc + cur, 0);\n\n        ----------------------------4|\n\n这个操作符的行为与数组的reduce方法相同。使用一个累积函数来处理流上的每一值，前一次累积后的值将作为下一次累积的初始值，把通过累积得到的最终值推送给输出流。注意，reduce操作符只会在源 Observable 发出结束通知后发出一个值，这相当于在使用 last 操作符后又使用了 scan 操作符。\n\n源 Observable 上发出的值都会被累积函数处理。如果提供了初始值，这个值将成为整个累积过程的初始值，如果没有提供的话，从源 Observable 发出的第一个值就是整个累积过程的初始值。\n\n参数\n\n| Name        | Type                                      | Attribute | Description |\n| ----------- | :---------------------------------------: | :-------: | ----------: |\n| accumulator | function<R,T>(acc:R,cur:T,index:number):R |           | 累积函数    |\n| seed        | R                                         | 可选。    | 初始值      |\n\n返回值\n\nObservable 把源 Observable 上的值都经过累积函数计算后得到的值作为值发送的流。\n\n示例\n```ts\n    var clicksInFiveSeconds = Rx.Observable.fromEvent(document, \'click\')\n                                .takeUntil(Rx.Observable.interval(5000));\n    var ones = clicksInFiveSeconds.mapTo(1);\n    var seed = 0;\n    var count = ones.reduce((acc,cur) => acc + cur, seed);\n\n    count.subscribe(v => console.log(v));\n```\n\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"rxjs\"]',1,24),(25,'山高路远','2018-03-05 13:20:28','','官方操作符翻译（二）','组合类','## combineAll\n\n----\n静态方法\n\n将高阶流转换成一阶流。当输入流完成后，内部使用combineLatest把内部流转化成输出流。\n\n* <font face=\"仿宋\">_使用combineLatest将高阶流打平成低阶流。_</font>\n\n        -------------------------------------|-------------------------------->\n            \\          \\---1---2--|->         \\---1---2--|->\n             \\--a--b-|->                      \\--a--b--|->\n\n                    combineAll\n\n        -------------------------------------|-a1-b1-b2-|->\n\n从一个高阶流上收集内部流，当高阶流完成后，开始订阅所有的内部流，使用combineLatest的方式把所有值合并到输出流上。\n\n    - 每当内部流发出值时，输出流都会发出值。\n    - 输出流上发出的值取决于是否提供了聚合函数：\n        - 提供聚合函数时：聚合函数按次序接收每个内部流上的最新值，把运行的结果传递给输出流。\n        - 未提供聚合函数时：把各个内部流的最新值按次序以数组的形式传递给输出流。\n\n| Name    | Type     | Attribute | Description                                                                  |\n| ------- | :------: | :-------: | ---------------------------------------------------------------------------: |\n| project | function | 可选      | 聚合函数，可以按次序接收各个内部流的最新值，函数运行后的结果将传递给输出流。 |\n\n返回值\n\nObservable 输出各内部流的值聚合后的结果的流。\n\n示例\n```ts\n    Rx.Observable.fromEvent(document, \'click\')\n        .map(event => Rx.Observable.interval(Math.random()*200).take(3))\n        .take(2)\n        .combineAll()\n        .subscribe(x => console.log(x));\n```\n## combineLatest\n\n----\n实例方法\n\n将多个输入流组合成一个输出流，输出流上的数据是由每一条输入流上的最后一条数据组合成的数据。\n\n* <font face=\"仿宋\">_无论什么时间只要输入流上发出了数据，它就会把所有输入流上的最新数据组合成一条新的数据推送到输出流上。_</font>\n\n        -a------b----c-----d------e---|\n\n        --1--2-----3--4-----5---6---|\n\n                combineLatest\n\n        --a1-a2-b2--b3-c3-c4----d4-d5---e5-e6-|\n\ncombineLatest把源 Observable 上的值和作为参数传递进来的 Observable 的值组合了起来。它的实现方式是通过订阅每一条Observable，将它们发出的最新值以数组的方式收集起来再推送到输出流上，当然也可以先传递给一个映射函数，由映射函数先把值处理后再推送到输出流上。\n\n参数\n\n| Name    | Type            | Attribute | Description                                |\n| ------- | :-------------: | :-------: | -----------------------------------------: |\n| other   | ObservableInput |           | 用来进行组合的输入流，可以输入多条输入流   |\n| project | function        | 可选      | 用于将组合后的值映射成一个新值发送给输出流 |\n\n返回\n\nObservable 一条包含所有输入流最新值的流，或者是所有最新值的映射值的流。\n\n示例\n```ts\n    var weight = Rx.Observable.of(70,72,76,79,75);\n\n    var height = Rx.Observable.of(1.76,1.77,1.78);\n\n    var bmi = weight.combineLatest(height, (w, h) => w/h*h);\n\n    bmi.subscribe(x => console.log(\'BMI is \' + x);\n```\n## concat\n\n----\n实例方法\n\n在当前的流发出值后，按照输入流的顺序再依次发出各输入流上发出的值。\n\n* <font face=\"仿宋\">_将多个流按顺序连接起来，依次发出输入流上发出的值。_</font>\n\n        ----a-------b--|-->\n\n                        -------c-----d----|>\n\n                    concat\n\n        ----a-------b----------c-----d----|>\n\n将源 Observable 和 其它的 Observable 连接起来。从源 Observable 开始逐个订阅输入流，并将获取到的值传递给输出流。在开始订阅下一个输入流之前必须保证当前的流已经发出了结束通知。\n\n参数\n\n| Name      | Type            | Attribute        | Description              |\n| --------- | :-------------: | :--------------: | -----------------------: |\n| other     | ObservableInput |                  | 将要被连接的流           |\n| scheduler | Scheduler       | 可选。默认：null | 调节对每一条输入流的订阅 |\n\n返回值\n\nObservable 按顺序排列的所有输入流的值构成的流。\n\n示例\n```ts\n    var timer = Rx.Observable.interval(1000).take(4);\n    var sequence = Rx.Observable.range(1,10);\n    var result = time.concat(sequence);\n\n    result.subscribe(v => console.log(v));\n\n    var timer1 = Rx.Observable.interval(1000).take(10);\n    var timer2 = Rx.Observable.interval(2000).take(6);\n    var timer3 = Rx.Observable.interval(500).take(10);\n    var result = timer1.concat(timer2, timer3);\n\n    result.subscribe(x => console.log(x));\n```\n## concatAll\n\n----\n实例方法\n\n通过把内部流串联起来的方式把高阶流打平成一阶流。\n\n* <font face=\"仿宋\">_把内部流按次序连接起来作为输出流。_</font>\n\n        -----------------------------------|----------------------------|-->\n             \\a----b---|->   \\-1--2--|->\n\n                     concatAll\n\n        -----------------------------------a----b---------1--2--|->\n\n连接所有从输入流上发出的内部流。这个操作符会依次监听每一个内部流，也就是说只有当一个内部流发出完成通知后它才会继而监听下一个，然后将监听得到的所有值依次发送给输出流。\n\n注意：如果输入流迅速且无止境的发出内部流，而内部流发出结束通知的时间比输入流慢，那么在不设置缓冲区时可能会面临内存问题。\n\nconcatAll 和 mergeAll使用并发参数为1时的行为是相同的。\n\n返回值\n\nObservable 依次发出所有内部流上的值的流。\n\n示例\n```ts\n    Rx.Observable.fromEvent(document, \'click\')\n        .map(event => Rx.Observable.interval(1000).take(4))\n        .concatAll()\n        .subscribe(v => console.log(v));\n```\n## exhaust\n\n----\n实例方法\n\n将高阶流打平成一阶流，如果在一个内部流完成之前又有一个新内部流开始发射值，那么新的内部流将被忽略。\n\n* <font face=\"仿宋\">_当前的内部流正在发射值时忽略掉新产生的内部流。_</font>\n\n        -------------------------------------------------|-->\n                \\      \\                  \\--1---2--3--4-|->\n                 \\      \\--e---f---g---h--i-|->\n                  \\---a----b----c----d-|->\n\n                    exhaust\n\n        --------a----b----c----d-------------1---2--3--4-|->\n\n此操作符将会订阅一个高阶流，当高阶流发出内部流时输出流开始订阅内部流，如果在订阅一个内部流期间又一个新的内部流到达而正在订阅的内部流又没有结束，这个新流将会被忽略。只有当前订阅的内部流完成后才会开始订阅下一个内部流。简而言之就是只有当前流的值都耗尽后才可能执行新的订阅。\n\n返回值\n\nObservable 输出流的上必然输出第一条内部流的值，其它的内部流的值是否会在输出流上取决于上述的规则。\n\n示例\n```ts\n    Rx.Observable.fromEvent(document,\'click\')\n        .map(event => Rx.Observable.interval(1000).take(5))\n        .exhaust()\n        .subscribe(v => console.log(v));\n```\n## forkJoin\n\n----\n静态方法\n\n将输入流的最后一个值合并后传给输出流。\n\n* <font face=\"仿宋\">_等待输入流结束，然后将最后发出的值传给输出流。_</font>\n\nforkJoin可以以参数或数组的形式接收任意数量的输入流。如果没有转入输入流，输出流将会立即发出结束通知。\n\n它会等所有的输入流发出结束通知，然后发出一个包含所有输入流发出的最终值组成的数组，因此，传入n条输入流，得到的数组中将包含n个元素，每一个元素都是从对应顺序的输入流上取到的最后一个值。这也就意味着输出流只会发出一个值，紧接着就会发出结束通知。\n\n为了使用输出流上获取到的数组的长度与输入流的数量保持一致，如果某一个输入流在发出结束通知之前没有发出过任何有效值，那么输出流也将会立刻结束并且不再发出任何值，尽管其它的输入流上可能会发出有效值。反过来，假如有一条输入流一直没有发出结束通知，输出流也不会发出值，除非另外一条输入像之前描述的那样只发了结束通知。总的来说就是为了让输出流发出值，所有的输入流都必须发出结束通知而且在此之前必须至少发出一个有效值。\n\n如果输入流中的某一条发出了错误通知，输出流将会立即发出这个错误通知，并且立即取消对其它流的订阅。\n\n此外，forkJoin还可以接受一个可选的映射函数，它会接受从各输入流上得到的值作为参数，然后把这些值映射成另外一个值发送给输出流。也就是说你可以认为默认的映射函数是把这些值放入一个数组里交给了输出流。注意这个函数只有在输出流准备发出值的时候才会被调用一次。\n\n        ----2---3------4----5--|-->\n\n        ----a----b------------d---|-->\n\n                    forkJoin\n\n        --------------------------5d|\n\n参数\n\n| Name    | Type                     | Attribute | Description                                              |\n| ------- | :----------------------: | :-------: | -------------------------------------------------------: |\n| sources | ...SubscribableOrPromise |           | 任意数量的输入流，可以直接以参数的形式或者放在数组中传入 |\n| project | function                 | 可选      | 接受所有输入流产生的值作为参数，输出一个值给输出流       |\n\n返回值\n\nObservable 以数组形式获取到的每一个输入流的值，或者来自映射函数的值。\n\n示例\n```ts\n    const observable = Rx.Observable.forkJoin(\n        Rx.Observable.of(1, 2, 3, 4),\n        Rx.Observable.of(5, 6, 7, 8)\n    );\n\n    observable.subscribe(\n        value => console.log(value),\n        err => {},\n        () => console.log(\'This is how it ends!\')\n    );\n----\n    const observable = Rx.Observable.forkJoin(\n        Rx.Observable.interval(1000).take(3),\n        Rx.Observable.interval(500).take(4)\n    );\n\n    observable.subscribe(\n        value => console.log(value),\n        err => {},\n        () => console.log(\'This is how it ends!\')\n    );\n----\n    const observable = Rx.Observable.forkJoin(\n        Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete\n        Rx.Observable.interval(500).take(4), // emit 0, 1, 2, 3 every half a second and complete\n        (n, m) => n + m\n    );\n\n    observable.subscribe(\n        value => console.log(value),\n        err => {},\n        () => console.log(\'This is how it ends!\')\n    );\n```\n## merge\n\n----\n实例方法\n\n创建一条可以同时把所有输入流的值推送出去的流。\n\n* <font face=\"仿宋\">_把多条输入流打平成一条输入流，所有输入流的值都可以在这条输出流上得到。_</font>\n\n        -a----------b----------c---|----->\n\n        ------d---------e----------e----|-->\n\n                    merge\n\n        -a----d----b----e-----c----e----|-->\n\n合并所有输入流的订阅，不管是源 Observable 还是作为参数输入的 Observable，只是把值依次推送到输出流上，不作任何额外的更改。输出流只有在所有的输入流都完成以后才能完成，任何一条输入流上的错误都将立即推送到输出流上。\n\n参数\n\n| Name       | Type            | Attribute                              | Description                                  |\n| ---------- | :-------------: | :------------------------------------: | -------------------------------------------: |\n| other      | ObservableInput |                                        | 用来进行组合的流，可以传递多个输入流作为参数 |\n| concurrent | number          | 可选。默认值：Number.POSITIVE_INFINITY | 允许同时订阅的输入流的最大数量               |\n| scheduler  | Scheduler       | 可选。默认值：null                     | 用来调节输入流的并发                         |\n\n返回值\n\nObservable 可以发送所有输入流上的值的Observable。\n\n示例\n```ts\n    var clicks = Rx.Observable.fromEvent(document, \'click\');\n    var timer = Rx.Observable.interval(1000);\n    var clicksOrTimer = clicks.merge(timer);\n\n    clicksOrTimer.subscribe(x => console.log(x)); ---- var timer1 = Rx.Observable.interval(1000).take(10); var timer2 = Rx.Observable.interval(2000).take(6);\n    var timer3 = Rx.Observable.interval(500).take(10);\n    var concurrent = 2;\n\n    // 这里只允许同时订阅2条，所以它的输出流的行为是先发出timer1和timer2上的值，\n    // 10秒过后当timer1发出完成通知后，开始同时发射timer2和timer3的值，所有输入流\n    // 的值都发射完成后再发出完成通知。\n    var merged = timer1.merge(timer2,timer3,concurrent);\n\n    merged.subscribe(v => console.log(v));\n```\n## mergeAll\n\n----\n实例方法\n\n将高阶流打平成一阶流，并行发送所有内部流的值。\n\n    -------------------------------------|---->\n        \\               \\-1-2--3-4--5--6-|->\n         \\-a--b--c--d--e--f--g--h--i-|->\n\n            mergeAll\n\n    ------a--b--c--d--e--f-1-2-g-3-j-4-i-5--6-|->\n\n此操作符订阅所有的内部流，并把所有内部流上发射的值传送给输出流。只有当所有的内部流都完成时输出流才会发出完成通知。如果有一个内部流发出错误通知，这个错误会立即被发送给输出流。\n\n参数\n\n| Name       | Type   | Attribute                            | Description              |\n| ---------- | :----: | :----------------------------------: | -----------------------: |\n| concurrent | number | 可选。默认：Number.POSITIVE_INFINITY | 并发订阅内部流的最大数量 |\n\n返回值\n\nObservable 并行输出所有内部流的值的流\n\n示例\n```ts\n    Rx.Observable.fromEvent(document,\'click\')\n        .map(event => Rx.Observable.intervl(1000))\n        .mergeAll()\n        .subscribe(v => console.log(v));\n\n    Rx.Observable.fromEvent(document, \'click\')\n        .map(event => RxObservable.interval(1000).take(10))\n        .mergeAll(2)\n        .subscribe(v => console.log(v));\n```\n## race\n\n----\n实例方法\n\n把最先开始输出值的流作为输出流。\n\n    --------a-------b-----c------|-->\n\n    ---1------3------|-->\n\n                race\n\n    ---1------3------|-->\n\n参数\n\n| Name           | Type           | Attribute | Description      |\n| -------------- | :------------: | :-------: | ---------------: |\n| ...observables | ...observables |           | 参与竞赛的输入流 |\n\n返回值\n\nObservable 第一条发出值的输入流的镜像。\n\n示例\n```ts\n    const first = Rx.Observable.of(\'first\')\n        .delay(100)\n        .map(_ => throw \'error\');\n\n    const second = Rx.Observable.of(\'second\').delay(200);\n\n    const third = Rx.Observable.of(\'third\').delay(300);\n\n    Rx.Observable.race(first, second, third)\n        .subscribe(v => console.log(v));\n\n    ----\n\n    Rx.Observable.interval(2000)\n        .race(\n            Rx.Observable.interval(1000),\n            Rx.Observable.fromEvent(document, \'click\')\n        )\n        .subscribe(v => console.log(v));\n```\n## startWith\n\n----\n实例方法\n\n在发送流上的数据时，先将传入此操作符的参数作为流上的第一个值发送出去。\n\n    -------a--------b-------c--|-->\n\n                startWith(s)\n\n    s------a--------b-------c--|-->\n\n参数\n\n| Name      | Type      | Attribute | Description                |\n| --------- | :-------: | :-------: | -------------------------: |\n| value     | ...T      |           | 输出流上发出的第一个值     |\n| scheduler | Scheduler | 可选。    | 用来调节Next通知上发出的值 |\n\n返回值\n\nObservable 先发出指定的参数，然后再发出输入流上的值。\n\n示例\n```ts\n    var source = Rx.Observable.interval(1000);\n\n    source.startWith(\'start\')\n        .subscribe(v => console.log(v));\n```\n## switch\n\n----\n实例方法\n\n通过取消之前的订阅，重新订阅最新的内部流来把高阶流打平成一阶的流。\n\n* <font face=\"仿宋\">_打平高阶流，当有新的流到达时，立即放弃对之前的流的订阅。_</font>\n\n        -------------------------------|-------->\n            \\          \\----e----f---|>\n             \\---a---b-----c---d---|->\n\n                    switch\n\n        -----------a---b-----e----f---|\n\nswitch用来订阅一个高阶流（发出流的流）。一个内部流被源 Observable 发出后，它就会被输入流订阅，并且将条内部流上的值传递到输出流上，比时它的行为和mergeAll是一样的，但是当下一个新的内部流被发出后，switch将会取消之前订阅的那条内部流，继而转向订阅这条新的内部流。\n\n返回值\n\nObservable 从源 Observable 上取到的最新的内部流。\n\n示例\n```ts\n    var clicks = Rx.Observable.fromEvent(document, \'click\');\n    var higherOrder = clicks.map(event => Rx.Observable.interval(1000));\n    var switched = higherOrder.switch();\n\n    switched.subscribe(v => console.log(v));\n```\n## withLatestFrom\n\n----\n实例方法\n\n将多个输入流组合成一个输出流，输出流上的数据是由每一条输入流上的最后一条数据组合成的，但是组合动作只在源 Observable 发出值时发生。\n\n* <font face=\"仿宋\">_当源 Observable 上发出值时，它会从所有的输入流上获取值，将它们组合成一个新的值推送给输出流。_</font>\n\n        -a-----b--------------c------------d--e---|-->\n\n        ----1-----2-----3--4--------5----|---->\n\n                withLatestFrom\n\n        ------b1------------c4-----------d5--e5---|-->\n\ncombineLatest将源 Observable 上的值和以参数形式传入的 Observable 上的值组合起来发送给输出流，只有当源 Observable 上发出值时才进行组合。还可以传入一个映射函数处理组合后的值。需要注意的是，只有当所有的输入流都发出过值以后输出流上才会产生值。\n\n参数\n\n| Name    | Type            | Attribute | Description                                                                        |\n| ------- | :-------------: | :-------: | ---------------------------------------------------------------------------------: |\n| other   | ObservableInput |           | 用来进行组合的输入流，可以输入多条输入流                                           |\n| project | function        | 可选      | 用于将组合后的值映射成一个新值发送给输出流。所有输入流的值依次作为参数传入此函数。 |\n\n返回值\n\nObservable 一条包含所有输入流最新值的流，或者是所有最新值的映射值的流。\n\n示例\n```ts\n    var clicks = Rx.Observable.fromEvent(document, \'click\');\n    var timer = Rx.Observable.interval(1000);\n    var result = clicks.withLatestFrom(timer)\n\n    result.subscribe(x => console.log(x));\n```\n## zip\n\n----\n实例方法\n\n如果所有的输入都是流，那么将所有输入流对应位置上的值组合成一个新值，将这个新值作为输出流上的正常值。此外zip操作符还可以直接使用可转化为流的数据作为参数，比如数组，promise，字符串等。\n\n    --a------b------c------d---2--|->\n\n    -----e------f------g-----h--|->\n\n                zip\n\n    ----ae------fb-----gc----hd-|->\n\n返回值\n\nObservable 将各输入流上对应的值组合成新的值发送给输出流或者先经过映射函数处理后再发送给输出流。\n\n参数\n\n| Name        | Type     | Attribute | Description                                                       |\n| ----------- | :------: | :-------: | ----------------------------------------------------------------: |\n| observables | any      |           | 用来组合的流或者它可以转化成流的值，比如promise，数组，字符串等。 |\n| project     | function | 可选      | 可选的映射函数，将组合后的值映射成新的值推送给输出流。            |\n\n示例\n```ts\n    var obs1 = Rx.Observable.from([1,2,3,4]);\n    var obs2 = Rx.Observable.from([\'a\',\'b\',\'c\']);\n\n    obs1.zip(obs2)\n        .subscribe(v => console.log(v));\n----\n    var obs1 = Rx.Observable.interval(1000);\n    var obs2 = Rx.Observable.from([\'a\', \'b\',\'c\']);\n\n    obs1.zip(obs2,(clock, letter) => letter + clock)\n        .subscribe(v => console.log(v));\n----\n    var obs = Rx.Observable.interval(1000);\n    var promise = new Promise(resolve => {\n        setTimeout(() => resolve(\'hello\'), 2000);\n    });\n\n    obs.zip(promise, (obs, promise) => promise + obs)\n        .subscribe(v => console.log(v));\n```\n## zipAll\n\n----\n实例方法\n\n参数\n\n| Name        | Type     | Attribute | Description                                                       |\n| ----------- | :------: | :-------: | ----------------------------------------------------------------: |\n| project     | * |       |      |\n\n返回值\n\nObservable\n\n示例\n```ts\n    const obs1 = Rx.Observable.interval(1000).take(5);\n\n    const obs2 = Rx.Observable.interval(1000).mapTo(\'a\').take(4);\n\n    Rx.Observable.of(obs1,obs2)\n        .zipAll()\n        .subscribe(v => console.log(v));\n\n    ----\n\n    Rx.Observable.of(obs1, obs2)\n        .zipAll((a, b) => a + b)\n        .subscribe(v => console.log(v));\n```\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"rxjs\"]',1,25),(26,'山高路远','2018-03-05 22:02:59','','官方操作符翻译（三）','条件类','## defaultIfEmpty\n\n----\n实例方法\n\n如果源 Observable 上没有发出过任何有效值，则使用传入这个操作符的参数作为输出流的有效值。\n\n* <font face=\"仿宋\">_源 Observable 上没有发出有效值就结束了的话，使用这个值作为输出流的默认值。_</font>\n\n        --------------------------|>\n\n                defaultIfEmpty(48);\n\n        --------------------------48|>\n\n如果源 Observable 没有发出过有效值，则使用这个值作为默认值，反之，使用源 Observable 上发出的值。\n\n| Name         | Type  | Attribute          | Description                          |\n| ------------ | :---: | :----------------: | -----------------------------------: |\n| defaultValue | any   | 可选。默认值：null | 当源 Observable 是空的时候的默认值。 |\n\n返回值\n\nObservable 一个要么发出源 Observable 上的值，要么发出一个默认值的流。\n\n示例\n```ts\n    var clicks = Rx.Observable.fromEvent(document, \'click\');\n    var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));\n    var result = clicksBeforeFive.defaultIfEmpty(\'no clicks\');\n\n    result.subscribe(x => console.log(x));\n```\n## every\n\n----\n实例方法\n\n创建一个发出布尔值的流，true表示源 Observable 的值都可以通过判定函数的检测，false 表示某些值无法通过判定函数检测。\n\n    -----1---------2------3-------4------5----|--->\n\n                every(x => x < 10);\n\n    ------------------------------------------true|>\n\n返回值\n\nObservable\n\n示例\n```ts\n    Rx.Observable.of(1,2,3,4,5)\n        .every(x => x < 6)\n        .subscribe(x => console.log(x));\n```\n## find\n\n----\n实例方法\n\n发射出从流上找到的第一个符合给定条件的值。\n\n* <font face=\"仿宋\">_找到第一个符条件的值，将它发送给输出流。_</font>\n\n        ----2--------10-----------4-----------25--------|-->\n\n                find(x => x%5 ===0);\n\n        -------------10|>\n\n从源 Observable 上查找第一个通过判定函数的值，将它发送给输出流。和first操作符不同的是，它必须接收一个判定函数，而且在没有找到有效值的情况下不会发出错误通知。\n\n| Name         | Type  | Attribute          | Description                          |\n| ------------ | :---: | :----------------: | -----------------------------------: |\n| predicate | function<T>(value: T, index: number, source: Observable<T>):boolean   | | 判定函数 |\n| thisArg | any | 可选 | 用来决定判定函数内部的this指向 |\n\n返回值\n\nObservable 发出源 Observable 上能过判定函数检测的第一个值的流。\n\n示例\n```ts\n    var clicks = Rx.Observable.fromEvent(document, \'click\');\n    var result = clicks.find(ev => ev.target.tagName === \'DIV\');\n\n    result.subscribe(v => console.log(v));\n```\n## findIndex\n\n----\n实例方法\n\n发出源 Observable 上第一个通过判定函数检测的值的索引。\n\n* <font face=\"仿宋\">_各find操作符的行为类似，只不过它发出的不是值，而是值的索引。_</font>\n\n        ----2--------10-----------4-----------25--------|-->\n\n                find(x => x%5 ===0);\n\n        -------------2|>\n\n从源 Observable 上查找第一个通过判定函数的值，将它的索引发送给输出流。和first操作符不同的是，它必须接收一个判定函数，而且在没有找到有效值的情况下不会发出错误通知。\n\n| Name         | Type  | Attribute          | Description                          |\n| ------------ | :---: | :----------------: | -----------------------------------: |\n| predicate | function<T>(value: T, index: number, source: Observable<T>):boolean   | | 判定函数 |\n| thisArg | any | 可选 | 用来决定判定函数内部的this指向 |\n\n返回值\n\nObservable 发出源 Observable 上能过判定函数检测的第一个值的索引的流。\n\n示例\n```js\n    var clicks = Rx.Observable.fromEvent(document, \'click\');\n    var result = clicks.findIndex(ev => ev.target.tagName === \'DIV\');\n\n    result.subscribe(v => console.log(v));\n```\n## isEmpty\n\n----\n实例方法\n\n如果源 Observable 没有发出过任何有效值，输出流发出true，反之，发出false。\n\n    --------------------------------|->\n\n                isEmpty\n\n    --------------------------------true|>\n\n返回值\n\n    Observable 一个发出 true 或 false 的流。\n\n示例\n```ts\n    var source = Rx.Observable.empty();\n\n    source.isEmpty()\n        .subscribe(v => console.log(v));\n```\n\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"rxjs\"]',1,26),(27,'山高路远','2018-03-06 00:25:30','','官方操作符翻译（四）','创建类','## bindCallback\n\n----\n静态方法\n\n将回调API转化成一个返回值为Observable的函数。\n\n* <font face=\"仿宋\">_给它一个签名为f(x, callback)的函数f,返回一个函数g, 调用\'g(x)\'的时候会返回一个 Observable。_</font>\n\nbindCallback不能称之为一个操作符，因为它的输入和输出都不是一个 Observable。它的输入必须是一个函数，这函数的最后一个参数必须是一个回调函数，当输入函数执行完成时调用此回调函数。它的输出也是一个函数，这函数的参数除了最后一个不是回调函数外，其它的和输入函数完成相同。当输出函数被调用时，它会返回一个流，如果输入函数调用回调函数时只传入了一个参数，这个参数将会在流上输出，如果输入函数调用回调函数时传入了多个参数，这些参数会以数组的形式在流上输出。\n\n非常重要的一点是，在输出函数返回的流被订阅之前，输入函数不会执行，也就是说如果输入函数会发出ajax请求，那么这个请求只会在每一次有人订阅输出函数返回的流时才执行，在此之前并不会发请求。\n\n此外，还可以传入一个可选的selector函数作为参数，这个函数的入参和回调函数相同，而返回值将作为最终流上输出的值。在多个参数的情况下，selector函数会直接使用这些参数，而不是以数组的形式使用。也就是说可以把默认的selector函数想像成在多参数情况下以数组形式返回参数，在单参数情况下直接返回参数的函数。\n\n最后一个可选参数是 Scheduler 用来控制当流被订阅时输入函数在什么时间触发，以及流上的值什么时间被发出。默认情况下，订阅流会同步触发输入函数的执行。如果使用 Scheduler.async，那么将会延迟输入函数的触发时机，类似于使用 setTimeout(..., 0)时的情形一样，意味着所有正在执行的函数都将在调用输入函数前就执行完成。\n\n默认情况下传入回调函数的结果在输入函数被调用后会立即被发射，特别是如果回调也是同步调用的话，Observable也会同步的调用next方法。如果希望延迟这些调用可以使用 Scheduler.async，这样可以保证异步的调用输入函数以避免乱象。\n\n需要注意的是，输出函数返回的Observable只能发出一次值，然后完成。即使输入函数多次调用回调函数，第二次以及之后的调用都不会出现在流中。如果需要监听多次的调用，可以使用fromEvent或者 fromEventPattern。\n\n如果输入函数依赖上下文(this)，该上下文将被设置为输出函数在调用时的同一上下文。特别是如果输入函数被当作是某个对象的方法进行调用时，为了保持同样的行为，建议将输出函数的上下文设置为该对象。\n\n如果输入函数以 node 的方式(第一个参数是可选的错误参数用来标示调用是否成功)调用回调函数，bindNodeCallback 提供了方便的错误处理，也许是更好的选择。 bindCallback 不会区别对待这些方法，错误参数(是否传递) 被解释成正常的参数。\n\n| Name      | Type      | Attribute | Description                                                |\n| --------- | :-------: | :-------: | ---------------------------------------------------------: |\n| func      | function  |           | 使用回调函数作为最后一个参数的函数                         |\n| func      | function  | 可选      | 从回调函数上接收值，然后将它们映射成一个新的值给输出流使用 |\n| scheduler | Scheduler | 可选      | 使用scheduler控制何时调用回调函数                          |\n\n返回值\n\nfunction 返回一个 Observable的函数。\n\n示例\n```ts\n    var getJSONAsObservable = Rx.Observable.bindCallback(jQuery.getJSON);\n\n    var result = getJSONAsObservable(\'/my/url/\');\n\n    result.subscribe(v => console.log(x), e => console.error(e));\n\n\n\n    someFunction((a, b, c) => {\n        console.log(a);\n        console.log(b);\n        console.log(c);\n    })\n\n    const boundSomeFunction = Rx.Observable.bindCallback(someFunction);\n\n    boundSomeFunction().subscribe(values => console.log(values));\n\n\n\n    function add(a, b, c) {\n        console.log(\'input function called\');\n\n        return fn => fn(a, b, c);\n    }\n\n    const boundSomeFunction = Rx.Observable.bindCallback(add(1,2,3),(a,b,c) => a + b + c);\n\n    boundSomeFunction().subscribe(v => console.log(v));\n\n\n\n    function iCallMyCallbackSynchronously(cb) {\n        cb();\n    }\n\n    const boundSyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously);\n    const boundAsyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously, null, Rx.Scheduler.async);\n\n    boundSyncFn().subscribe(() => console.log(\'I was sync!\'));\n    boundAsyncFn().subscribe(() => console.log(\'I was async!\'));\n    console.log(\'This happened...\');\n\n\n\n    const someObject = {\n        methodWithCallback(fn) {\n            fn();\n        }\n    }\n\n    const boundMethod = Rx.Observable.bindCallback(someObject.methodWithCallback);\n\n    boundMethod.call(someObject) // make sure methodWithCallback has access to someObject\n        .subscribe(subscriber);\n```\n## bindNodeCallback\n\n----\n静态方法\n\n将一个node-js风格的API转换成一个发出 Observable 的函数。\n\n* <font face=\"仿宋\">_和bindCallback一样，只不过期望传入一个node-js风格的回调函数。_</font>\n\nbindNodeCallback不能称之为一个操作符，因为它的输入和输出都不是一个 Observable。它的输入必须是一个函数，这函数的最后一个参数必须是一个回调函数，当输入函数执行完成时调用此回调函数。这个回调函数需要符合node-js的风格，也就是说第一个参数必须是一个错误对象，标识执行过程是否发生了错误，如果传入了这个参数，说明调用发生了错误。它的输出也是一个函数，这函数的参数除了最后一个不是回调函数外，其它的和输入函数完成相同。当输出函数被调用时，它会返回一个流。如果输入函数在调用它的回调函数时传递了错误参数，这个错误将会在流上输出。如果没有传递错误参数，流上将会输出第二个参数，如果有更多的参数，流上将会以数组的形式输出这些参数，当然，错误参数除外。\n\n此外，还可以传入一个可选的selector函数作为参数，用来将值转化成希望在流上输出的值，而不是直接输出通常情况下的回调参数。这和bindCallback的selector函数类似，但是错误参数永远不会被传入到这个函数中。\n\n注意在输出产生的流被订阅之前输入函数是不会被调用的。默认情况下输入函数的调用在发生订阅后同步发生，但也可以通过调度器来改变这种行为模式。调度器可以控制来自于回调函数的值何时在流上输出。这和在bindCallback上使用调度器时是相同的。\n\n和bindCallback一样它也可以设置函数运行时的执行环境。\n\n输出函数返回的Observable只能发出一次值，然后完成。即使输入函数多次调用回调函数，第二次以及之后的调用都不会出现在流中。如果需要监听多次的调用，可以使用fromEvent或者 fromEventPattern。\n\nbindNodeCallback也可以在非node环境中使用，因为node-js风格的回调仅仅是一种书写约定，不管是哪种环境下，只要回调的书写风格符合node-js的回调风格，bindNodeCallback就可以安全的处理它。\n\n传递给回调函数的第一个错误对象没必要非得是javaScripte内置的Error对象的实例，事实上，它甚至可以不是一个对象。错误参数这里只是用来标识是否有错误存在，一切可以转化的真值的参数都代表着有错误发生，因此它可以是一个布尔真值，一个非0数字，非空字符串等，所有这些情况都会使用最终的流输出一个错误。这意味着当使用bindNodeCallback 的时候通常形式的回调函数都会触发失败。如果你的 Observable 经常发生你预料之外的错误，请检查下回调函数是否是 node-js 式的回调，如果不是，请使用bindCallback替代。\n\n注意，即使错误参数出现在回调函数中，但是它的值是假值，它仍然不会出现在Observable的发出数组或者选择函数中。\n\n| Name      | Type      | Attribute | Description                                                |\n| --------- | :-------: | :-------: | ---------------------------------------------------------: |\n| func      | function  |           | 使用回调函数作为最后一个参数的函数，必须是node-js风格      |\n| func      | function  | 可选      | 从回调函数上接收值，然后将它们映射成一个新的值给输出流使用 |\n| scheduler | Scheduler | 可选      | 使用scheduler控制何时调用回调函数                          |\n\n返回值\n\nfunction 返回一个 Observable的函数。\n\n示例\n```ts\n    import * as fs from \'fs\';\n\n    var readFileAsObservable = Rx.Observable.bindNodeCallback(fs.readFile);\n\n    var result = readFileAsObservable(\'./roadNames.txt\', \'utf8\');\n\n    result.subscribe(x => console.log(x), e => console.error(e));\n\n\n\n    someFunction((err, a, b) => {\n        console.log(err); // null\n        console.log(a); // 5\n        console.log(b); // \"some string\"\n    });\n\n    var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction);\n\n    boundSomeFunction()\n    .subscribe(value => {\n        console.log(value); // [5, \"some string\"]\n    });\n\n\n\n    someFunction((err, a, b) => {\n        console.log(err); // undefined\n        console.log(a); // \"abc\"\n        console.log(b); // \"DEF\"\n    });\n\n    var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction, (a, b) => a + b);\n\n    boundSomeFunction()\n    .subscribe(value => {\n        console.log(value); // \"abcDEF\"\n    });\n\n\n\n    someFunction(a => {\n        console.log(a); // 5\n    });\n\n    var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction);\n    boundSomeFunction()\n    .subscribe(\n        value => {}             // never gets called\n        err => console.log(err) // 5\n    );\n```\n## create\n\n----\n静态方法\n\n创建一条流，当有观察者订阅时，执行传入的函数。\n\n* <font face=\"仿宋\">_创建一条自定义的流，可以在这条流上输出任何你想要的值。_</font>\n\n                create(observer => observer.next(1));\n\n    -1-------------------------------------------------->\n\n这个操作符将一个onSubscription函数转换成一条流，当有订阅者订阅时，这个函数将使用一个观察者——observer作为唯一的参数调用，在函数执行的过程中，如果需要传递数据，则函数会通过调用观察者的相应方法将数据能过相应的通知传递给观察者。\n\n调用next方法时，作为正常数据传递；调用complete方法时，会给观察都发送一个结束通知，然后流会关闭并且再也不会有任何通知发出。调用error方法时，可以传递错误发生的信息以使观察者知道流上发生错误的原因。\n\n可以多次调用观察者上next方法向它传递值，但是 complete 和error 方法只能调用一次，并且在调用了它们中的任意一个时就不能再调用任何方法。如果在调用了 complete 或 error 方法后还执行了其它方法，根据流的特性原则，这些方法都会被忽略。需要注意的量并不一定要调用 complete 方法来结束流，你完全可以不调用它，从而创建一条永远不会结束的流。\n\nonSubscription函数可以选择返回一个函数或者一个具有 unsubscribe 方法的对象，当需要取消订阅，释放流执行时的资源时，就可以调用这个返回的函数或者对象的 unsubscribe 方法。例如，假设你在流执行进程中使用了一个定时器，当取消订阅时就可以通过上述的方式将定时器清理掉以避免浪费计算资源。\n\n大多数情况下并不会使用create方法去创建一条流，因为现有操作符可以为我们创建适合各种场景的流，换句话讲，这个操作符是比较底层的，如果现有的操作符实在无法满足需要，你可以考虑使用它。\n\ntypescript 签名问题\n\n因为 Observable 继承的类已经定义了静态 create 方法,但是签名不同, 不可能给 Observable.create 合适的签名。 正因为如此，给 create 传递的函数将不会进行类型检查，除非你明确指定了特定的签名。\n\n当使用 TypeScript 时，我们建议将传递给 create 的函数签名声明为(observer: Observer) => TeardownLogic, 其中Observer 和 TeardownLogic 是库提供的接口。\n\n参数\n\n| Name           | Type                                        | Attribute | Description                                                                                      |\n| -------------- | :-----------------------------------------: | :-------: | -----------------------------------------------------------------------------------------------: |\n| onSubscription | function(observer: Observer): TearDownLogic |           | 此函数在发生订阅时执行，在适当的时候通过相应的方法给观察者发送通知，执行后会返回清理资源的方法。 |\n\n返回值\n\nObservable 流。当流被订阅时会执行传入的函数传递数据。\n\n示例\n```ts\n    Rx.Observable.create(function(observer) {\n        observer.next(1);\n        observer.next(2);\n        observer.next(3);\n        observer.complete();\n    })\n    .subscribe(\n        v => console.log(v),\n        err => {},\n        _ => console.log(\'observable completed\')\n    );\n\n\n    Rx.Observable.create(function(observer) {\n        observer.error(\'error occur\');\n    })\n    .subscribe(\n        v => console.log(v), // 永远不会被调用\n        err => console.log(err),\n        complete => console.log(\'completed\') // 永远不会被调用\n    )\n```\n## defer\n\n----\n静态方法\n\n通过工厂函数创建一个新流的作为输出流，每当有新的订阅者要求订阅时，都会使用此函数创建一个新的流。\n\n* <font face=\"仿宋\">_创建一个新的内部流作为输出流。_</font>\n\n                defer(() => Rx.Observable.of(\'a\',\'b\',\'c\'));\n\n        ------a-------b------c--|-->\n\n当有新的订阅者订阅流时，通过工厂方法创建一个新的输出流给订阅者，工厂函数只会在有订阅者订阅时才执行。尽管看起来所有的订阅者订阅的都是同一条流，但事实下每个订阅者的都订阅了不同的输入流。\n\n参数\n\n| Name              | Type                                | Attribute | Description                                                                                                           |\n| ----------------- | :---------------------------------: | :-------: | --------------------------------------------------------------------------------------------------------------------: |\n| observableFactory | function(): Subscribable Or Promise |           | 工厂函数，可以用来生成新的流，每次订阅都会触发它的执行。可以返回一个promise，但是promise会立即被包装成一个 Observable |\n\n返回值\n\nObservable 对这个流的订阅会触发工厂函数的执行产生新的流。\n\n示例\n```ts\n    Rx.Observable.defer(() => {\n        if(Math.random() > 0.5) {\n            return Rx.Observable.fromEvent(document, \'click\');\n        } else {\n            return Rx.Observable.interval(1000);\n        }\n    });\n```\n## empty\n\n----\n静态方法\n\n创建一个不会发出任何有效值的流，只会立即发出一个Complete通知。\n\n* <font fact=\"仿宋\">_立即发出一个结束通知。_</font>\n\n            empty\n\n        -|------------------------------->\n\n这个静态操作符的唯一用处就是创建一个立即发出Complete通知的流。可以用来和其它操作符进行组合，比如：mergeMap。\n\n参数\n\n| Name      | Type      | Attribute | Description                       |\n| --------- | :-------: | :-------: | --------------------------------: |\n| scheduler | Scheduler | 可选      | 使用scheduler控制何时发出结束通知 |\n\n示例\n```ts\n    var observable = Rx.Observable.empty().startWith(7);\n\n    observable.subscribe(x => console.log(x));\n\n    var interval = Rx.Observable.interval(1000);\n\n    var result = interval.mergeMap(x => x % 2 === 1? Rx.Observable.of(\'a\', \'b\', \'c\') : Rx.Observable.empty());\n\n    result.subscribe(v => console.log(v));\n```\n## from\n\n----\n静态方法\n\n将数组、类数组对象、promise、部署了遍历器接口的对象或类 Observable 对象转换成Observable。\n\n* <font face=\"仿宋\">_几乎可以将任何东西都转换成流。_</font>\n\n                from([1,2,3])\n\n        1--------------2--------------3|\n\n可以将多种类型的数据转换成流，并且将原数据上的值依次推送到流上。字符串被当成由字母组成的数组进行转换。\n\n参数\n\n| Name      | Type               | Attribute | Description                                                                    |\n| --------- | :----------------: | :-------: | -----------------------------------------------------------------------------: |\n| ish       | ObservableInput<T> |           | 想要转换的数组、类数组对象、promise、部署了遍历器接口的对象或类Observable对象 |\n| scheduler | Scheduler          | 可选      | 调节值的发送                                                                   |\n\n示例\n```ts\n    var observable = Rx.Observable.from([1,2,3,4,5]);\n\n    observable.subscribe(v => console.log(v));\n\n    function* generatorDoubles(seed) {\n        var i = seed;\n\n        while(true) {\n            yield i;\n\n            i = i*2\n        }\n    }\n\n    var iterator = generatorDoubles(3);\n    var result = Rx.Observable.from(iterator).take(5);\n\n    result.subscribe(v => console.log(v));\n```\n## fromEvent\n\n----\n静态方法\n\n创建一个从指定的目标对象上发出指定的事件的流。\n\n* <font face=\"仿宋\">_基于DOM事件或者Node-js的事件发射器创建一条流。_</font>\n\n                fromEvent(document, \'click\');\n\n        ---------------------------event--------event----------------->\n\n此操作符接受一个事件对象作为第一个参数，在这个事件对象上注册了对应事件的处理函数，第二个参数是一个字符串，它表明需要监听哪种类型的事件。后边会介绍这个操作符支持的事件对象，如果需要监听其它的事件对象，需要使用fromEventPattern，它可以在任意的事件对象上使用。当处理支持fromEvent指定的API时，添加事件和移除事件的方法可能具有不同的名称，但它们都接接受一个描述事件类型的字符串和一个执行函数，执行函数在事件发生时会被调用。\n\n一旦输出流被订阅，事件处理函数就会注册到目标对象上的相应事件，当事件被触发时，事件对象就会被当作第一个参数传递给输出流。当取消订阅时，事件处理函数就会从目标对象上移除。\n\n注意，当目标对象调用事件处理函数时传入了多个参数，除了第一个参数外，其它参数都不会出现在输出流中。为了访问其它参数，可以传入一个可选的映射函数给fromEvent，这个映射函数可以接收到所有的参数，输出流上会输出映射函数返回的值。\n\n以下列出的事件对象通过鸭式辩型进行检查。这意味着它并不关心传的是什么对象及及运行在哪种环境中，只要它暴露了相应的方法，都可以安全的使用fromEvent。举例来说就是假如在node环境中某一个对象拥有和DOM对象相同的方法时，依然可以使用fromEvent操作符。\n\n支持的事件对象\n\n    - DOM EventTarget 一个部署了addEventListener 和 removeEventListener方法的对象。在浏览器中，addEventListener接受一个描述事件类型的字符串，和一个事件处理函数，以及第三个可选的参数（一个对象或一个布尔值）用来描述事件处理函数何时被触发。在使用fromEvent时依然可能提供第三个可选参数。\n\n    - Node.js EventEmitter 一个部署了addListener 和 removeListener方法的对象。\n\n    - jQuery-style event target 一个包含on 和off方法对象。\n\n    - DOM NodeList DOM节点列表，例如 document.querySelectorAll 或者 Node.childNodes 的返回结果。虽然这些集合并不是事件对象，fromEvent仍然可以通过遍历集合来给每一个节点注册事件。当取消订阅时，所有注册的函数也将被移除。\n\n    - DOM HTMLCollection 和NodeList一样，也会给每一个DOM节点注册事件，并且在取消订阅时移除它们。\n\n参数\n\n| Name      | Type                       | Attribute | Description                                                                                                         |\n| --------- | :------------------------: | :-------: | ------------------------------------------------------------------------------------------------------------------: |\n| target    | EventTargetLike            |           | DOM EventTarget, Node.js EventEmitter, JQuery-like event target, NodeList 或者 HTMLCollection等可以添加事件的对象。 |\n| eventName | string                     |           | 从目标对象上发出来的事件                                                                                            |\n| options   | EventListenerOptions       | 可选      | 传入addEventListener的配置参数                                                                                      |\n| selector  | SelectorMethodSingature<T> | 可选      | 结果的预处理函数，接受从事件处理函数上发出的所有参数，返回一个值                                                    |\n\n返回值\n\n    Observable<T>\n\n示例\n```ts\n    var clicks = Rx.Observable.fromEvent(document, \'click\');\n\n    clicks.subscribe(v => console.log(v));\n\n\n\n    var clicksInDocument = Rx.Observable.fromEvent(document, \'click\', true);\n\n    var clicksInDiv = Rx.Observable.fromEvent(someDivInDocument, \'click\');\n\n    clicksInDocument.subscribe(_ => console.log(\'document\'));\n\n    clicksInDiv.subscribe(_ => console.log(\'div\'));\n```\n## fromEventPattern\n\n----\n静态方法\n\n从一个基于 addHandler/removeHandler 方法的API创建 Observable。\n\n* <font face=\"仿宋\">_将任何部署 addHandler/removeHandler 方法的API转化为 Observable。_</font>\n\n创建一个流，通过 addHandler 和 removeHandler 方法来添加和移除事件处理程序，可以使用可选的映射函数来预处理结果。订阅时调用 addHandler 方法，取消订阅时调用 removeHandler 方法。\n\n| Name          | Type                                            | Attribute | Description                                                                |\n| ------------- | :---------------------------------------------: | :-------: | -------------------------------------------------------------------------: |\n| addHandler    | function(handler: function): any                |           | 使用一个事件处理函数作为参数的函数，将处理函数添加到事件源                 |\n| removeHandler | function(handler: function, singal?: any): void |           | 可选的函数，接受处理器函数作为参数，清理之前在事件源上注册的处理函数       |\n| selector      | function(...args, any): T                       | 可选      | 输出值的预处理函数，接受从事件处理函数上输入的参数，返回的值在输出流的输出 |\n\n返回值\n\n    Observable\n\n示例\n```ts\n    function addClickHandler(handler) {\n        document.addEventListener(\'click\', handler);\n    }\n\n    fuction removeClickHandler(handler) {\n        document.removeEventListener(\'click\', handler);\n    }\n\n    Rx.observable.fromEventPattern(\n        addClickHandler,\n        removeClickHandler\n    )\n    .subscribe(v => console.log(v));\n```\n## fromPromise\n\n----\n静态方法\n\n将promise转换成流。\n\n* <font face=\"仿宋\">_将promise转换成流，随后将promise成功 resolve 后发出的值推送到流上，然后发出结束通知。_</font>\n\n        ----------------------resolvedValue->\n\n                fromPromise(promise);\n\n        ---------------------resolvedValue|\n\n将ES2015的promise或者符合 promise A+ 规范的promise转换成流。promise成功**resolve**后的值将会被当作正常值通过next方法推送到输出的流上，**reject**后的异常将会通过error方法推送到输出流上。\n\n| Name      | Type           | Attribute | Description                             |\n| --------- | :------------: | :-------: | --------------------------------------: |\n| promise   | PromiseLike<T> |           | 需要转换的promise                       |\n| scheduler | Scheduler      | 可选      | 调节值（来自 resolve 或 reject ）的发送 |\n\n示例\n```ts\n    var result = Rx.Observable.fromPromise(fetch(\'http://myserver.com\'));\n\n    result.subscribe(v => console.log(v), err => console.error(err));\n\n    var promise = new Promise((resolve, reject) => {\n        setTimeout(() => {\n            resolve(\'success\');\n        },2000);\n    });\n\n    Rx.Observable.fromPromise(promise).subscribe(v => console.log(v));\n```\n## interval\n\n----\n静态方法\n\n创建一个按一定时间间隔发送整数的流。\n\n* <font face=\"仿宋\">_按时间间隔发送递增数字。_</font>\n\n                interval(1000);\n\n        --0--1--2--3--4--5--6--7--8--9--10------------->\n\n这个操作符生成一个发出无限数列的流，传入的参数将作为发送的时间间隔，以毫秒数为单位。第一个值并不会立即发出，而是需要等到指定的时间间隔之后才发出。默认情况下，这个操作符使用async调度器提供时间概念，当然你可选传入其它的调度器来提供时间概念。\n\n| Name      | Type      | Attribute       | Description                          |\n| --------- | :-------: | :-------------: | -----------------------------------: |\n| period    | number    | 可选。默认值：0 | 发送值的时间间隔，以毫秒数为单位     |\n| scheduler | Scheduler | 可选。默认值：0 | 调节值的发送，为值的发送提供时间概念 |\n\n返回值\n\nObservable 每隔一段时间就发出一个整数的流。\n\n示例\n```ts\n    Rx.Observable.interval(1000)\n        .subscribe(v => console.log(v));\n```\n## never\n\n----\n静态方法\n\n创建一个永远不会发出任何值的流。\n\n* <font face=\"仿宋\">_一条不会发出任何值的流。_</font>\n\n                never\n\n        ----------------------------------------->\n\n这个操作符用来创建一个即不会发出正常通知，也不会发出错误通知和完成通知的流。可以用于测试或者和其它流进行合并。需要注意的是它不会发出完成通知，仍然需要手动取消订阅。\n\n返回值\n\n    Observable 不会发出任何值的流。\n\n示例\n```ts\n    function info() {\n        console.log(\'Will not be called\');\n    }\n\n    Rx.Observable.never().startWith(7)\n        .sbuscribe(v => console.log(v), info, info);\n```\n## of\n\n----\n创建一个流，把传入此函数的参数从左到右依次推送到流上，然后发出结束通知。\n\n* <font face=\"仿宋\">_发送传入的参数，然后发出结束通知。_</font>\n\n                of(1,2,3);\n\n        1-------------2--------------3|\n\n用来创建一个简单的发送传入参数的流，这样可以用来和其它的流进行组合。默认情况下，它使用null作为调度器，也就是说会同步的把值发送出去，当然你可以自定义的使用其它的调度器来决定如何发送值。\n\n参数\n\n| Name      | Type      | Attribute | Description  |\n| --------- | :-------: | :-------: | -----------: |\n| values    | ...T      |           | 参数         |\n| scheduler | Scheduler | 可选      | 调节值的发送 |\n\n示例\n```ts\n    var numbers = Rx.Observable.of(10,20,30);\n\n    var letters = Rx.Observable.of(\'a\',\'b\',\'c\');\n\n    var interval = Rx.Observable.interval(1000);\n\n    var result = number.concat(letters).concat(interval);\n\n    result.subscribe(v => console.log(v));\n```\n## repeat\n\n----\n实例方法\n\n将已经发射过的值重复发射，直到达到指定的次数。\n\n    -----a------b---|\n\n        repeat(3);\n\n    ----a-------b----a-------b----a-------b|\n\n参数\n\n| Name  | Type   | Attribute | Description                         |\n| ----- | :----: | :-------: | ----------------------------------: |\n| count | number | 可选      | 需要重复的次数，0表示发出一个空的流 |\n\n## repeatWhen\n\n----\n实例方法\n\n返回一个输入流的镜像，除了结束通知。如果输入流发出了完成通知，这个操作符会发出通知给通知流。如果通知流上发生了错误或者发出了完成通知，那么它会在子订阅上发送错误或完成通知，否则这个操作符会重新订阅输入流。\n\n    ------------------r--------------r---------r-|--->\n\n    --a---b------|-->\n\n                repeatWhen\n\n    --a---b----------a---b-----------a---b-----a-|-->\n\n参数\n\n| Name    | Type                                            | Attribute | Description                                                        |\n| ------- | :---------------------------------------------: | :-------: | -----------------------------------------------------------------: |\n| notifer | function(notifications: Observable): Observable |           | 接收一个发出通知的流，通知流上可以通过发错误或结束通知结束重复行为 |\n\n返回值\n\n    Observable 把输入流使用重复逻辑包装过后流。\n\n示例\n```ts\n    const source = Rx.Observable.interval(1000).take(5);\n\n    source\n        .repeatWhen(() => Rx.Observable.fromEvent(document, \'click\'))\n        .subscribe(v => console.log(v));\n\n\n\n    Rx.Oservable.fo(42)\n        .repeatWhen(notifications => notifications // 输入流的上完成通知组成的流。\n            .scan((acc, cur, i) => acc + i, 0)\n            .delay(200)\n            .takeWhile(v => v < 1)\n        )\n        .subscribe(v => console.log(v), e => console.error(e), () => console.log(\'complete\'));\n```\n## range\n\n----\n静态方法\n\n创建一个按顺序发出指定范围内的数字的流。\n\n* <font face=\"仿宋\">_按顺序发出指定范围内的数字。_</font>\n\n                    range(1,10);\n\n        ---1---2---3---4---5---6---7---8---9---10-|->\n\nrange操作符会按顺序发出一定范围内的整数，接受一个起始值作为第一个参数，一个长度值作为第二个参数。默认情况下不使用任何调度器，只是将这些数字同步的发出，也可以使用一个调度器来决定如何发送值。\n\n参数\n\n| Name      | Type      | Attribute       | Description    |\n| --------- | :-------: | :-------------: | -------------: |\n| start     | number    | 可选。默认值：0 | 起始值         |\n| count     | number    | 可选。默认值：0 | 需要发送的数量 |\n| scheduler | Scheduler | 可选            | 调节值的发送   |\n\n返回值\n\nObservable 发送一个有限范围内的整数的流。\n\n示例\n```ts\n    Rx.Observable.range(1,10)\n        .subscribe(v => console.log(v));\n```\n## throw\n\n----\n静态方法\n\n创建一个立即发出错误通知的流。\n\n                throw(e);\n\n    X------------------------>\n\n要以用来和其它流进行合并，比如mergeMap。\n\n参数\n\n| Name      | Type      | Attribute | Description      |\n| --------- | :-------: | :-------: | ---------------: |\n| error     | any       |           | 错误通知发出的值 |\n| scheduler | Scheduler | 可选      | 调节值的发送     |\n\n返回值\n\n    Observable 只发出错误通知的流。\n\n示例\n```ts\n    Rx.Observable.throw(new Error(\'oops!)).startWith(7)\n        .subscribe(v => console.log(v), e => console.error(e));\n\n\n\n    Rx.Oservable.interval(1000)\n        .mergemap(x => x === 13 ? Rx.Observable.throw(\'Thirteens are bad\') : Rx.Observable.of(\'a\', \'b\', \'c\'))\n        .subscribe(v => console.log(v), e => console.error(e));\n```\n## timer\n\n----\n静态方法\n\n创建一个输出流，在指定的延迟时间到达后开始发射值，在指定的间隔时间到达后发射递增过的值。\n\n* <font face=\"仿宋\">_类似于interval，但是这个操作符允许指定流开始发射值的时间。_</font>\n\n                timer(3000, 1000);\n\n        ------0--1--2--3--4--5--------->\n\ntimer在等待时间到达后开始发射值，开始发射后以指定的间隔时间发出递增的值，这些值是一些数字常量。等待时间可以是一个毫秒数，也可以是一个日期对象。默认情况下，使用async调度器提供时间的概念，但是允许传递任何类型的调度器，如果没有指定时间周期，输出流上只会发射0，反之，它会发出一个无限的数列。\n\n| Name         | Type      | Attribute | Description                              |\n| ------------ | :-------: | :-------: | ---------------------------------------: |\n| initialDelay | number    | Date      |                                          |  |\n| period       | number    | 可选      | 输出流上发出值的间隔时间                 |\n| scheduler    | Scheduler | 可选      | 用来提供时间概念时调度器，会影响值的发送 |\n\n返回值\n\nObservable 等待时间到达后发出第一个值0，然后以一定的间隔时间发送递增的数字。\n\n示例\n```ts\n    Rx.Observable.timer(3000, 1000)\n        .subscribe(v => console.log(v));\n\n\n\n    Rx.Observable.timer(5000)\n        .subscribe(v => console.log(v));\n```\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"rxjs\"]',1,27),(28,'山高路远','2018-03-06 10:48:57','','官方操作符翻译（五）','错误处理类','## catch\n\n----\n实例方法\n\n使用输出流来捕获源 Observable 上的错误或者抛出一个异常。\n\n    ---------a--------b---------X------->\n\n                                --------1----2----3-|>\n\n                catch\n\n    ---------a--------b-----------------1----2----3-|>\n\n| Name     | Type     | Attribute | Description                                                                                                                                               |\n| -------- | :------: | :-------: | --------------------------------------------------------------------------------------------------------------------------------------------------------: |\n| selector | function |           | 错误处理函数，传入它的参数就是从源 Observable 上捕获到的异常，某些情况下你可能想重新执行源 Observable，那么这个函数返回的流将继续接着源 Observable 执行。 |\n\n返回值\n\nObservable 一个起源于源 Observable 或者从selector 函数中返回出来的流。\n\n示例\n```js\n    Rx.Observable.of(1,2,3,4,5)\n        .map(x => {\n            if( x === 4) {\n                throw \'four!\';\n            } else {\n                return x;\n            }\n        })\n        .catch(err => Rx.Observable.of(\'I\', \'II\', \'III\', \'IV\', \'V\'))\n        .subscribe(x => console.log(x));\n```\n## retry\n\n----\n实例方法\n\n返回一个源 Observable 的镜像流，但是镜像流上不包括源 Observable 上的错误。如果源 Observable 上发出了错误通知，这个操作符将重新尝试订阅源 Observable，尝试的次数不能超过参数指定的次数，而不会把错误通知发送出去。\n\n    --1---2---3---X->\n\n                retry(2);\n\n    --1---2---3-----1---2---3------1---2---3--X->\n\n任何来自源 Observable 的值都会在输出流上发出，即使在这期间发生了错误。例如，如果输出流在第一次发射2个值后发生了错误，这个时候它会重新尝试第二次发射，如果第二次成功，那么输出流上的值将是第一次发射的2个值，加上第二次发射的这些值\n\n| Name  | Type   | Attribute | Description          |\n| ----- | :----: | :-------: | -------------------: |\n| count | number |           | 失败后继续尝试的次数 |\n\n返回值\n\nObservable 使用retry逻辑包装过的源 Observable 的镜像流。\n\n示例\n```js\n    Rx.Observable.interval(1000)\n        .map(x => {\n            const v = Math.random();\n\n            if(v > 0.9) {\n                throw \'dangerous\';\n            } else {\n                return v;\n            }\n        })\n        .retry(2)\n        .subscribe(v => console.log(v));\n```\n## retryWhen\n\n----\n实例方法\n\n返回一个源 Observable 的镜像流，但是镜像流上不包括源 Observable 上的错误。如果源 Observable 上抛出了错误，这个操作符会抛出引起错误的通知给通知流。如果通知流发出了错误通知或完成通知，则触发输出流的错误或完成通知，否则该方法会尝试重新订阅源 Observable。\n\n    --------------------r---------------------r-------|----->\n\n    -1--2--X->\n\n                retryWhen\n\n    -1--2---------------1--2------------------1--2---|-->\n\n| Name     | Type                                    | Attribute | Description                                                               |\n| -------- | :-------------------------------------: | :-------: | ------------------------------------------------------------------------: |\n| notifier | function(error: Observable): Observable |           | 接收一通知流，根据此流的通知来决定什么时间重新执行或停止订阅源 Observable |\n\n返回值\n\nObservable 使用retry逻辑包装过的源 Observable 的镜像流。\n\n示例\n```ts\n    Rx.Observable.interval(1000)\n        .map(v => {\n            if(v > 5) {\n                throw v; // 由retryWhen接收此错误。\n            } else {\n                return v;\n            }\n        })\n        .retryWhen(error => error.do(v => console.log(`value ${v} is too high!`))\n                .delayWhen(v => Rx.Observable.timer(v * 1000))\n        )\n        .subscribe(v => console.log(v));\n\n    Rx.Observable.interval(1000)\n        .map(v => {\n            if( v > 3) {\n                throw v;\n            } else {\n                return v;\n            }\n        })\n        .retryWhen(error => error.zip(Rx.Observable.range(1,4))\n            .mergeMap(([err,i]) => {\n                if(i > 3) {\n                    return Rx.Observable.throw(err);\n                } else {\n                    console.log(`wait ${i} second before retry`);\n                    return Rx.Observable.timer(i * 1000);\n                }\n            })\n        )\n        .catch(err => Rx.Observable.of(\'oh, it was give up to retry\'))\n        .subscribe(v => console.log(v));\n```\n\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"rxjs\"]',1,28),(29,'山高路远','2018-03-07 09:01:24','','官方操作符翻译（六）','过滤类','## debounce\n\n----\n实例方法\n\n只有在由延迟流决定的一段特定时间内，输入流上没有再发出新的值后，输入流发出的值才会被输出流发了。\n\n* <font face=\"仿宋\">_类似于debuounceTime，但它的静默时间由第二个流决定。_</font>\n\n        -----a-------b--c------------d-----|-->\n\n        ---------|-->\n\n                    debounce\n\n        ---------a----------------c------------d--|-->\n\n延迟输入流上值的发送，在静默阶段内如果有新的值到来那么前一个静默值会被丢弃。这个操作符会追踪输入流上的最新值，同时通过调用传入的函数来获取一条决定静默时间的流。从输入流上发出的值只有在延迟流发出值或完成通知时才会被输出流发出。如果在延迟流发出值之前有新的值从输入流上发出，那么前一个值就会被丢弃，不会出现在输出流上。\n\n和 debounceTime 一样，这是一个限制频率的操作符，也是一个延迟发射值的操作符，输出流的值始终不会和输入流的值同步发出。\n\n参数\n\n| Name             | Type                                      | Attribute | Description                                               |\n| ---------------- | :---------------------------------------: | :-------: | --------------------------------------------------------: |\n| durationSelector | function(value: T): SubscribableOrPromise |           | 接受输入流上的值，用于计算延迟时间，返回一个流或者promise |\n\n返回值\n\n    Observable 延迟发送输入流的值，同时可以限制发送频率的流。\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .debounce(() => Rx.Observable.interval(1000))\n        .subscribe(v => console.log(v));\n```\n## debounceTime\n\n----\n实例方法\n\n在指定的时间范围内，如果输入流上没有再发出值，输入流的上一值才会被发出。\n\n* <font face=\"仿宋\">_和delay的行为有些相似，但是在有大量的发送时，它只会发送最新值。_</font>\n\n        ----a----b-c----d---------e-j--------|->\n\n                delay(20);\n\n        ----a------c----d-----------j--------|->\n\n这个操作符会延迟发送输入流上传递来的值。在延迟时间内如果有新的值抵达，那么它会把之前值丢弃，以这个新值抵达的时间为基准重新计算延迟时间，只有在延迟时间过后没有新值抵达时才会发送这个值，否则它重复上述的行为。\n\n这是一个可以限制发送频率的操作符，因为它限制了在一定的时间只能有一个值发出，它也类似一个延迟操作符，因为输出流上的值的发送时间与输入流的发送时间并不相同。这个操作符可以接收一个调度器。\n\n参数\n\n| Name      | Type      | Attribute           | Description                                                                        |\n| --------- | :-------: | :-----------------: | ---------------------------------------------------------------------------------: |\n| dueTime   | number    |                     | 以毫秒为单位的时间值（或者由同调度器提供的时间单位），用来决定发送值之前的静默时间 |\n| scheduler | Scheduler | 可选。默认值：async | 用来调节操作符内部的时间                                                           |\n\n返回值\n\nObservable 根据指定的时间延迟发送输入流上的值，并且在发送的频率过高时会丢弃之前的值。\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .debounceTime(1000)\n        .subscribe(v => console.log(v));\n```\n## distinct\n\n----\n实例方法\n\n创建一个输出流，它会将输入流上发射的当前值与前一个值进行对比，如果值发生了改变，这个值将会在输出流上推送。\n\n如果提供一个key值选择函数作为参数，将使用这个函数把输入流上的值映射成一个新值后再执行对比，如果没有提供引函数，将直接使用输入流上的值进行相等检查。\n\n在javascript中存在 set 数据结构，这个操作符会使用 set 结构来提高检查的性能。\n\n运行时，此操作符依赖于数组及数组的indexOf方法最小化实现 set 结构，所以如果使用多个值进行等值检查时运行性能会降低。即使是在最新的浏览器中，一个运行时间过长的等值检查可能会引发内存泄露。为了使这种情况得到缓解，某些情况下可以经它提供第二个可选参数——flushes，这样内部的set结构的值就可以被清空。\n\n参数\n\n| Name        | Type       | Attribute | Description                     |\n| ----------- | :--------: | :-------: | ------------------------------: |\n| keySelector | function   | 可选      | 用来决定使用哪个值进行等值检查  |\n| flushes     | Observable | 可选      | 用来刷新操作符内部的set结构的值 |\n\n返回值\n\nObservable 将源 Observable 上的值进行区分过的流。\n\n示例\n```js\n    Rx.Observable.of(1,1,2,2,3,3,4,4,5,7,5,7,8)\n        .distinct()\n        .subscribe(v => console.log(v));\n\n    Rx.Observable.of({\n        { age: 4, name: \'Foo\' },\n        { age: 7, name: \'Bar\' },\n        { age: 5, name: \'Foo\' }\n    })\n    .distinct(v => v.name)\n    .subscribe(v => console.log(v));\n\n    Rx.Observable.of([1,2,3],[1,2,3],[0,1,2])\n        .distinct(v => v)\n        .subscribe(v => console.log(v));\n```\n## distinctUntilChanged\n\n----\n实例方法\n\n创建一个输出流，它会将输入流上发射的当前值与前一个值进行对比，如果值发生了改变，这个值将会在输出流上推送。\n\n如果提供一个比较函数，将使用它来比较当前值与前一个值以决定该值是否应该在输出流上发出。如果没有提供此函数，将使用默认的比较函数。默认的比较函数为：(x,y) => x === y;\n\n| Name    | Type     | Attribute | Description                                |\n| ------- | :------: | :-------: | -----------------------------------------: |\n| compare | function | 可选      | 用来比较输入流上的当前值与前一个值是否相同 |\n\n返回值\n\nObservable 对输入流的值进行过区分后的流。\n\n示例\n```js\n    Rx.Observable.of(1,1,2,2,2,1,1,3,3,4)\n        .distinctUntilChanged()\n        .subscribe(v => console.log(v));\n\n    Rx.Observable.of({\n        { age: 4, name: \'Foo\' },\n        { age: 7, name: \'Bar\' },\n        { age: 5, name: \'Foo\' }\n    })\n    .distinctUntilChanged((pre, cur) => cur.name === pre.name)\n    .subscribe(v => console.log(v));\n```\n## distinctUntilKeyChanged\n\n----\n实例方法\n\n创建输出流，使用提供的 key 获取源 Observable 值的 value，比较当前值与前一个值是否相等，只有发生了变化时才会在输出流上发出。\n\n如果提供一个比较函数，则使用此函数来判定输入流发出的值是否应该在输出流上发出，如果没有提供此函数，默认使用等值检查。\n\n参数\n\n| Name    | Type     | Attribute | Description                                |\n| ------- | :------: | :-------: | -----------------------------------------: |\n| key     | string   |           | 进行比较的 value 的key名                   |\n| compare | function | 可选      | 用来比较输入流上的当前值与前一个值是否相等 |\n\n返回值\n\nObservable 对输入流的值进行过区分后的流。\n\n示例\n```js\n    Rx.Observable.of(\n            { age: 4, name: \'Foo\'},\n            { age: 7, name: \'Bar\'},\n            { age: 5, name: \'Foo\'},\n            { age: 6, name: \'Foo\'}\n        )\n        .distinctUntilKeyChanged(\'name\')\n        .subscribe(x => console.log(x));\n\n    Rx.Observable.of(\n        { age: 4, name: \'Foo1\'},\n        { age: 7, name: \'Bar\'},\n        { age: 5, name: \'Foo2\'},\n        { age: 6, name: \'Foo3\'}\n        )\n        .distinctUntilKeyChanged(\'name\', (x, y) => x.substring(0, 3) === y.substring(0, 3))\n        .subscribe(x => console.log(x));\n```\n## elementAt\n\n----\n实例方法\n\n只输出输入流上指定位置的值然后立即结束的流。\n\n    ---------a--------b---------c------d------|-->\n\n                elementAt(2);\n\n    ----------------------------c|->\n\n输出流输出输入流上指定索引位置的值或者在索引超出输入流的范围后输出一个默认值。如果超出索引范围，但是又没有提供默认值，此时输出流上会输出一个错误通知。\n\n参数\n\n| Name         | Type   | Attribute | Description     |\n| ------------ | :----: | :-------: | --------------: |\n| index        | number |           | 从0开始的索引值 |\n| defaultValue | T      | 可选      | 默认值          |\n\n返回值\n\nObservable 只输出一个值的流，可能是输入流的正常值，也可能是默认值，也可能是一个错误。\n\n错误\n\nArgumentOutOfRangeError 如果传入的索引小于0，或者输入流在索引位置上没有值时这个错误会被抛出。\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .elementAt(2)\n        .subscribe(v => console.log(v));\n```\n## filter\n\n----\n实例方法\n\n创建一个流，它的值是使用判定函数对输入流发出的值进行过滤后的值。\n\n* <font face=\"仿宋\">_与数组的filter方法类似，发出过滤后的值。_</font>\n\n        --0--1--2--3--4--5----|-->\n\n                filter(v => v % 2 === 0);\n\n        --0-----2-----4-------|>\n\n和数组的filter方法行为一样，从输入流上获取值，使用判定函数对值进行过滤，只有符合过滤条件的值才会在输出流上发出。\n\n| Name      | Type                                   | Attribute | Description                                                                                                                                                    |\n| --------- | :------------------------------------: | :-------: | -------------------------------------------------------------------------------------------------------------------------------------------------------------: |\n| predicate | function(v: T, index: number): boolean |           | 判定函数。它从输入流上接收值进行判定，如果此函数返回true，接收到的值将在输出流发出，反之，则不会发出。index参数是从开始订阅时，输入流的发出的值的索引，从0开始 |\n| thisArg   | any                                    | 可选      | 判定函数运行时的this指向                                                                                                                                       |\n\n返回值\n\nObservable 通过判定函数检测的值组成的流。\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .filter(event => event.target.tagName === \'DIV\')\n        .subscribe(v => console.log(v));\n```\n## first\n\n----\n实例方法\n\n发送输入流上的第一个值，或者第一个符合某些条件的值。\n\n* <font face\"仿宋\">_只发射第一个或第一个符合某些条件的值。_</font>\n\n        ---------a-------b------c---------d-->\n\n                first\n\n        ---------a|\n\n在不传入任何参数时，这个操作符仅发出输入流上的第一个值，然后立即发出结束通知。如果传入一个判定函数，则发出第一个通过判定函数检测的值。它还可以接受一个结果控制函数来转化输出的值，或一个在输入流没有发出符合条件的值情况下使用的默认值。如果没有提供默认值，并且在输入流上也没有找到符合条件的值时，输出流将会抛出错误。\n\n| Name           | Type                                   | Attribute | Description                                                                                                       |\n| -------------- | :------------------------------------: | :-------: | ----------------------------------------------------------------------------------------------------------------: |\n| predicate      | function(v: T, index: number): boolean | 可选      | 判定函数。用来检测输入流上的值是否符合条件                                                                        |\n| resultSelector | function(v: T, index: number): R       | 可选      | 根据输入流上的值生产输出值的函数。这个函数将接收到2个参数：value是输入流输出的数据，index是此数据在输入流上的索引 |\n| defaultValue   | R                                      | 可选      | 在输入流上没有找到合法值的情况下使用的默认值                                                                      |\n\n返回值\n\nObservable<T|R> 第一个符合条件的值。\n\n异常\n\nEmptyError 在结束通知发出前如果没有发出过有效值，将会发送一个错误通知给观察者。\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .first()\n        .subscribe(v => console.log(v));\n\n    Rx.Observable.fromEvent(document, \'click\')\n        .first(event => event.target.tagName === \'DIV\')\n        .subscribe(v => console.log(v));\n```\n## ignoreElements\n\n----\n实例方法\n\n忽略输入流上所有的正常值，只发出其错误通知和完成通知。\n\n    ------a-----b-----c-----d-------|--->\n\n                ignoreElements\n\n    --------------------------------|--->\n\n返回值\n\nObservable 只能发出错误通知或完成通知的流，具体发出哪一个要取决于输入流。\n\n示例\n```js\n    const source = Rx.Observable.interval(1000)\n        .take(5)\n        .map(v => {\n            if(v < 4) {\n                return v;\n            }else {\n                throw \'too big\';\n            }\n        });\n\n    source.ignoreElements().subscribe(v => console.log(v), e => console.error(e), () => console.log(\'complete\'));\n```\n## audit\n\n----\n实例方法\n\n在一段时间内忽略输入流上的值，持续时间由另一条流决定，之后发出输入流上的最近的值。\n\n* <font face=\"仿宋\">_类似于auditTime，只是它的静默时间是由另外一条流决定的。_</font>\n\n        -------a--x-y-------------b---x----------c-x-x-x-----|-->\n\n        -------------|-->\n\n                    audit\n\n        -------------y-----------------x----------------x----|-->\n\n这个操作符和throttler类似，只不是它输出的是静默时间过后最近的值，而不是第一个值。audit内部的计时器被禁用后，它会发出输入流上发出的最新的值，在计时器开启时输入流上发出的值都会被忽略，最初的时候计时器是被禁用的。当输入流上的第一个值到达时，传入的函数会被调用，计时器此时开启，此函数会返回一个流，这个流发出值或完成通知后，计时器会停止，然后输入流上发出的最新值将会在输出流上输出。下一个值到达时重复此过程。\n\n参数\n\n| Name             | Type                                      | Attribute | Description                                 |\n| ---------------- | :---------------------------------------: | :-------: | ------------------------------------------: |\n| durationSelector | function(value: T): SubscribableOrPromise |           | 接受输入流的值作为参数，输出一个流或promise |\n\n返回值\n\nObservable 把输入流的值发射频率限制后的流。\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .audit(event => Rx.Observable.interval(1000))\n        .subscribe(v => console.log(v));\n```\n## auditTime\n\n----\n实例方法\n\n在一段时间内忽略输入流上的值，之后发出输入流上最新的值。\n\n* <font face=\"仿宋\">_当输入流上发出值是，输出流忽略这个值并在接下来的指定时间内忽略输入流的值，过后发出输入流最新的值。_</font>\n\n        --------a--x--y------b---------x----c-x------|-->\n\n                    auditTime(500);\n\n        --------------y----------------x-------------|-->\n\n此操作符和 throttleTime 类似，不同的是它在指定的时间段后发出的是输入流上最新的值而不是第一个值。auditTime内部的计时器被禁用后，它会发出输入流上发出的最新的值，在计时器开启时输入流上发出的值都会被忽略，最初的时候计时器是被禁用的。当输入流上的第一个值到达时，计时器此时开启。在指定的时间过后，计时器会停止，然后输入流上发出的最新值将会在输出流上输出。下一个值到达时重复此过程。可以传入一个可选的调度器来管理计时器。\n\n参数\n\n| Name      | Type      | Attribute           | Description                            |\n| --------- | :-------: | :-----------------: | -------------------------------------: |\n| duration  | number    |                     | 在发出输入流上的最新值时需要等待的时间 |\n| scheduler | Scheduler | 可选；默认值：async | 管理计时器，处理发送频率               |\n\n返回值\n\nObservable 把输入流的值发射频率限制后的流。\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .auditTime(1000)\n        .subscribe(x => console.log(x));\n```\n## last\n\n----\n实例方法\n\n输入流上发出输入流上的最后一个值。可以传入一个判定函数，这种情况下，输出流发出的值将会是输入流上满足这个判定函数的最后一个值。\n\n        ----a---------b-------c-------d--|-->\n\n                    last\n\n        ---------------------------------d|\n\n参数\n\n| Name      | Type     | Attribute | Description |\n| --------- | :------: | :-------: | ----------: |\n| predicate | function | 可选      | 判定函数    |\n\n返回值\n\nObservable 发出输入流上符合条件的值的流。\n\n异常\n\nEmptyError 如果在输入流发出结束通知前没有发出过值，或没有发出过符合判定函数条件的值时，向观察者通知一个异常。\n\n示例\n```js\n    Rx.Observable.of(1,2,3,4)\n        .last()\n        .subscribe(v => console.log(v));\n\n    Rx.Observable.of(1,2,3,4)\n        .last(v => v%2 ===1)\n        .subscribe(v => console.log(v));\n```\n## sample\n\n----\n实例方法\n\n当另一个流发出值时输出输入流上最新的值。\n\n* <font face=\"仿宋\">_和sampleTime类似，只不过取样的时机取决于另一条流。_</font>\n\n        -------a------b----c---------------------d--------|-->\n\n        ---------x-----------x-----x----------------x--------|->\n\n                    sample\n\n        ---------a-----------c----------------------d--------|->\n\n当通知流上发出值或者完成通知时，此操作符都会查看输入流上的最新值，如果这个值和输出流的前一个值不同，则这个值就会被传递给输出流。在订阅输出流时，通知流同时也会被订阅。\n\n参数\n\n| Name     | Type            | Attribute | Description      |\n| -------- | :-------------: | :-------: | ---------------: |\n| notifier | Observable<any> |           | 取样时机的通知流 |\n\n返回值\n\nObservable 发出取样结果的流。\n\n示例\n```js\n    Rx.Observable.interval(1000)\n        .sample(Rx.Observable.fromEvent(document, \'click\'))\n        .subscribe(v => console.log(v));\n```\n## sampleTime\n\n----\n实例方法\n\n每隔一断时间对输入流的值进行取样。\n\n* <font face=\"仿宋\">_周期性的对输入流进行取样。_</font>\n\n        -------a-----b-c---------d--e------------f-g-d-m--------|-->\n\n                    sampleTime(700);\n\n        ----------------c----------------e------------------m--|->\n\n此操作符周期性的查看输入流，并将其最新值作为取样结果传递给输出流，如果自上次取样过后输入流没有发出过数据，则不会传递值。取样行为周期性的发生，并且是在输出流被订阅时就开始。\n\n参数\n\n| Name      | Type      | Attribute           | Description  |\n| --------- | :-------: | :-----------------: | -----------: |\n| period    | number    |                     | 取样周期     |\n| scheduler | Scheduler | 可选；默认值：async | 调度取样时间 |\n\n返回值\n\nObservable 发出取样结果的流。\n\n示例\n```js\n    Rx.Observable.interval(1000)\n        .sampleTime(2000)\n        .subscribe(v => console.log(v));\n```\n## single\n\n----\n实例方法\n\n只输出输入流上唯一一个符合判定条件的值，如果输入流没有符合判定条件的值或者有多个符合条件的值，输出流上将会抛出错误。\n\n    -------a-------b-------c-------|--->\n\n                single\n\n    ----------------X------------------->\n\n参数\n\n| Name      | Type     | Attribute | Description |\n| --------- | :------: | :-------: | ----------: |\n| predicate | Function |           | 判定函数    |\n\n返回值\n\nObservable 输入流上唯一符合判定条件的值组成的流。\n\n错误\n\nEmptyError 没有符合判定函数的唯一值时发出的错误通知。\n\n示例\n```js\n    Rx.Observable.interval(1000)\n        .take(5)\n        .single(v => v === 4)\n        .subscribe(v => console.log(v));\n```\n## skip\n\n----\n实例方法\n\n返回一个跳过指定数量的值的流。\n\n    ---a---b---c---d---e---|->\n\n                skip(3);\n\n    ---------------d---e---|>\n\n参数\n\n| Name  | Type   | Attribute | Description        |\n| ----- | :----: | :-------: | -----------------: |\n| count | number |           | 需要跳过的值的数量 |\n\n返回值\n\nObservable 跳过了一定数量值的流。\n\n示例\n```js\n    Observable.from([1,2,3,4,5,6])\n        .skip(3)\n        .subscribe(v => console.log(v));\n```\n## skipLast\n\n----\n实例方法\n\n跳过输入流上最后n个值。\n\n    ----1---2---3---4---5---6-----|-->\n\n                skipLast(3);\n\n    ----1---2---3--|->\n\n输出流上累积足够的队列保存最初的n个值，当接收到更多值时，将从队列的前面取值并在结果队列产生，这将导致值的发射被延迟。\n\n参数\n\n| Name  | Type   | Attribute | Description         |\n| ----- | :----: | :-------: | ------------------: |\n| count | number |           | 需要跳过的最后n个值 |\n\n返回值\n\nObservable 跳过了输入流上最后n个值的流。\n\n错误\n\nArgumentOutOfRangeError 当i < 0时，抛出此错误。\n\n示例\n```js\n        Rx.Observable.range(1,5)\n            .skipLast(3)\n            .subscribe(v => console.log(v));\n```\n## skipUntil\n\n----\n实例方法\n\n在通知流发出值之前，忽略输入流上产生的值。\n\n    --a-----b-----c----d-----e-----f---g----h---|-->\n\n    ---------------------x---------------|-->\n\n                skipUntil\n\n    ------------------------e------f---g----h---|-->\n\n参数\n\n| Name     | Type       | Attribute | Description                                |\n| -------- | :--------: | :-------: | -----------------------------------------: |\n| notifier | Observable |           | 发出通知值使输出流开始镜像输入流上发出的值 |\n\n返回值\n\nObservable 忽略了通知流发出通知之前的所有值的流。\n\n示例\n```js\n    Rx.Observable.interval(1000)\n        .skipUntil(Rx.Observable.fromEvent(document, \'click\'))\n        .subscribe(v => console.log(v));\n```\n## skipWhile\n\n----\n实例方法\n\n输入流上的值在通过判定函数的结果为true时将会被输出流忽略，一旦判定函数的结果变为false，输出流就开始镜像输入流。\n\n    ---2---3----4-----5----6----1-----|-->\n\n                skipWhile(x => x < 4);\n\n    ------------4-----5----6----1-----|-->\n\n参数\n\n| Name      | Type     | Attribute | Description              |\n| --------- | :------: | :-------: | -----------------------: |\n| predicate | Function |           | 检测输入流的值的判定函数 |\n\n返回值\n\nObservable 当判定函数的值变为false时开始镜像输入流的流。\n\n示例\n```js\n    Rx.Observable.interval(1000)\n        .skipWhile(x => x < 4)\n        .subscribe(v => console.log(v));\n```\n## take\n\n----\n实例方法\n\n只发出输入流上指定数量的值的流，从第一个值开始。\n\n* <font face=\"仿宋\">_从第一个值开始发出指定数量的值，然后发出结束通知。_</font>\n\n        ---a------b------c------d-----e---|-->\n\n                take(3);\n\n        ---a------b------c|\n\n输出流仅仅发出了输入流上从第一个值开始的n个值。如果输入流上值的个数小于n，那么所有的值都会被发出。值发射完成后，不管输入流有没有发出结束通知，输出流都会立即发出结束通知。\n\n参数\n\n| Name  | Type   | Attribute | Description                |\n| ----- | :----: | :-------: | -------------------------: |\n| count | number |           | 输出流上允许发出的最大数量 |\n\n返回值\n\nObservable 发出输入流上从第一个值开始的n个值，或者输入流发出值的个数小于n时发出所有的值的流。\n\n异常\n\nArgumentOutOfRangeError 在给此操作符传入负数时给观察者发了的错误。\n\n示例\n```js\n    Rx.Observable.interval(1000)\n        .take(5)\n        .subscribe(v => console.log(v));\n```\n## takeLast\n\n----\n实例方法\n\n只输出输入流最后发出的n个值。\n\n* <font face=\"仿宋\">_储存输入流上最后发出的n个值，在输入流完成后，输出流是发出这些值。_</font>\n\n        -----a----b---------c-------e----f-----g----h----|--->\n\n                takeLast(2);\n\n        -------------------------------------------------gh|-->\n\n输出流上只输出输入流上最后n个值，如果输入流上的值小于n，那么输入流的值将全部被输出。输出流必须在输入流发出完成通知后才能发出值，因为在此之前无法判断输入流上是否还有值发出，所有的值都以同步的方式输出。\n\n参数\n\n| Name  | Type   | Attribute | Description                |\n| ----- | :----: | :-------: | -------------------------: |\n| count | number |           | 从输入流上获取值的最大数量 |\n\n返回值\n\nObservable 只输出输入流上最后n个值的流。\n\n错误\n\nArgumentOutOfRangeError 当n < 0时，此操作符会抛出此错误。\n\n示例\n```js\n    Rx.Observable.range(1,100)\n        .takeLast(3)\n        .subscribe(v => console.log(v));\n```\n## takeUntil\n\n----\n实例方法\n\n在通知流发出通知之前，持续发射输入流上的值。\n\n* <font face=\"仿宋\">_发射输入流上的值，直到通知流上发出一个值，然后发出完成通知。_</font>\n\n在通知流发出值之前，输出流完全就是输入流的镜像。此操作符会一直监视传入的通知流，如果通知流发出了值或结束通知，输出流就会停止发射输入流上的值，并发出完成通知。\n\n| Name     | Type       | Attribute | Description                                        |\n| -------- | :--------: | :-------: | -------------------------------------------------: |\n| notifier | Observable |           | 通知流。当它发射出一个值以后，输出流将会停止发射值 |\n\n返回值\nObservable 持续发出输入流上的值，直到通知流上发出值为止。\n\n示例\n```js\n    Rx.Observable.interval(1000)\n        .takeUntil(Rx.Observable.fromEvent(document, \'click\'))\n        .subscribe(v => console.log(v));\n``````\n## takeWhile\n\n----\n实例方法\n\n在输入流上的值满足判定条件的情况下持续发射值，一旦某一个值不满足判定条件，立即发出结束通知。\n\n* <font face=\"仿宋\">_在值满足条件时持续发送值，一旦不满足，立即结束。_</font>\n\n        ---2---3----4---5---7---|-->\n\n                    takeWhile(x => x < 5);\n\n        ---2---3----4---|\n\n这个操作会订阅输入流，在满足判定条件时发出的完全是输入流的镜像。判定函数返回的布尔值代表条件是否满足，一旦此函数返回false，输入流将立即停止镜像并发出完成通知。\n\n参数\n\n| Name      | Type                                       | Attribute | Description                                                                |\n| --------- | :----------------------------------------: | :-------: | -------------------------------------------------------------------------: |\n| predicate | function(value: T, index: number): boolean |           | 判定函数。判定输入流上的值是否满足给定的条件，第二个参数是输入流上值的索引 |\n\n返回值\n\nObservable 满足判定条件时的输入流镜像，不满足时立即结束。\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .takeWhile(event => event.clientX > 200)\n        .subscribe(v => console.log(v));\n```\n## throttle\n\n----\n实例方法\n\n发出输入流上的某一个值，然后在指定时间内忽略输入流上发出的值，这个指定时间由另外一流决定。\n\n* <font face=\"仿宋\">_和throttleTime类似，只不过静默时间是由另一条流决定的。_</font>\n\n        --a--x-y---------b---x-----------c--x-x-x-x--------|-->\n\n        ------|->\n\n                    throttle\n\n        --a--------------b---------------c-----------------|-->\n\n当计时器被禁用后在输出流上发出输入流的值，计时器开启时输入上的值都会被忽略。计时器在最初是被禁用的，当输入流的第一个值到达时，它会直接被输出流输出，然后传入的函数被调用，计时器开启，这个函数会返回一个流来决定静默时间。当返回的流产生了值或者发出完成通知时，计时器被禁用。在下一值到达时重复以上过程。\n\n参数\n\n| Name             | Type                                      | Attribute | Description                                                                             |\n| ---------------- | :---------------------------------------: | :-------: | --------------------------------------------------------------------------------------: |\n| durationSelector | function(value: T): SubscribableOrPromise |           | 接受输入流的值作为参数，输出一个流或promise                                             |\n| config           | Object                                    |           | 用来定义 leading 和 trailing 行为的配置对象。 默认为 { leading: true, trailing: false } |\n\n返回值\n\nObservable 对输入流进行了节流包装及频率限制的流。\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .throttle(event => Rx.Observable.interval(1000))\n        .subscribe(v => console.log(v));\n```\n## throttleTime\n\n----\n实例方法\n\n发出输入流上的某一个值，然后在指定时间内忽略输入流上发出的值。\n\n* <font face=\"仿宋\">_让一个值通过，然后在接下来的指定时间内忽略输入流上的值。_</font>\n\n        --a--x-y---------b---x-----------c--x-x-x-x--------|-->\n\n                    throttleTime(500)\n\n        --a--------------b---------------c-----------------|-->\n\n当计时器被禁用后在输出流上发出输入流的值，计时器开启时输入上的值都会被忽略。计时器在最初是被禁用的，当输入流的第一个值到达时，它会直接被输出流输出，然后计时器开启，在经过指定的静默时间后，计时器被禁用。在下一值到达时重复以上过程。可以传入一个可选的Scheduler管理计时器。\n\n参数\n\n| Name      | Type      | Attribute           | Description                            |\n| --------- | :-------: | :-----------------: | -------------------------------------: |\n| duration  | number    |                     | 在发出输入流上的最新值时需要等待的时间 |\n| scheduler | Scheduler | 可选；默认值：async | 管理计时器，处理发送频率               |\n\n返回值\n\nObservable 对输入流进行了节流包装及频率限制的流。\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .throttleTime(500)\n        .subscribe(v => console.log(v));\n\n```\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"rxjs\"]',1,29),(30,'山高路远','2018-03-07 14:30:51','','官方操作符翻译（七）','多播类','## multicast\n\n----\n实例方法\n\n输出流可以将输入流共享给多个订阅\n\n    ----1----2-----3----4-----5----|-->\n\n        multicast(() => new Subject());\n\n    ====1====2=====3====4=====5====|-->\n\nmulticast可以在2种模式下工作。\n\n第一种方式是可以给这种操作符提供一个Subject或都一个可以返回Subject的工厂函数。这种情况下，将会得到一个特殊的Observable——ConnectableObservable。和普通的Observable一样这个流可以被多次订阅，但是此时并不会触发对输入流的订阅。只有当调用了ConnectableObservable的connet方法时，才会触发对输入流的订阅，这意味关你可以手动控制何时对输入流开始订阅。这个订阅可以在多个订阅者中共享，这意味者一个发起ajax的请求可以只发出一次，即使多个订阅者的订阅都会触发些请求。\n\n使用ConnectableObservable的通常情况是在第一个订阅发生时就调用它的connect方法，此后在有其它订阅都订阅时都使用这个订阅，在最后一个订阅者取消订阅后再取消。为了避免这种复杂的逻辑，ConnectableObservable提供了一个特殊的操作符refCount，当调用这个方法时，它返回一个Observable，它会统计自己的订阅者数量，只要有订阅者存在，它都会使ConnectableObservable处于订阅状态，如果你不需要手动的决定何时开始连接及何时断开连，可以使用这个方法。\n\n第二种方式是给此操作符添加传递一个可选的第二个参数——selector function。这个函数接收输入流的镜像流，返回另一个流，返回的流将被当作其它操作符的输入流。在这种模式下，multicast的第一个参数不直接传入一个Subject，而是必须传入一个产生Subject的工厂函数。在这种模式下，multicast返回的仅仅是一个普通的Observable，而不是一个ConnectableObservable，因此对输出流的多次订阅会触发的实际是多次订阅。然而，如果在selector函数内部多次订阅输入流时只会触发一次对输入流的订阅。因此，这种模式适用那些需要多次订阅输出流，而只想订阅一次输入流时特别适用。\n\n给multicast提供的Subject被当作输入流的代理，也就是说输入流的值都会通过这个Subject传递给订阅者。因此，如果Subject上存在一些特殊属性时，由multicast返回的Observable也同样具有这些属性。如果仅给这个操作符提供一个Subject，包括Subject的其它子类，例如：AsyncSubject，BehaviorSubject等，可以使用publish，publishLast等操作符替代。这些都是multicast的包装，在其内部都会硬编码一个Subject。\n\n参数\n\n| Name                    | Type                | Attribute | Description                                                                                            |\n| ----------------------- | :-----------------: | :-------: | -----------------------------------------------------------------------------------------------------: |\n| subjectOrSubjectFactory | Function 或 Subject |           | 用来创建Subject的工厂函数或者需要推入值的Subject                                                       |\n| selector                | Function            | 可选      | 在需要时可以多次调用输入流，但是不会多次订阅输入流。输入流的订阅者将在订阅期间收到输入流上的所有通知。 |\n\n返回值\n\nObservable 可以把输入流的值共享给多个订阅者的流。\n\n示例\n```js\n    const seconds = Rx.Observable.interval(1000)\n\n    const connectableSeconds = seconds.multicast(new Subject());\n\n    connectableSeconds.subscribe(v => console.log(`first: ${v}`));\n    connectableSeconds.subscribe(v => console.log(`second: ${v}`));\n\n    connectableSeconds.connect();\n\n    const seconds= Rx.Observable.interval(1000);\n\n    seconds\n        .multicast(\n            () => new Subject(),\n            seconds => seconds.zip(seconds)\n        )\n        .subscribe();\n```\n## publish\n\n----\n实例方法\n\n返回一个ConnectableObservable，也就是订阅行为只有调用输出流的connect方法时才真正的发生。\n\n    -------1-----2------------3------4--------5----|-->\n\n                publish\n\n    =======1=====2============3======4========5====|==>\n\n参数\n\n| Name     | Type     | Attribute | Description                                                                                            |\n| -------- | :------: | :-------: | -----------------------------------------------------------------------------------------------------: |\n| selector | Function | 可选      | 在需要时可以多次调用输入流，但是不会多次订阅输入流。输入流的订阅者将在订阅期间收到输入流上的所有通知。 |\n\n返回值\n\nConnectableObservable\n\n示例\n```js\n    const source = Rx.Observable.interval(1000);\n\n    const example = source.do(v => console.log(\'Do something\'))\n        .publish();\n\n    const sub1 = example.subscribe(v => console.log(`first subscribe: ${v}));\n\n    const sub2 = example.subscribe(v => console.log(`second subscribe: ${v}));\n\n    setTimeout(() => {\n        example.connect();\n    },5000);\n```\n## publishBehavior\n\n----\n实例方法\n\n返回值\n\nConnectableObservable\n\n## publishLast\n\n----\n实例方法\n\n返回值\n\nConnectableObservable\n\n## publishReplay\n\n----\n实例方法\n\n返回值\n\nConnectableObservable\n\n## share\n\n----\n实例方法\n\n输出流上的值可以共享给多个观察者。至少有一个观察者开始订阅这个条流时，它才会发射值，当所有的观察者都取消订阅时，它才会取消对输入源的订阅。因为它可同时把值同时发送给多个观察者，所以输出流可以认为是‘热’的。\n\n输出流的行为类似于使用了.publish().refCount()的流，但不同的是后者不会重新订阅输入流。例如，Rx.Observable.of(\'test\').publish().refCount() 在有新的观察者加入进不会将 \'test\' 重新发送给观察者，这与Rx.Observable.of(\'test\').share()的行为是不同的。\n\n    -----1---2-----3---4------5---|->\n\n                share\n\n    =====1===2=====3===4======5===|=>\n\n返回值\n\nObservable 在连接上时向观察者发送数据的流。\n\n示例\n```js\n    const source =  Rx.Observable.timer(1000)\n        .do(() => console.log(\'sid effect\'))\n        .mapTo(\'result\')\n\n    // 以下两个订阅会触发do操作符的逻辑执行2次\n\n    const sub1 = source.subscribe(v => console.log(v));\n\n    const sub2 = source.subscribe(v => console.log(v));\n\n    // 以下两个订阅只会将do操作符的逻辑触发一次\n\n    const hot = source.share();\n\n    const sub3 = hot.subscribe(v => console.log(v));\n\n    const sub4 = hot.subscribe(v => console.log(v));\n```\n\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"rxjs\"]',1,30),(31,'山高路远','2018-03-07 17:20:27','','官方操作符翻译（八）','转换类','## buffer\n\n----\n实例方法\n\n缓冲输入流上发出的值，直到收到缓冲结束通知时再把缓冲值一次性发出。\n\n* <font face=\"仿宋\">_在输入流上收集值，当通知流上发出通知时发出收集到的这些值。_</font>\n\n        --a--b--c--d--e--f--g--h--i--j--k--l--m--n--o--p--q--|-->\n\n        -----------------n-----------------n--------------n--|-->\n\n                        buffer\n\n        ----------------[a,b,c,d,e,f]--------------------[g,h,i,j,k,l]-----------------[m,n,o,p,q]--|-->\n\n缓冲输入流上的值，等到通知流发出结束缓冲的通知时，发出这些值，然后再开始下一次的缓冲。\n\n参数\n\n| Name         | Type            | Attribute | Description |\n| ------------ | :-------------: | :-------: | ----------: |\n| closeNotifer | Observable<any> |           | 通知流      |\n\n返回值\n\nObservable 发出缓冲值的流，缓冲值以数组的形式保存。\n\n示例\n```js\n    Rx.Observable.interval(1000)\n        .buffer(Rx.Observable.fromEvent(document, \'click\'))\n        .subscribe(v => console.log(v));\n```\n## bufferCount\n\n----\n实例方法\n\n缓冲输入流中的值，直到输入流中的值到达指定数量时，才在输出流中发出。\n\n* <font face=\"仿宋\">_将输入流中的值收集到数组中，当数组的长度到达指定的长度时将其发出。_</font>\n\n    --1--2--3--4--5--6--7--8--9--10-|->\n\n                bufferCount(3,2);\n\n    --------[1,2,3]--------[4,5,6]--------[7,8,9]---[10]|\n\n缓冲输入流上的值，当值的数量达到指定的数量时，发出该缓存值，并清理缓冲区。第二个参数决定缓冲区开启的频次，如果不提供第二个参数或者其值为null时，每次开始缓冲时都会开启新的缓冲区，在值发射过后清空。\n\n| Name             | Type   | Attribute | Description                                                                                           |\n| ---------------- | :----: | :-------: | ----------------------------------------------------------------------------------------------------: |\n| bufferSize       | number |           | 缓冲区储存值的最大数量                                                                                |\n| startBufferEvery | number | 可选      | 开启新缓冲区的频次，例如当这个值为2时，隔一个数据会开启一次缓冲区。默认情况下，开始发射值时开启缓冲区 |\n\n返回值\n\nObservable 以数组形式来缓存值的流。\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .debounceCount(2,2)\n        .subscribe(v => console.log(v));\n```\n## bufferTime\n\n----\n实例方法\n\n缓冲指定时间周期内输入流上发出的值。\n\n* <font face=\"仿宋\">_以数组的形式收集输入流上的值，每隔一定的周期发出这些值。_</font>\n\n        ---a----b----c----d----e----f----|-->\n\n                bufferTime(200);\n\n        --------[a,b]--------[c,d]---------[e,f]----|-->\n\n如果不提供可选参数bufferCreationInterval，每个时间周期过后都会重置缓冲区，如果提供了这个参数，这个操作符会以bufferCreationInterval指定的时间来开启新的缓冲区，以bufferTimeSpan指定的时间结束缓冲。当指定maxBufferSize参数时，缓冲区在时间到达或缓冲数量达到最大值时都会结束。\n\n参数\n\n| Name                   | Type      | Attribute         | Description            |\n| ---------------------- | :-------: | :---------------: | ---------------------: |\n| bufferTimeSpan         | number    |                   | 发出缓冲值的周期       |\n| bufferCreationInterval | number    | 可选              | 开启新的缓冲的时间间隔 |\n| maxBufferSize          | number    | 可选              | 缓冲的最大数量         |\n| scheduler              | Scheduler | 可选；默认：async | 调节缓冲区             |\n\n返回值\n\nObservable 输入缓冲值的流。\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .map(event => event.clientX)\n        .bufferTime(1000)\n        .subscribe(v => console.log(v));\n\n\n    Rx.Observable.fromEvent(document, \'click\')\n        .map(event => event.clientX)\n        .bufferTime(2000, 5000)\n        .subscribe(v => console.log(v));\n```\n## bufferToggle\n\n----\n实例方法\n\n缓冲输入流的值，openings 发送的时候开始缓冲，closingSelector 发送的时候结束缓冲。\n\n* <font face=\"仿宋\">_在opening发射值的时候开始缓冲数据，然后调用 closingSelector 函数获取通知关系缓冲的流。_</font>\n\n        ---a---b---c---d---e---f---g---h---i---|-->\n\n        -o---------------------------o---------|-->\n\n        -------------c-------------------c-----|-->\n\n                    bufferToggle\n\n        -------------[a,b,c]-------------[h]---|-->\n\n在 opening 发出值时打开缓冲区，开始缓冲输入流的数据，在 selectorFunction 返回的流或者 promise 发出值时再结束缓冲，然后将缓冲得到的值传递给输出流。\n\n参数\n\n| Name            | Type                    | Attribute | Description                                                     |\n| --------------- | :---------------------: | :-------: | --------------------------------------------------------------: |\n| opeings         | Subscribalbe 或 Promise |           | 通知何时开始缓冲                                                |\n| closingSelector | Subscribalbe 或 Promise | 可选      | 接受openings发出的值作为参数，返回流或Promise，通知何时关闭缓冲 |\n\n返回值\n\nObservable 发出缓冲值的流。\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .map(event => event.clientY)\n        .bufferToggle(\n            Rx.Observable.interval(5000),\n            i => i % 2 ? Rx.Observable.interval(2000) : Rx.Observable.empty()\n        )\n        .subscribe(v => console.log(v));\n```\n## bufferWhen\n\n----\n实例方法\n\n缓冲输入流上的值，使用一个工厂函数来获取结束缓冲的通知流。\n\n* <fonct face=\"仿宋\">_缓冲输入流上的数据，当收集开始时调用传入的函数获取结束缓冲的通知流。_</font>\n\n        ---a---b---c---d---e---f---g--|->\n\n        -------------s|->\n\n                    bufferWhen\n\n        -------------[a,b,c]--------[d,e,f,g]--[]|->\n\n立即开启缓冲，在输入函数返回的流发出值是结束缓冲并在输出流上发出缓冲值，紧接着开始下一次缓冲过程。\n\n参数\n\n| Name            | Type                  | Attribute                            | Description |\n| --------------- | :-------------------: | :----------------------------------: | ----------: |\n| closingSelector | function():Observable | 返回缓冲结束的通知流，不接受任何参数 |\n\n返回值\n\nObservable 发出缓冲值的流。\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .map(event => event.clientX)\n        .bufferWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))\n        .subscribe(x => console.log(x));\n```\n## concatMap\n\n----\n实例方法\n\n将多个流合并到一条流上，需要等待当前的流完成后才能开始合并下一个，合并过程按传入的顺序进行。\n\n* <font face=\"仿宋\">_将每一个值映射成Observable，然后使用concatlAll将所有的内部流打平。_</font>\n\n        --1------------3---------5-----------|-->\n\n        --10---10---10--|-->\n\n                    concatMap(i => 10*i----10*i---10*i)\n\n        --10---10---10-30---30---30-50---50---50--|->\n\n把输入流的值通过传入的函数映射成流，此函数返回的流将按次序进行连接。\n\n注意：如果输入流的值不断的发送出来，并且速度快于内部流完成的速度，将会导致内部问题，因为内部流无限的在缓冲区聚集等待轮流订阅。\n\nconcatMap 等价于给并发数量为1的 mergeMap。\n\n参数\n\n| Name           | Type                                                                              | Attribute | Description                                                                                                                                                                                                                                                 |\n| -------------- | :-------------------------------------------------------------------------------: | :-------: | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |\n| project        | function(value: T, index?:number):ObservableInput                                 |           | 接收输入流的值，返回内部流的函数                                                                                                                                                                                                                            |\n| resultSelector | function(outerValue: T, innerValue: I, outerIndex:number, innerIndex: number):any | 可选      | 它用于产生基于值的输出 Observable 和源(外部)发送和内部 Observable 发送的索引。 传递给这个函数参数有： outerValue: 来自源的值； innerValue: 来自投射的 Observable 的值； outerIndex: 来自源的值的 \"index\"； innerIndex: 来自投射的 Observable 的值的 \"index\" |\n\n返回值\n\nObservable 把输入的值经过映射成流后再连接起来的流。\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .concatMap(event => Rx.Observable.interval(1000).take(3))\n        .subscribe(v => console.log(v));\n```\n## concatMapTo\n\n----\n实例方法\n\n将输入源流上的值映射成多个相同的流并将它们按先后顺序合并到一条流上。\n\n* <font face=\"仿宋\">_类似于concatMap，但是每次映射成的内部流都是相同的。_</font>\n\n        --1------------3---------5-----------|-->\n\n        --10---10---10--|-->\n\n                    concatMap(10----10---10-|)\n\n        --10---10---10-10---10---10-10---10---10--|->\n\n把输入流的值通过传入的函数映射成相同的内部流，此函数返回的流将按次序进行连接。\n\n注意：如果输入流的值不断的发送出来，并且速度快于内部流完成的速度，将会导致内部问题，因为内部流无限的在缓冲区聚集等待轮流订阅。\n\nconcatMapTo 等价于给并发数量为1的 mergeMapTo。\n\n参数\n\n| Name            | Type                                                                              | Attribute | Description                                                                                                                                                                                                                                                 |\n| --------------- | :-------------------------------------------------------------------------------: | :-------: | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |\n| innerObservable | ObservableInput                                                                   |           | 替换输入流上的值的内部流                                                                                                                                                                                                                                    |\n| resultSelector  | function(outerValue: T, innerValue: I, outerIndex:number, innerIndex: number):any | 可选      | 它用于产生基于值的输出 Observable 和源(外部)发送和内部 Observable 发送的索引。 传递给这个函数参数有： outerValue: 来自源的值； innerValue: 来自投射的 Observable 的值； outerIndex: 来自源的值的 \"index\"； innerIndex: 来自投射的 Observable 的值的 \"index\" |\n\n返回值\n\nObservable 把输入的值经过映射成流后再连接起来的流。\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .concatMapTo(Rx.Observable.interval(1000).take(3))\n        .subscribe(v => console.log(v));\n```\n## exhaustMap\n\n----\n实例方法\n\n将输入流上的值输入成流，然后将这个条流上的值合并到输出流上，只有当前一个流完成时，新的内部流的值才会开始合并。\n\n* <font face=\"仿宋\">_将输入流的值映射成流，然后能过exhaust将其打平。_</font>\n\n        ---1--------5--------3--------5-----------------|-->\n\n        ---10-----10-----10-|->\n\n                    exhaustMap(i => 10*i----10*i----10*i);\n\n        ---10-----10-----10--10-----10-----10---|-->\n\n将输入流的值通过传入的函数转化后得到一条内部流，然后把内部流打平到输出流上。当新的内部流到达而之前的内部流尚未发出完成通知时，新的内部流将会被忽略，也就是说只有当前的内部流发出完成通知后接收到的新的内部流才会继续合并。\n\n参数\n\n| Name           | Type                                                                              | Attribute | Description                                                                                                                                                                                                                                              |\n| -------------- | :-------------------------------------------------------------------------------: | :-------: | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |\n| project        | function(value:T, index?:number):ObservableInput                                  |           | 接收输入流的值，返回内部流                                                                                                                                                                                                                               |\n| resultSelector | function(outerValue: T, innerValue: I, outerIndex:number, innerIndex: number):any | 可选      | 它用于产生基于值的输出 Observable 和源(外部)发送和内部 Observable 发送的索引。 传递给这个函数参数有： outerValue: 来自源的值；innerValue: 来自投射的 Observable 的值：outerIndex: 来自源的值的 \"index\"：innerIndex: 来自投射的 Observable 的值的 \"index\" |\n\n返回值\n\nObservable 由内部流根据上述规则组成的流。\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .exhaustMap(event => Rx.Observable.interval(1000).take(3))\n        .subscribe(v => console.log(v));\n```\n## expand\n\n----\n实例方法\n\n将输入流上的值递归转化成流再合并到输出流上。\n\n* <font face=\"仿宋\">_类似于mergeMap，但是映射函数会被用于每个输入值及每一个输出值。_</font>\n\n        ------1------------------|-->\n\n        -------2---------|----->\n\n                expand(x => x === 8 ? empty: ----2*x---|);\n\n        -----1----2-----4-----8----|-->\n\n输入的函数接收输入流的值作为参数，返回内部流，内部流被合并到输出流上并发出值。当有新的内部流到达时，此操作符会重新发出输出流上的值并对它们应用输入的函数。\n\n参数\n\n| Name       | Type                              | Attribute                                  | Description                                        |\n| ---------- | :-------------------------------: | :----------------------------------------: | -------------------------------------------------: |\n| project    | function(value: T, index: number) |                                            | 映射函数，接受输入流或输出流的值，将其转化成一条流 |\n| concurrent | number                            | optional; 默认值：Number.POSITIVE_INFINITE | 同时订阅的输入流的最大数量                         |\n| scheduler  | Shceduler                         | 可选；默认值： null                        | 调度内部流的订阅                                   |\n\n返回值\n\nObservable 对输入流和输出流的值都应用映射函数得到的流。\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .mapTo(1)\n        .expand(x => Rx.Observable.of(2*x).delay(1000))\n        .take(10)\n        .subscribe(x => console.log(x));\n```\n## groupBy\n\n----\n实例方法\n\n将输入流上的值按一定的规则分组成不同的流，然后把这些流发送给输出流，每一条流上都是一组符合相同条件的值。\n\n    ----1----2----3----4----5----|->\n\n                groupBy(v => v%2);\n\n    -----------------------------|->\n        \\   \\\n         \\   2---------4---------|\n          1------3----------5----|\n\n参数\n\n| Name             | Type                                                     | Attribute | Description                                |\n| ---------------- | :------------------------------------------------------: | :-------: | -----------------------------------------: |\n| keySelector      | function(value:T):K                                      |           | 分组函数，用于检查输入流上的每一个值       |\n| elementSelector  | function(value: T):R                                     | 可选      | 用来检查每一个返回值的函数                 |\n| durationSelector | function(grouped:GroupedObservable<K,R>):Observable<any> | 可选      | 返回一个流，用来决定每个组应该存在多长时间 |\n\n返回值\n\nObservable<GroupedObservable<K,R>> 发出分组后的流的高阶流，分组的流都有一个唯一的key，并且该流中的值都是输入流上符合某一条件的值。\n\n示例\n```js\n    Rx.Observable.of(\n        {id: 1, name: \'aze1\'},\n        {id: 2, name: \'sf2\'},\n        {id: 2, name: \'dg2\'},\n        {id: 1, name: \'erg1\'},\n        {id: 1, name: \'df1\'},\n        {id: 2, name: \'sf2\'},\n        {id: 3, name: \'qfs3\'},\n        {id: 2, name: \'qsg\'}\n    )\n    .groupBy(v => v.id)\n    .mergeMap(group => group.reduce((acc,cur) => [...acc, cur],[]))\n    .subscribe(v => console.log(v));\n```\n## map\n\n----\n实例方法\n\n输出流上的值是使用一个映射函数将输入流上的值映射后得到新的值。\n\n* <font face=\"仿宋\">_和数组的map方法行为一样，将输入的值根据规则进行转换后在输入流上发出。_</font>\n\n        --------1-----------2----------3----------|--->\n\n                map(v => v * 10);\n\n        --------10----------20---------30---------|---->\n\n参数\n\n| Name    | Type                                 | Attribute | Description                                                                                       |\n| ------- | :----------------------------------: | :-------: | ------------------------------------------------------------------------------------------------: |\n| project | function(value: T, index: number): R |           | 映射函数，第一个参数是从输入流上得到的值，第二个参数是这个值在开始订阅后在输入流上的索引，从0开始 |\n| thisArg | any                                  | optional  | 映射函数运行时的this指向                                                                          |\n\n返回值\n\nObservable 发出映射后的值的流。\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .map(event => event.clientX)\n        .subscribe(v => console.log(v));\n```\n## mapTo\n\n----\n实例方法\n\n当输入源上发出值时，把它映射成一个一常数在输出流上输出。\n\n* <font face=\"仿宋\">_行为与map一样，只不过每次映射的结果都一样_</font>\n\n        -----1--------2---------3-----|-->\n\n                mapTo(\'a\');\n\n        -----a--------a---------a-----|-->\n\n接受一个常量作为参数，每当输入流上有值发出时，输出流都发出这个常量，换句话讲就是它只关心输入流什么时候发出值，而不关心输入流发出的值本身。\n\n参数\n\n| Name  | Type  | Attribute | Description |\n| ----- | :---: | :-------: | ----------: |\n| value | any   |           | 输出的值    |\n\n返回值\n\nObservable 每次在输入流发出值时都发出同样值的流。\n\n示例\n```js\n    Rx.Observable.fromEvent(document,\'click\')\n        .mapTo(\'Hello\')\n        .subscribe(v => console.log(v));\n```\n## mergeMap\n\n----\n实例方法\n\n将所有输入流的值都合并到一条流上。\n\n* <font face=\"仿宋\">_映射每一条输入流，并将它们打平到一条流上。_</font>\n\n        -1-----2-----3---------|-->\n\n        ---2----2----2--|-----> //第一次时的内部流，第2，3次的一样，这个流是直正的输入流\n\n                mergeMap(v => Observable.of(v + 1).repeat(3));\n\n        -2--2--2--3--3--3--4--4--4----|-->\n\n输出流会把所有从映射函数中返回的内部流打平到一条流上。映射函数可以使用输入流的值来生成内部流。\n\n参数\n\n| Name           | Type                                                                                | Attribute                              | Description                                                                                                                                                    |\n| -------------- | :---------------------------------------------------------------------------------: | :------------------------------------: | -------------------------------------------------------------------------------------------------------------------------------------------------------------: |\n| project        | function(value: T, index: number): ObservableInput                                  |                                        | 接受输入流参数，返回内部的流                                                                                                                                   |\n| resultSelector | function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): nay | 可选                                   | 基于输入流和内部流的值和逻辑来生成值的函数。 outerValue: 输入流的上的值 ;innerValue: 内部流上的值; outerIndex: 输入流的值的索引; innerIndex: 内部流的值的索引; |\n| concurrent     | number                                                                              | 可选。默认值：Number.POSITIVE_INFINITY | 同时可以订阅的内部流的最大数量                                                                                                                                 |\n\n返回值\n\nObservable 一条合并了所有映射函数生成的内部流的流，内部流上的值都会在这条流上发出。\n\n示例\n```js\n    Rx.Observable.of(\'a\',\'b\',\'c\')\n        .mergeMap(v => Rx.Observable.interval(1000).map(x => x + v ))\n        .subscribe(v => console.log(v));\n\n    const source = Rx.Observable.of(\'Hello\');\n\n    const createPromise = v => new Promise(resolve => resolve(`I got ${v} from promise`));\n\n    source.mergeMap(\n        v => createPromise(v),\n        (outValue, innerValue) => `Source: ${outValue},${innerValue}`\n    )\n    .subscribe(v => console.log(v));\n```\n## mergeMapTo\n\n----\n实例方法\n\n把输入流的值都映射成同样的流，然后把这些映射后的流进行合并。\n\n* <font face=\"仿宋\">_和mergeMap的行为类似，只不过得到的内部流都是相同的。_</font>\n\n        ------1----2------3------|-->\n\n        --10--10--10--|--> //内部流\n\n                    mergeMapTo\n\n        ------10--10--10----10--10--10-----10--10--10--|-->\n\n参数\n\n| Name           | Type                                                                                | Attribute                              | Description                                                                                                                                                    |\n| -------------- | :---------------------------------------------------------------------------------: | :------------------------------------: | -------------------------------------------------------------------------------------------------------------------------------------------------------------: |\n| project        | function(value: T, index: number): ObservableInput                                  |                                        | 接受输入流参数，返回内部的流                                                                                                                                   |\n| resultSelector | function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): nay | 可选                                   | 基于输入流和内部流的值和逻辑来生成值的函数。 outerValue: 输入流的上的值 ;innerValue: 内部流上的值; outerIndex: 输入流的值的索引; innerIndex: 内部流的值的索引; |\n| concurrent     | number                                                                              | 可选。默认值：Number.POSITIVE_INFINITY | 同时可以订阅的内部流的最大数量                                                                                                                                 |\n\n返回值\n\nObservable 一条合并了所有映射函数生成的内部流的流，内部流上的值都会在这条流上发出。\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .mergeMapTo(Rx.Observable.interval(1000).take(5))\n        .subscribe(v => console.log(v));\n```\n## mergeScan\n\n----\n实例方法\n\n在输入流上应用累积函数，累积函数返回内部流 ，然后每个返回的内部流被合并到输出输出流中。\n\n* <font face=\"仿宋\">_类似于scan，但由累积函数返回的内部流会被合并到输出流中。_</font>\n\n参数\n\n| Name        | Type                                  | Attribute                               | Description                  |\n| ----------- | :-----------------------------------: | :-------------------------------------: | ---------------------------: |\n| accumulator | function(acc:R,value:T):Observable<R> |                                         | 累积函数                     |\n| seed        | any                                   |                                         | 累积的初始值                 |\n| concurrent  | number                                | 可选的 默认值：Number.POSITIVE_INFINITY | 可周时订阅的输入流的最大数量 |\n\n返回值\n\nObservable 累积后的流。\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .mapTo(1)\n        .mergeScan((acc, cur) => Rx.Observable.fo(acc + cur), 0)\n        .subscribe(v => console.log(v));\n```\n## pairwise\n\n----\n实例方法\n\n将一系列连续发射的值成对的组合在一起，发出这些组合后的值。\n\n* <font face=\"仿宋\">_将当前值和前一个值组合后发出。_</font>\n\n        ---a----b-----c-----d-------|-->\n\n                pairwise\n\n        -------[a,b]--[b,c]-[c,d]--|-->\n\n一条发出n个值的流将被转化成一条发出n-1组值的流，每组值都是包含2个值的数组。因此只有当输入流开始发出第二个值时，输出流上才开始发出值。\n\n返回值\n\nObservable 发出成对值的流。\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .pairwise()\n        .map(pair => {\n            const x0 = pair[0].clientX;\n            const y0 = pair[0].clientX;\n            const x1 = pair[1].clientY;\n            const y1 = pair[1].clientY;\n\n            return Math.sqrt(Map.pow(x0 - x1,2) + Math.pow(y0 - y1,2))\n        })\n        .subscribe(x => console.log(x));\n```\n## partition\n\n----\n实例方法\n\n使用判定函数将输入流分成2条不同的流，一条发出满足判定条件的值，一条发出不满足判定条件的值。\n\n* <font face=\"仿宋\">_类似于filter，但它会返回2条不同的流。_</font>\n\n        ---1--2--3--4-----5------6----7--8---|-->\n\n                partition(x => x%2 ===1 );\n\n        ---1-----3--------5-----------7------|-->\n\n        ------2-----4------------6-------8---|-->\n\n此操作符返回一个数组，数组的第一个值是发出满足判定函数的值组成的流，第二个值是不满足判定函数的值组成的流。\n\n参数\n\n| Name      | Type                                       | Attribute | Description                                                                                                                                 |\n| --------- | :----------------------------------------: | :-------: | ------------------------------------------------------------------------------------------------------------------------------------------: |\n| predicate | function(value: T, index: number): boolean |           | 判定函数，输入流的值通过判定函数检测为true时分配到第一条流上，否则分配在第二条流上。index 参数是自订阅开始后发送序列的索引，是从 0 开始的。 |\n| thisArg   | any                                        | 可选的    | 决定判定函数运行时的this指向                                                                                                                |\n\n返回值\n\n[Observable, Observable] 第一个是通过检测的流，第二个未通过检测的流。\n\n示例\n```js\n    const parts = Rx.Observable.fromEvent(document, \'click\')\n        .partition(event => event.target.tagName === \'DIV\')\n\n    const clickOnDivs = parts[0];\n\n    const clickOnOthers = parts[1];\n\n    clickOnDivs.subscribe(v => console.log(v));\n\n    clickOnOthers.subscribe(v => console.log(v));\n```\n## pluck\n\n----\n实例方法\n\n指定一个目标属性，抽取输入流发出的值的此属性。\n\n* <font face=\"仿宋\">_和map方法类似，但只能用来提取输入流出值的一个内部属性。_</font>\n\n        -----{a:1}-----{a:2}-----{a:3}----|-->\n\n                pluck(\'a\');\n\n        ------1---------2----------3------|>\n\n获取输入流发出的值的属性值，接收的参数作为属性查找的路径，然后使用这个路径在每一个值上查找其属性值，如果没有找到，则会发出undefined。\n\n参数\n\n| Name     | Type      | Attribute | Description          |\n| -------- | :-------: | :-------: | -------------------: |\n| property | ...string |           | 需要查找的目标属性值 |\n\n返回值\n\nObservable 发出提取的值组成的流。\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .pluck(\'target\', \'tagName\')\n        .subscribe(v => console.log(v));\n```\n## scan\n\n----\n实例方法\n\n在输入流上应用一个累积函数，每一次累积的结果都发送给输出流，累积时可以接受一个可选的初始值。\n\n* <font face=\"仿宋\">_和reduce操作符类似，不同的是会把每一次累积的结果都发送出去。_</font>\n\n将输入流发出的值能过累积函数进行累积，累积函数知道如何把新接收到的值加入已有的累积结果中。如果提供了初始值，那么它将作为整个累积过程的初始值，如果没有提供，输入流上的第一个值将作为整个累积过程的初始值。\n\n参数\n\n| Name        | Type                         | Attribute | Description                  |\n| ----------- | :--------------------------: | :-------: | ---------------------------: |\n| accumulator | function(acc: R, value: T):R |           | 累积函数，用于累积每个输入值 |\n| value       | T                            | R         | 可选的初始值                 |\n\n返回值\n\nObservable<R> 输出累积值的流。\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .mapTo(1)\n        .scan((acc,cur) => acc + cur, 0)\n        .subscribe(v => console.log(v));\n```\n## switchMap\n\n----\n实例方法\n\n在输入流发出值时，把它映射成一条内部流，然后把这条内部流打平成到输出流上，输出流上只会发出最近的内部流上的值。\n\n* <font face=\"仿宋\">_把输入流上的值映射成流，然后使用switch操作符把内部流打平到输出流上。_</font>\n\n        -1---------3-----5----|->\n\n        -10---10---10-| // 内部流\n\n                switchMap(v => Observable.from([10,10,10]).map(x => x * v))\n\n        -10---10---10-30---30-50---50---50-|\n\n输出流上的值是由映射函数在输入流的值的基本上生成的内部流所发出的，输出流只允许观察一条内部流，当有新的内部流到达时，输出流将会取消对之前的内部流的订阅，转而订阅这个最新的内部流，并发出它上面的值。\n\n参数\n\n| Name           | Type                                                                                | Attribute                              | Description                                                                                                                                                    |\n| -------------- | :---------------------------------------------------------------------------------: | :------------------------------------: | -------------------------------------------------------------------------------------------------------------------------------------------------------------: |\n| project        | function(value: T, index: number): ObservableInput                                  |                                        | 接受输入流参数，返回内部的流                                                                                                                                   |\n| resultSelector | function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): nay | 可选                                   | 基于输入流和内部流的值和逻辑来生成值的函数。 outerValue: 输入流的上的值 ;innerValue: 内部流上的值; outerIndex: 输入流的值的索引; innerIndex: 内部流的值的索引; |\n| concurrent     | number                                                                              | 可选。默认值：Number.POSITIVE_INFINITY | 同时可以订阅的内部流的最大数量                                                                                                                                 |\n\n返回值\n\nObservable 仅从最新的内部流上取值的流。\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .switchMap(event => Rx.Observable.interval(1000))\n        .subscribe(v => console.log(v));\n```\n## switchMapTo\n\n----\n实例方法\n\n将输入流上的值都转换成一个内部流，然后将它打平到输出流上。\n\n* <font face=\"仿宋\">_它的行为类似于switchMap，不同的时它映射出的内部流都是相同的。_</font>\n\n        -1---------3-----5----|->\n\n        -6---6---6-| // 内部流\n\n                switchMapTo\n\n        -6---6---6-6---6-6---6---6-|\n\n输出流上的值是由映射函数生成的内部流所发出的，输出流只允许观察一条内部流，当有新的内部流到达时，输出流将会取消对之前的内部流的订阅，转而订阅这个最新的内部流，并发出它上面的值。\n\n| Name            | Type                                                                                | Attribute | Description                                                                                                                                                    |\n| --------------- | :---------------------------------------------------------------------------------: | :-------: | -------------------------------------------------------------------------------------------------------------------------------------------------------------: |\n| innerObservable | ObservableInput                                                                     |           | 内部流                                                                                                                                                         |\n| resultSelector  | function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): nay | 可选      | 基于输入流和内部流的值和逻辑来生成值的函数。 outerValue: 输入流的上的值 ;innerValue: 内部流上的值; outerIndex: 输入流的值的索引; innerIndex: 内部流的值的索引; |\n\n返回值\n\nObservable 只能发出最新内部流的值，或者经过resultSelector处理过的值，新的内部流到达时会取消旧的订阅。\n\n示例\n```js\n    Rx.Observable.fromEvent(document,\'click\')\n        .switchMapTo(Rx.Observable.interval(1000))\n        .subscribe(x => console.log(v));\n```\n## window\n\n----\n实例方法\n\n当分割流发出值后把输入流进行分割，从而把输入流转化成多条内部流。\n\n* <font face=\"仿宋\">_类似于buffer，但发出的是分割后的流，而不是数组。_</font>\n\n    --a--b--c--d--e--f--g--h--i--j--k--l--m--n--|->\n\n    ---------w------------------w---------------|->\n\n                window\n\n    --------------------------------------------|->\n       \\       \\                   \\\n        \\       \\                   j--k--l--m--n|\n         \\       d--e--f--g--h--i|\n          a--b--c|\n\n此操作符返回一个将输入流切分后的流组成的流。每一条切分后的流都发出各自的值，这些值在各个流中不会发生重叠。输出流是一个高阶流。\n\n参数\n\n| Name             | Type            | Attribute | Description      |\n| ---------------- | :-------------: | :-------: | ---------------: |\n| windowBoundaries | Observable<any> |           | 发出分割通知的流 |\n\n返回值\n\nObservable<Observable<T>> 发出分割后的流的流。\n\n示例\n    \n```js\n    Rx.Observble.fromEvent(docuement, \'click\')\n        .window(Rx.Observable.interval(1000))\n        .map(win => win.take(2))\n        .mergeAll()\n        .subscribe(x => console.log(x));\n\n    const source = Rx.Observable.timer(0,1000);\n\n    const example = source.windwo(Rx.Observable.interval(3000))\n\n    const count = example.scan((acc,cur) => acc + 1, 0);\n\n    const subscription1 = count.subscribe(v => console.log(`window: ${v}`));\n\n    const subscription2 = example.mergeAll().subscribe(v => console.log(v));\n```\n    \n## windowCount\n\n----\n实例方法\n\n把输入流进行切分，切分后的流最多可以发出指定数量的值。\n\n* <font face=\"仿宋\">_类似于bufferCount， 但发出的是流，而不是数组。_</font>\n\n        -----a----b-----c-----d----e----f---g---h---|-->\n\n                 windowCount(3)\n\n        --------------------------------------------|-->\n            \\a----b----c|     \\d---e---f|   \\g---h|\n\n输入流发送由输入流分割后的子流形成的流，每个子流最多可以发出指定数量的值。当输入流上发出完成通知或者错误通知时，输出流把这个通知传递给相应的子流。另外，可以指定开启分割的间隔给此操作符，此时会按指定的间隔来开启新的流，如果没有指定的话，输入流的值到达时会立即开启子流，在子流完成后立即开启下一个子流。\n\n参数\n\n| Name             | Type   | Attribute | Description                    |\n| ---------------- | :----: | :-------: | -----------------------------: |\n| windowSize       | number |           | 每一个子流可以发出值的最大数量 |\n| startWindwoEvery | number | 可选      | 开启子流的间隔                 |\n\n返回值\n\nObservable<Observable<T>> 发出分割后的流的流。\n\n示例\n```js\n    Rx.Observable.fromEvetn(document, \'click\')\n        .windwoCount(3)\n        .map(win => win.skip(1))\n        .mergeAll())\n        .subscribe(v => console.log(v));\n\n    Rx.Observable.fromEvent(document, \'click\')\n        .windowCount(2, 3)\n        .mergeAll()\n        .subscribe(x => console.log(x));\n\n    Rx.Observable.interval(1000)\n        .windwoCount(4)\n        .do(() => console.log(\'NEW WINDWO\'))\n        .mergeAll()\n        .subscribe(v => console.log(v));\n```\n## windowToggle\n\n----\n实例方法\n\n将输入流分割成嵌套的流，分割时以 openings 发出值为开始，以 closingSelector 发出值为结束。\n\n* <font face=\"仿宋\">_类似于bufferToggle，但发出的是流而不是数组。_</font>\n\n        -a--b---c---d---e---f----g----h----|-->\n\n        --w-----------w-------------w------|--->\n\n            -----|-->\n\n                    windowToggle\n\n        -------------------------------------|-->\n            \\b---c|       \\e---f|       \\h|\n\n当openings发出值时开始分离输入流上的数据，当closingSelector发出值时结分离行为，分离出的流作为输出流的值发出。\n\n参数\n\n| Name            | Type                           | Attribute | Description                                                         |\n| --------------- | :----------------------------: | :-------: | ------------------------------------------------------------------: |\n| openings        | Observable<O>                  |           | 开始新的分离的通知流                                                |\n| closingSelector | function(value: O): Observable |           | 接收opeings的值作为参数，返回新的流，返回的流发出任意通知时结束分离 |\n\n返回值\n\nObservable<Observable<T>> 发出分割后的流的流。\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .windowToggle(\n            Rx.Obserbable.interval(1000),\n            i => i%2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n        )\n        .mergeAll()\n        .subscribe(v => console.log(v));\n```\n## windowWhen\n\n----\n实例方法\n\n使用一个分割函数把输入流分割成多条子流。\n\n* <font face=\"仿宋\">_类似于bufferWhen，但发出的是流而不是数组。_</font>\n\n        --a-----b----c---d---e--f----g----h---|--->\n\n        ---------------|-->\n\n                    windowWhen\n\n        --------------------------------------|--->\n        \\a------b----c| \\d---e--f----g----h|\n\n每当分割流发出通知时结束当前的分离行为，然后重新开启一个新的分割流。输出流被订阅后第一个分割流会立即被开启。\n\n参数\n\n| Name            | Type                   | Attribute | Description                                                                    |\n| --------------- | :--------------------: | :-------: | -----------------------------------------------------------------------------: |\n| closingSelector | function(): Observable |           | 不接收任何参数，返回新的流，返回的流发出任意通知时结束分离，同时开启下一个分离 |\n\n返回值\n\nObservable<Observable<T>> 输出分割流的流\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .windowWhen(() => Rx.Observable.interval(1000 + Math.randow() * 4000))\n        .map(win => win.take(2))\n        .mergeAll()\n        .subscribe(v => console.log(v));\n\n    Rx.Observale.timer(0, 1000)\n        .windowWhen(() => Rx.Observable.inerval(5000))\n        .dow(() => console.log(\'NEW WINDOW\'))\n        .mergeAll()\n        .subscribe(v => console.log(v));\n```\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"rxjs\"]',1,31),(32,'山高路远','2018-03-08 00:02:48','','官方操作符翻译（九）','工具类','## do\n\n----\n实例方法\n\n在输入流发出值是执行一个有副作用的操作，但输出流的值和输入流是完全相同的。\n\n* <font fact=\"仿宋\">_在输入流有值发出时执行一个函数，只要函数运行时没有发生错误输出的值仍然和输入流上的值一样。_</font>\n\n        ---1--------2---------3----|-->\n\n                do(v => console.log(v));\n\n        ---1--------2---------3----|-->\n\n生成一个输入流的镜像，但是这个镜像在发出值之前会执行一个具有副作用的操作，输入流上的所有通知都能安全的传递到输出流上。这个方法非常适合用来调试代码。\n\n注意，这个操作符和subscribe并不一样，它的返回值也是一个流，所有在没有订阅之前，这些副作用的操作是永远不会执行的，并不像subscribe一样会触发流的执行。\n\n参数\n\n| Name           | Type     | Attribute | Description                |\n| -------------- | :------: | :-------: | -------------------------: |\n| nextOrObserver | Observer | function  | 可选                       |  |\n| error          | function | 可选      | 处理输入流上错误通知的函数 |\n| complete       | function | 可选      | 处理输入流上结束通知的函数 |\n\n返回值\n\nObservable 会在发出值之前执行副作用的输入流镜像。\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .do(v => console.log(v))\n        .map(v => v.clientX)\n        .subscribe(v => console.log(v));\n```\n## delay\n\n----\n实例方法\n\n指定一个延迟时间，当输入流有上值到达时，输出流将延迟发射这个值，也可以指定一个日期对象，在到达此日期对象指定的值时发射值。\n\n* <font face=\"仿宋\">_以指定的延迟时间发送值。_</font>\n\n        --------a------------b------------|->\n\n                delay\n\n        --------------a------------b------|>\n\n如果此操作符的参数是一个数字，将被当成一个毫秒数，在输入流上的值到达时，输出流将延迟毫秒数指定的时间发送值，也就是说输出流发射值时最低要保持这个延迟时间。\n\n如果提供的参数是一个日期对象，这个流将会在到达这个日期时才开始发射值，这个日期之前在输入流上产生的值不会被发射。\n\n参数\n\n| Name      | Type           | Attribute | Description                                  |\n| --------- | :------------: | :-------: | -------------------------------------------: |\n| delay     | number 或 Date |           | 延迟发射值的时间间隔或者开始发射值的日期对象 |\n| scheduler | Scheduler      | 可选      | 有来提供时间概念的调度器                     |\n\n返回值\n\nObservable 以指定是延迟时间或日期规则发送值。\n\n示例\n```js\n    Rx.Observable.fromEvent(document,\'click\')\n        .delay(2000)\n        .subscribe(v => console.log(v));\n\n    Rx.Observable.fromEvent(document,\'click\')\n        .delay(new Date(2018-05-01))\n        .subscribe(v => console.log(v));\n```\n## delayWhen\n\n----\n实例方法\n\n直到另外一条流发出值后才发出输入流上的值。\n\n* <font face=\"仿宋\">_类似于delay，但它的延迟时间是由另外一条流来决定的。_</font>\n\n        -----a--------b--------d----------|-->\n\n        -------x---|->\n\n        ------------------x-|->\n\n        -------------------------------------x-|->\n\n                delayWhen(durationSelector);\n\n        -------a----------b------------------d-|->\n\n此操作符根据另外一条流来决定输入流上的值何时应该被发射。当输入流上有值到达时，传入的函数会被调用，它可以接收输入流的值作为参数，返回一条流，只有当这条流发出值或完成通知时输入流上的值才会在输出流上发出。\n\n此外它接受第二个可选参数-subscriptionDelay，这个参数是一条流，只有当它发出第一个参数或者完成通知时，输入流才开始被订阅。如果没有提供这个参数，输入流会在输出流被订阅的同时被订阅。\n\n参数\n\n| Name                  | Type                         | Attribute | Description                                                                        |\n| --------------------- | :--------------------------: | :-------: | ---------------------------------------------------------------------------------: |\n| delayDurationSelector | function(value:T):Observable |           | 接受输入流的值作为参数，返回通知流，只有当通知流发出值时输入流的值才会被输出流发出 |\n| subscriptionDelay     | Observable                   |           | 决定输入流何时被订阅的流                                                           |\n\n返回值\n\nObservable 延迟发送值的流。\n\n示例\n```js\n    Rx.Observable.fromEvent(document, \'click\')\n        .delayWhen(event => Rx.Observable.interval(Math.random() * 5000))\n        .subscribe(x => console.log(x));\n```\n## dematerialize\n\n----\n实例方法\n\n将发出Notification对象的流拆解为发出Notification对象所代表的值的流。\n\n* <font face=\"仿宋\">_将Notification对象拆解为它实际所代表的值——next、error或complete通知所代表的值。反向方法是materialize_</font>\n\n        -------------{x}-------------{y}-----------{|}--|-->\n\n                    dematerialize\n\n        --------------x---------------y------------|---->\n\n此操作符的操作对象被假设成一条只发出正常通知而不会发出错误通知的流，输入流的值都是持有实际值的元数据，在输出流上实际就是将这些值拆解到相应通知的流。\n\n返回值\n\nObservable 发出输入流上的通知对象拆解后的值的流。\n\n示例\n```js\n    var notifA = new Rx.Notification(\'N\', \'A\');\n\n    var notifB = new Rx.Notification(\'N\', \'B\');\n\n    var notifC = new Rx.Notification(\'E\', void 0, new TypeError(\'x.toUpperCases is not a function\'));\n\n    var materialized = Rx.Observable.of(notifA, notifB, notifC);\n\n    var upperCase = materialized.dematerialize();\n\n    upperCase.subscribe(x => console.log(x), e => console.error(e));\n```\n## materialize\n\n----\n实例方法\n\n将输入流上发出的值全部包装成Notification对象在输出流上发出。\n\n* <font face=\"仿宋\">_将next，error，complete通知的值都包装成Notification对象，然后在输出流上输出。_</font>\n\n        --------x------------y---------z-------|--->\n\n                    materialize\n\n        --------{x}----------{y}-------{z}-----{|}|->\n\n这个操作符将输入流上的正常值、错误值、完成通知全部包装进Notification对象。当输入流上发出完成通知时，输出流上的next通知中也会发出输入流结束的通知，然后输出流本身也将结束。当输入流发出错误通知时，输出流上的next通知也会发出这个错误，然后输出流结束。\n\n这个操作符可以用来产生流上的元数据，可以和dematerialize配合使用。\n\n返回值\n\nObservable<Notification<T>> 发出通知对象的流，这些通知对象包含了从输入流上获取到的元数据。\n\n示例\n```js\n    var letters = Rx.Observable.of(\'a\', \'b\', 13, \'c\');\n\n    var upperCase = letters.map(x => toUpperCase());\n\n    var materialized = upperCase.materialize();\n\n    materialized.subscribe(v => console.log(v));\n```\n## observeOn\n\n----\n实例方法\n\n使用指定的调度器重新发射输入流上的各个通知。\n\n* <font face=\"仿宋\">_在流的外部保证一个调度器被使用。_</font>\n\n此操作符接受一个调度器作为第一个参数，调度器用来调节输入流上值的发射。如果你不能控制给定的输入流的内部调度器，但又想控制它如何发射值，此时可以使用这个操作符。\n\n输出流上发出值和输入流是相同的，只不过使用指定调度器调节了值的发射过程。需要注意的时这并不是说输入流内部的调度器被替换掉了，原来的调度器仍然会被使用，只是当发出值时，它又被传入此操作符的调度器重新又调节了一次。在同步发出大量值的输入流上使用此操作符时会把这条流分解成异步的块。通常为了实现这效果，需要把调度器直接传递给输入流。observeOn只是简单的将通知延迟一些，以确保通知在预期的时间点发出。\n\n此操作符还可以接收第二个参数，它以毫秒为单位指定延迟通知的发送时间。observeOn 与 delay 操作符最主要的区别是它会延迟所有通知，包括错误通知，而 delay 会当源 Observable 发出错误时立即通过错误。 通常来说，对于想延迟流中的任何值，强烈推荐使用 delay 操作符，而使用 observeOn 时，用来指定应该使用哪个调度器来进行通知发送。\n\n参数\n\n| Name      | Type       | Attribute | Description          |\n| --------- | :--------: | :-------: | -------------------: |\n| scheduler | IScheduler |           | 调度器               |\n| delay     | number     | 可选      | 延迟发射值的时间间隔 |\n\n返回值\nObservable<T> 对输入流应用了指定的调度器后的流。\n\n示例\n```js\n    Rx.Observable.interval(1000)\n        .observeOn(Rx.Scheduler.animationFrame)\n        .subscribe(val => {\n            someDiv.style.height = val + \'px\';\n        });\n```\n## subscribeOn\n\n----\n实例方法\n\n使用指定的调度器异步的订阅输入流。\n\n    ----a----------------b-----|-->\n\n                subscribeOn(scheduler);\n\n    ====a================b=====|==>\n\n参数\n\n| Name      | Type      | Attribute | Description |\n| --------- | :-------: | :-------: | ----------: |\n| scheduler | Scheduler |           | 调度器      |\n\n返回值\nObservable<T> 修改过的输入流以便使它的订阅发生在指定的调度器上。\n\n示例\n\n## timeInterval\n\n----\n实例方法\n\n参数\n\n| Name      | Type      | Attribute | Description |\n| --------- | :-------: | :-------: | ----------: |\n| scheduler | Scheduler |           | 调度器      |\n\n## timestamp\n\n----\n实例方法\n\n参数\n\n| Name      | Type      | Attribute | Description |\n| --------- | :-------: | :-------: | ----------: |\n| scheduler | Scheduler |           | 调度器      |\n\n## timeout\n\n----\n实例方法\n\n参数\n\n| Name      | Type      | Attribute | Description |\n| --------- | :-------: | :-------: | ----------: |\n| due       | number    |           |             |\n| scheduler | Scheduler |           | 调度器      |\n\n## timeoutWith\n\n----\n实例方法\n\n参数\n\n| Name           | Type      | Attribute | Description |\n| -------------- | :-------: | :-------: | ----------: |\n| due            | any       |           |             |\n| withObservable | any       |           |             |\n| scheduler      | Scheduler |           | 调度器      |\n\n## toArray\n\n返回值\n\nObservable<any[]> | WebSocketSubject<T> | Observable<T>\n\n## toPromise\n\n将输入流转化成符合ES6标准的promise\n\n参数\n\n| Name        | Type               | Attribute | Description                                                                                                    |\n| ----------- | :----------------: | :-------: | -------------------------------------------------------------------------------------------------------------: |\n| PromiseCtor | PromiseConstructor | 可选的    | Promise的构造函数。如果没有提供的话，它会在 Rx.config.Promise中寻找构造函数，然后回退成原生的Promise构造函数。 |\n\n返回值\n\nPromise<T> 符合ES6的Promise，使用输入流的最后一个值。\n\n示例\n```js\n    const source = Rx.Observable.of(42)\n        .toPromise();\n\n    source.then(v => console.log(v));\n```\n\n转载请注明出处：www.hijavascript.com',1,1,0,'[\"rxjs\"]',1,32),(33,'山高路远','2017-03-19 12:40:17',NULL,'Javascript最佳实践','','## 编程风格\n1. 基本格式化：缩进层级、语句结尾、行的长度、换行、命名、直接量\n2. 注释：单行注释、多行注释、注释申明（todo hack xxx fixme review）、什么时候使用注释\n3. 语句和表达式：花括号对齐方式、块语句间隔、switch语句、with语句、for、for-in循环\n4. 变量、函数和运算符：变量声明、函数声明、函数调用间隔、立即调用的函数、严格模式、相等（eval和原始包装类）\n## 编程实践\n1. UI层的松耦合：将javascript从CSS抽离、将CSS从javascript中抽离、将javascript从HTML中抽离、将HTML从javascript中抽离\n2. 避免使用全局变量：命名冲突、代码的脆弱性、测试难度、意外的全局变量、单全局变量方式\n3. 事件处理：隔离应用逻辑、不要分发事件对象\n4. 避免空比较：检测原始值、检测引用值（函数、数组）、检测属性\n5. 将配置数据从代码中分离：什么是配置数据、抽离配置数据、保存配置数据\n6. 抛出自定义错误：错误的本质、抛出错误的好处、什么时候抛出错误、try-catch语句、错误类型\n7. 不是你的对象不要动：不覆盖、新增、删除对象的属性及方法、基于对象的继承、基于类的继承、门面模式，阻止修改\n8. 浏览器嗅探：特性检测、避免特性推断、避免浏览器推断\n## javascript中的毒瘤\n1. 全局变量\n2. 没有块级作用域\n3. 自动插入分号\n4. 保留字，在作用对象的Key使用时需要用引号包裹\n5. typeof\n6. parseInt\n7. +\n8. 浮点数 IEE754标准\n9. NaN\n10. 假值\n11. hasOwerProperty是方法\n12. js对象没有真正的空对象\n##糟粕\n1. ==\n2. with 和 eval\n3. continue语句\n4. switch穿越\n5. 缺少块的语句\n6. ++ --\n7. function 对比 function表达式\n8. 包装对象\n9. new\n10. void\n\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"javascript\",\"other\"]',1,33),(34,'山高路远','2017-08-17 22:34:43',NULL,'javascript函数按值传递参数','','# js中函数按值传递参数\n\n## 代码\n```js\n    var outPerson= {\n                name:\"superMan\",\n                age:1000\n    }\n    function sayName(person){\n                person.name = \"wukong\";\n                console.log(\"inner\",person.name);\n    }\n\n    sayName(outPerson); // inner wukong\n    console.log(\"out\",outPerson.name); // out wukong\n```\n在内部函数中改变了外部对象的属性值，看起来貌似将外部对象的引用传了进去：\n\n```js\n    var outPerson = {\n                name:\"superMan\",\n                age:1000\n            }\n    function sayName(person){\n        var innerPerson = {\n            name:\"iIronMan\",\n                age:100\n        }\n        person = innerPerson;\n        console.log(\"inner\",person.name);\n    }\n    sayName(outPerson); // inner ilronMan\n    console.log(\"out\",outPerson.name); // out superman\n```\n\n接着上面的，如果引用被传了进去，外部输出的应该是什么？\n\n```js\n    var outPerson = {\n        name:\"superMan\",\n        age:1000\n    }\n    function sayName(person){\n        var innerPerson = {\n        name:\"iIronMan\",\n        age:100\n    }\n    console.log(“inner”,person.name); // inner superMan\n    person = innerPerson;\n    person.name = \"wukong\";\n        console.log(\"inner\",person.name); // inner wukong\n    }\n    sayName(outPerson);\n    console.log(\"out\",outPerson.name); // out superMan\n```\n\n## 代码分析\n\n例子举完了，那么究竟什么是按引用传递，什么是按值传递。\n要弄清楚这个问题，首先我们要清楚在JS中值是如何保存和如何复制的。\n\n### 保存\n\n1. 原始值类型保存在栈内存中，引用类型保存在堆内存中。\n2. 对变量赋值时，如果变量的类型为引用类型，那以在栈内存中实际保存的是此对象在堆内存的地址，如果变量的类型为原始值，则在栈内存中开辟一块区域来保存这个值。\n\n### 复制\n1. 对于原始值，在栈内存开辟一块区域，保存一个原始值的副本；对于引用类型，开辟一块区域，保存一个此引用类型在堆内存中的地址的副本。\n\nvar a = 5; 会在栈中开辟一块内存，将5保存在其中\n\n| 内存地址 | 1001 |\n| ------- | -----|\n| 值 | 5 |\n| 变量 | a|\n\n\nvar b =a; 得到一个变量b，将a中的值赋给b；\n\n| 内存地址 | 1001 | 1002 |\n| ------- | -----| ---- |\n| 值 | 5 | 5 |\n| 变量 | a | b |\n\na = 10;a的值变成10，而b的值并不会受到影响\n\n| 内存地址 | 1001 | 1002 |\n| ------- | -----| ---- |\n| 值 | 10 | 5 |\n| 变量 | a | b |\n\n2. 对于引用类型也一样，只不过这个值是一个堆内存的地址。\n\n    var obj = {a:2}\n\n栈内存\n\n| 内存地址 | 1001 | 1002 | 1003 |\n| ------- | -----| ---- | ---- |\n| 值 | 2001 |  |  |\n| 变量 | obj |  | |\n\n堆内存\n\n| 内存地址 | 2001 | 2002 | 2003 |\n| ------- | -----| ---- | ---- |\n| 值 | {a:2} |  |  |\n\n    var ele = obj;\n\n栈内存\n\n| 内存地址 | 1001 | 1002 | 1003 |\n| ------- | -----| ---- | ---- |\n| 值 | 2001 | 2001 |  |\n| 变量 | obj | ele | |\n\n堆内存\n\n| 内存地址 | 2001 | 2002 | 2003 |\n| ------- | -----| ---- | ---- |\n| 值 | {a:2} |  |  |\n\nele.a = 3;将会把堆内存地址2001中的值改为3，此时如果访问obj.a，得到结果也就是3。\n\n## 传参时的情况\n回到开始时的函数，在调用sayName函数时发生的过程就是：\n1. 开辟一块内存，把outPerson变量的内存地址中保存的值复制给sayName函数的行参person；\n\n2. 行参person在函数内部如果没有被重新赋值，它的内存中将始终保存的是outPerson对象在堆中的内存地址。\n\n3. 如果在函数内部重新给person赋值，那么person变量内存中保存的值将被修改（赋原始值，保存原始值 ；赋引用类型的值，保存对应值的堆内存地址），也就是说此时person变量完全断开了和原来对象的关系。\n\n## 如果传递的是引用会发生什么\n\n假设在函数传参时是把引用传进去，会有2种传法:\n\n1. outPerson在传递时把自己的引用传给person，那么对person的赋值必然会改变outPerson变量中内存的值，在例2中外部就应该输出out ilronMan；\n\n2. outPerson在传递时不去开辟新的内存，把引用直接传给person，得到的结果和前面是一样的。\n所以在JS中，原始类型传递时按值传递，引用类型传递时按值传递了引用，所以归根结底在js的参数传递过程都都是按值进行传递。\n\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"javascript\"]',1,34),(35,'前端大耍','2018-04-10 20:44:16',NULL,'【进阶】在Angular应用中使用socket.io','','> 我们已经知道如何在angular 中使用 websocket 和服务器进行交互。但是程序的健壮性不够，也有很多同学起node服务器的时候会遇到错误，难以解决。客户端代码中的websocket 代码也不够健壮，操作起来也不方便。本文介绍一种更好的方案： socket.io\n> 首先，新建服务端文件夹 server。进入文件夹。\n\n```shell\nnpm init -y\nnpm install --save socket.io\n```\n\n> 建立服务端入口文件 index.js\n\n```js\nconst http = require(\'http\');\nconst io = require(\'socket.io\');\n\n\nconst httpServer = http.createServer((req, res) => {\n  res.end();\n});\n\nconst ioServer = io(httpServer);\n\nioServer.on(\'connection\', socket => {\n  console.log(\'some one connected\');\n  // 监听客户端推送的 \'clientMessage\' 事件\n  socket.on(\'clientMessage\', msg => {\n    console.log(msg);\n    // 向客户端推送 \'serverMessage\' 事件。\n    socket.emit(\'serverMessage\', msg);\n  });\n});\n\n\nhttpServer.listen(\n  8080,\n  () => console.log(\'server started\')\n);\n\n```\n\n> 先用 @angular/cli 新建项目，然后额外安装 socket.io 以及对应的 types。\n\n```\n$ npm i --save socket.io\n$ npm i --save-dev @types/socket.io-client\n```\n\n> 新建 websocket 服务\n\n```js\n$ ng g s websocket -m app\n```\n\n> 代码：\n\n```js\n// websocket.service.ts\nimport {Injectable} from \'@angular/core\';\nimport * as SocketIO from \'socket.io-client\';\nimport {Subject} from \'rxjs/Subject\';\nimport {Observable} from \'rxjs/Observable\';\n\n@Injectable()\nexport class Websocket2Service {\n\n  io;\n  message$: Observable<string>;\n  private _message$ = new Subject<string>();\n\n  constructor() {\n\n    this.io = SocketIO(\'ws://localhost:8080\');\n    this.io.emit(\'connection\');\n    // 客户端在监听服务器推送的 \'serverMessage\'事件。\n    this.io.on(\'serverMessage\', (msg) => this._message$.next(msg));\n    // 这里为什么进行额外的转换，请看历史文章： Rxjs 之 asObservable\n    this.message$ = this._message$.asObservable();\n  }\n\n  sendMessage(message: string) {\n    // 对比原生的websocket实现，你可以 emit 指定类型的事件，服务器只要在监听\n    // 你指定的事件，就会做响应的处理。普通的websocket 里则要通过的发送的信息中\n    // 添加额外的类型信息，服务器通过解析才知道这个请求对应的处理方式。\n    // 这里服务器在监听着 \'clientMessage\' 事件。\n    this.io.emit(\'clientMessage\', message);\n  }\n}\n```\n\n> 在组件中使用\n\n```js\nimport {Component, OnInit} from \'@angular/core\';\nimport {WebsocketService} from \'./websocket.service\';\n\n@Component({\n  selector: \'app-root\',\n  template: `\n    <ul>\n      <li *ngFor=\"let msg of messages\">{{msg}}</li>\n    </ul>\n\n    <p *ngIf=\"error\">{{error | json}}</p>\n    <p *ngIf=\"completed\">completed!</p>\n\n\n    <input type=\"text\"\n           #message>\n    <button (click)=\"send(message.value);message.value=\'\';\">send</button>\n  `,\n  styleUrls: [\'./app.component.css\']\n})\nexport class AppComponent implements OnInit {\n  messages = [];\n  error: any;\n  completed = false;\n\n  constructor(private websocketService: WebsocketService) {\n  }\n\n  ngOnInit(): void {\n    this.websocketService.message$.subscribe(\n      msg => {\n        console.log(msg);\n        this.messages.push(msg);\n      }\n    );\n  }\n\n  send(message: string) {\n    this.websocketService.sendMessage(message);\n  }\n}\n```\n\n> 运行截图：\n![2018-04-28下午4_56_141539792822964.png](http://pghicsch6.bkt.clouddn.com/2018-04-28下午4_56_141539792822964.png)\n\n\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\",\"other\"]',2,35),(36,'前端大耍','2018-05-09 10:24:36',NULL,'HostListener 和 HostBinding 两兄弟','','> 老实说，我早就想写他们了，可是觉得他们太简单，没什么好说的。\n>\n> 这兄弟俩都是在 Directive 内部使用的。用处不同，但都一个意思。\n>\n> HostBinding 监听指令的宿主元素身上的属性。\n>\n> HostListener 监听指令的宿主元素身上的事件。\n>\n> 但是它们都很懒，只监听你命令他们去监听的东西。\n\n\n\n```typescript\n// spy.directive.ts\nimport {Directive, ElementRef, HostBinding, HostListener} from \'@angular/core\';\n\n// 这个很明显，是一个指令，而且取了个很合适的名字。\n// 指令就像一个间谍，它埋伏在宿主元素身上，监视着其一举一动\n@Directive({\n  selector: \'[appSpy]\'\n})\nexport class SpyDirective {\n  \n  hover = false;\n  // 你看，指令一旦被创建出来，它就拥有了对宿主元素的引用！\n  // 这意味着，宿主注定要任其摆布！\n  constructor(private ele: ElementRef) {\n  }\n  // 老大出场了，想操控宿主的 style 属性中的 font-size\n  // 它得逞了，前端界至高之神 Angular 赋予了它这样的能力。\n  // 每当 hover 属性变成 true 时，它就将宿主 style 属性中的 font-size 变成特大。\n  // 宿主很无奈，只能任其摆布。\n  @HostBinding(\'style.fontSize\')\n  get fontSize() {\n    return this.hover ? \'xx-large\' : \'small\';\n  }\n  // 老大觉得不够过瘾，又来玩 style.color 属性。\n  // 宿主继续任其摆布\n  @HostBinding(\'style.color\')\n  get color() {\n    return this.hover ? \'inherit\' : \'#fff\';\n  }\n  // 老二不甘寂寞，也来了。它想监听宿主身上的 mouseenter 事件，\n  // 每当鼠标指针移动到宿主身上，它就把宿主的字体颜色变成红色。\n  // 玩的不亦乐乎。\n  @HostListener(\'mouseenter\', [\'\"red\"\'])\n  mouseenter(color: string) {\n    this.ele.nativeElement.style.backgroundColor = color;\n    this.hover = true;\n  }\n // 看到宿主幽怨的眼神，老二决定当鼠标从宿主身上离开时，还宿主一个清白。\n // 可是，what？搞错了颜色。。宿主的脸色变了。。。\n  @HostListener(\'mouseleave\', [\'\"blue\"\'])\n  mouseleave(color: string) {\n    this.ele.nativeElement.style.backgroundColor = color;\n    this.hover = false;\n  }\n}\n\n```\n\n> 可怜可怜这个纯真的你好组件吧！\n\n```typescript\n// hello.component.ts\nimport {Component} from \'@angular/core\';\n\n// 因为太纯真，已经被间谍指令附身，接下来的日子只能听天由命了。。。\n@Component({\n  selector: \'app-hello\',\n  template: `\n    <p appSpy>\n      hello works!\n    </p>\n  `,\n})\nexport class HelloComponent {\n}\n\n```\n\n> 注意参数，注意参数，虽然参数是字符串数组，可你注意到它们有几个引号了么？`[\'\"red\"\'] or [\'red\'] `?\n\n\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',2,36),(37,'前端大耍','2018-05-13 23:35:08',NULL,'Angular 6 LazyLoading 变化','','> 升级到 Angular6 以后，发现lazyloading 模块无法正常工作了。控制台报错：\n\n```JS\ncore.js:1598 ERROR Error: Uncaught (in promise): Error: Cannot find module \"app/optimization/optimization.module\".\n```\n\n> 很奇怪，于是去官网看 issue，发现有变化，下面是 github 上显示的修改：\n\n```JS\nconst routes: Routes = [\n   {\n     path: \'customers\',\n-    loadChildren: \'app/customers/customers.module#CustomersModule\'\n+    loadChildren: \'./customers/customers.module#CustomersModule\'\n   },\n   {\n     path: \'orders\',\n-    loadChildren: \'app/orders/orders.module#OrdersModule\'\n+    loadChildren: \'./orders/orders.module#OrdersModule\'\n   },\n   {\n     path: \'\',\n```\n\n> 原来 loadChildren 对应的路径发生了改变。需要将路径设置为与当前模块的相对路径。比如原来我的目录结构是这样的。\n\n```JS\n--src\n  --app\n    app.module.ts\n    app-routing.module.ts\n  --optimization\n    -optimization.module.ts\n    -optimization-routing.module.ts\n```\n\n> Angular5 中 AppRouting 的配置：\n\n```JS\nconst routes: Routes = [\n  {\n      path: \'optimization\',\n      loadChildren: \'app/optimization/optimization.module#OptimizationModule\'\n  }\n];\n```\n\n> 现在需要修改为：\n\n```JS\nconst routes: Routes = [\n  {\n      path: \'optimization\', \n   	  loadChildren: \'./optimization/optimization.module#OptimizationModule\'\n  }\n];\n```\n\n> 也就是 optimization.module.ts 相对于 app-routing.module.ts 的路径。\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',2,37),(38,'前端大耍','2018-05-24 22:20:45',NULL,'Angular FormGroup','','使用 Angular 来创建响应式表单真的是 so easy。我们先用 fromGroup 来创建一个表单。\n\n```typescript\n@Component({\n  selector: \'app-root\',\n  template: `\n    <form [formGroup]=\"myForm\">\n      <input formControlName=\"userName\">\n      <input formControlName=\"password\">\n      <button>submit</button>\n      <div>{{myForm.value|json}}</div>\n    </form>\n`\n})\nexport class AppComponent implements OnInit {\n\n  myForm: FormGroup;\n\n  constructor() {\n\n  }\n\n  ngOnInit(): void {\n    this.myForm = new FormGroup({\n      userName: new FormControl(\'abc\'),\n      password: new FormControl(\'123\'),\n    });\n  }\n}\n```\n\n需要注意三个要素：\n\n1. 创建响应式表单，需要在模块中引入 ReactiveFormsModule。\n2. 注意 form 元素上的 formGroup ，它包含一组 FormControl ，跟踪他们的值和校验状态的变化。\n3. 每一个需要跟踪的 FormControl 都需要显式的指定 formControlName，这个指定的名称会做为其在FormGroup中的key。\n\n关于FormControl 的具体使用方式，在上一篇文章中已经做了说明。\n\n通过给 form 元素添加 ngSubmit 事件，来控制表单提交的逻辑。\n\n```typescript\n<form [formGroup]=\"myForm\" (ngSubmit)=\"onSubmit()\"> ...\n\n...\nonSubmit(){\n    console.log(this.myForm.value); // { \"userName\": \"abc\", \"password\": \"123\" }\n    this.http.post(\'...\',this.myForm.value).subscribe(...)\n}\n```\n\nAngular 提供了 FormBuilder 类，可以在表单域较多时，显著的减少代码量：\n\n```typescript\nconstructor(private fb:FormBuilder)\nngOnInit(){\n     this.myForm = this.fb.group({\n      userName: \'abc\',\n      password: \'1234\',\n    });\n}\n```\n\n对 Angular 了解的越多，你做项目的速度就越快！ \n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',2,38),(39,'前端大耍','2018-06-25 17:35:20',NULL,'Angular Http 请求的错误处理方式','','在 Angular 中，对 http 请求的错误处理非常重要。有时候客户端由于网络原因，或服务端因为出了些异常，导致请求失败。如果我们能重新请求一下，就会获得正确的响应。今天我们主要来说一下，对于失败的请求，如何重新发起。\n\n- retry\n\n```js\nhttp.get(\'url\').pipe(\n	retry(3),\n    catchError(error=> this.handleError(error))\n)\n```\n\n上面的代码在请求失败后，会重新请求三次，如果三次请求同样都失败了，才会触发error，走进 catchError的处理逻辑中。\n\n上面的代码问题是三次请求都是立即发起的，间隔时间短，服务器也许还没有从异常中恢复。三次请求连续失败的可能性较大。我们希望在请求失败后，延迟两秒再次发起请求，这样成功机率大些。这就需要用到另一个操作符。\n\n- retryWhen\n\n```js\nhttp.get(\'url\').pipe(\n	retryWhen(error=>error.pipe(delay(2000))),\n    catchError(error=>this.handleError(error))\n)\n```\n\n可以看到，当请求失败后，每隔两秒，就会再次发出请求。这时候问题又来了，如果服务器这个接口真的出问题了，总不能无止境的请求下去，要限制重试次数。\n\n```js\nhttp.get(\'url\').pipe(\n	retryWhen(error=>error.pipe(delay(2000),take(2))),\n    catchError(error=>this.handleError(error))\n)\n```\n\n现在，我们最多试两次，就不试了，还不成功就让它走catchError的流程。但是，你会发现即使请求都失败了，也不会走 catchError的流程。\n\n这是因为 retryWhen 重试两次后，就 complete 了。它并没有将 error 传递给后面的操作符。如何解决？我们还需要一个操作符。\n\n- scan\n\n```js\nhttp.get(\'url\').pipe(\n    retryWhen(error=>{\n        error.pipe(\n            scan((retryCount,_error)=>{\n                retryCount+=1;\n                if(retryCount>2){\n                    throw _error;\n                }else{\n                    return retryCount\n                }\n            },0),\n            delay(2000)\n        )\n    }),\n    catchError(error=>this.handleError)\n)\n```\n\n通过 scan 我们记录并叠加了重试次数，如果重试次数大于2次，就抛出错误，而这个错误，正是 http 的错误对象。这样，catchError就可以抓到并处理了。试试吧！\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',2,39),(40,'前端大耍','2018-05-21 19:33:01',NULL,'Angular Provider','','我们可以很容易的编写一个 service ，并将其通过DI注入到Component 或别的 service 中去。\n\n```typescript\n// a.service.ts\n@Injectable({})\nclass ServiceA {\n    ...\n}\n    \n// a.module.ts\n@NgModule({\n    ...\n    providers:[ServiceA]\n })\nclass AModule{}\n\n// \n```\n\n但是如果我们想注入的东西并不是一个 service ，该怎么做？看一个简单的例子：\n\n```typescript\n@Injectable({})\nclass ServiceB{\n    constructor(private config:ServiceBConfig){}\n    \n    log(message:string){\n        if(this.config.isProd){\n            return;\n        }\n        window.console.log(message);\n    }\n}\n```\n\n这个 service 需要在构造函数中传入一个 config，config 是一个对象，对象中的属性决定了service中 log 方法的逻辑：如果目前是生产环境，则不在控制台输出信息，可能是出于安全性的考虑。\n\n```\ninterface ServiceBConfig{\n    isProd:boolean;\n}\n```\n\n很明显，config 只是一个对象字面量，并不是一个可注入的 service。如果直接运行项目，会报错，因为 angular 不知道从哪里得到这个 config 对象，用以实例化 ServiceB。\n\n这时候我们就需要用到 provider 的另一种模式： useFactory。\n\n```typescript\n// b.module.ts\nconst config:ServiceBConfig = {\n    isProd: false\n}\n@NgModule({\n    ...\n    providers:[\n        {\n			provide: ServiceB,\n    		useFactory: serviceBFactory(config),\n        }\n    ]\n})\n\nconst serviceBFactory = \n      (config:ServiceBConfig) =>\n		() => new ServiceB(config);\n```\n\nuserFactory 的值必须为一个返回 ServiceB 实例的函数。因为我们需要接收一个 config 来实例化 ServiceB，所以这里使用了高阶函数。serviceBFacotry(config) 执行后返回的正是 useFactory 需要的函数:\n\n```\n()=> new ServiceB(config)\n```\n\n这样，我们就可以很灵活的根据环境来实例化所需要的service。\n\n我们仍然像以前一样使用它：\n\n```typescript\n@Component({...})\nexport class ComponentB{\n    constructor(private serviceB:ServiceB){}\n}\n```\n\n但是在 ng build 时，控制台会有警告：\n\n```js\nCan\'t resolve all parameters for ServiceB in ... This will become an error in Angular ...\n```\n\n这是因为 angular 在 build 时会去检查所有声明了@Injectable 的类的 constructor 需要的参数。Angular 要在程序用到这个类的实例时对其进行实例化。如果参数也是可注入的，Angular 自己可以找到。但是 config 并不是，所以 Angular 会给出警告，因为如果找不到，程序运行时就会出错。\n\n但是我们自己写的程序，很清楚的知道，config 参数我们是用 ServiceBFactory 传进去的。如何避免这个警告呢？很简单，去掉 ServiceB 的 @Injectable 声明：\n\n```typescript\n//@Injectable()\nexport class ServiceB{\n    ...\n}\n```\n\n再进行build，发现警告消失了。\n\n去掉了@Injectable ，我的 serviceB 还可以被注入么？\n\n实际上，当你使用依赖注入时，Angular 寻找的只是一个 InjectionToken：\n\n```typescript\n// b.component.ts\n...\nconstructor(private serviceB:ServiceB){}\n...\n```\n\n它找的是 ServiceB 这个 token ，并不是 ServiceB这个类，我们平时在 providers 数组中声明的 provider，其实相当于\n\n```typescript\n@NgModule({\n    ...\n    //providers:[ServiceA]\n    // 相当于\n    providers:[\n   	{\n    	provider: ServiceA, // angular 会创建一个名称一样的 token\n    	useFactory: (...args)=> new ServiceA(...args),\n    	deps:[...]\n	  }\n    ]\n})\n\n```\n\nangular 会自动生成一个和类名一样的token。并生成一个 factory 函数，函数的参数就是constructor 中的参数。 参数的值是地 deps数组中指定的其它可注入类。\n\n如果我们的 service C 依赖了另一个可注入类：\n\n```typescript\n// b.service.ts\nexport class ServiceC{\n    constructor(private userService:UserService){}\n}\n```\n\n那么实际上 angular 会将基转换为\n\n```typescript\n@NgModule({\n    ...\n    providers:[\n    	{\n    		provide: ServiceC, \n    		useFactory: (userService:UserService)=>new ServiceC(userService),\n    		deps:[UserService]\n   		}\n    ]\n})\n```\n\n需要注意的是 UserService 必须声明为可注入的\n\n```typescript\n@Injectable()\nexport class UserService{...}\n```\n\n所以，DI 使用时，在构造函数中声明的是 token，而使用的，是这个token对应的实例。\n\n我们也可以偷梁换柱：\n\n```typescript\n@NgModule({\n    ...\n    providers:[\n    	{\n    		provide: ServiceC, \n    		useFactory: ()=>new ServiceA(),\n    		deps:[]\n   		}\n    ]\n})\n```\n\n现在，当我们在组件中注入 ServiceC 时，实际得到的是 ServiceA的实例。因为 ServiceA 的 constructor 中没有依赖，所以我们不需要在 factory 函数中声明参数，deps数组也是空的，可以不写。\n\n当然，在实际项目中，我们不会这么使用。因为当你使用 ServiceC时，会创建一个新的 ServiceA 实例，而服务应该（大部分情况) 是单例的。如果真要给 ServiceA 起个别名，应该使用 useExisting\n\n```typescript\n...\n{provide: ServiceC, useExisting: ServiceA}\n```\n\n这样， angular 会在注入 ServiceC 时，寻找已经存在的 ServiceA 的实例，而不是再创建一个。\n\n依赖注入的知识点很多，今天先说这么多。代码是基于 angular5的，angular6中又有一些改变，后面慢慢写。如果有什么问题，欢迎入群交流。\n\n\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',2,40),(41,'前端大耍','2018-07-20 21:07:26',NULL,'Angular Router 跳转到指定 Tab 页','','在开发中遇到一个需求：A页面包含一个 tab 组件，不同的 tab标签点击后显示不同的内容。B页面中包含一组 链接，要求点击链接时跳到A页面对应的 tab 标签页下。看了下官方文档，实现起来很简单。需要注意三个点：\n\n- Router\n- ActivatedRoute\n- ParamMap\n\nB页面具体实现如下：\n\n```type\n@Component({\n  selector: \'app-link-page\',\n  template: `\n   <span (click)=\"toTab(1)\">to tab1</span>\n   <span (click)=\"toTab(2)\">to tab2</span>\n   <span (click)=\"toTab(3)\">to tab3</span>\n  `,\n  styles: []\n})\nexport class LinkPageComponent implements OnInit {\n  constructor(private router: Router) {}\n\n  ngOnInit() {}\n\n  toTab(index) {\n  	// 注意这里参数的传递方式\n    this.router.navigate([\'tab-page\', { tab: index }]);\n  }\n}\n```\n\nA页面实现如下：\n\n```ts\n@Component({\n  selector: \'app-tab-page\',\n  template: `\n   <ul>\n    <li [class.active]=\"tab==1\">tab1</li>\n    <li [class.active]=\"tab==2\">tab2</li>\n    <li [class.active]=\"tab==3\">tab3</li>\n   </ul>\n  `,\n  styles: [\n    `\n      li {\n        display: inline-block;\n        list-style: none;\n      }\n      .active {\n        background: blue;\n        color: white;\n      }\n    `\n  ]\n})\nexport class TabPageComponent implements OnInit {\n  tab: any = 1;\n  constructor(private route: ActivatedRoute) {}\n\n  ngOnInit() {\n    this.route.paramMap\n      .pipe(\n        switchMap(params => {\n          this.tab = params.get(\'tab\');\n          return null;\n        })\n      )\n      .subscribe();\n  }\n}\n```\n\n也可以用其它的方式，Angular 非常灵活。\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',2,41),(42,'前端大耍','2018-05-21 19:18:01',NULL,'Angular Validator','','> 表单是现代网页应用构成的重要元素，而其中的难点又是表单校验。\n>\n> Angular 内置了几个表单校验指令。\n\n```html\n<input required minlength=\"4\" />\n```\n\n> 如果用户没有输入内容，或输入长度不足4个字符，需要做出错误提示。\n\n```html\n<input #name=\"ngModel\" ngModel required minlength=\"4\">\n<div *ngIf=\"name.invalid && (name.dirty||name.touched)\">\n    input is invalid.\n</div>\n```\n\n> 上面是一个模板驱动表单，需要注意几点：\n>\n> 一，要使用 ngModel，需要在模块中引入 FormsModule。\n>\n> 二，`#name=\"ngModel\"`这行代码是将一个 ngModel 的实例，赋值给一个模板变量。\n>\n> 三，ngModel 实例有很多属性， invalid属性代表此实例的值是否无效（未通过验证），dirty代表input 是否获取过焦点，touched 代表在移动端是否获取过焦点（你不希望表单在你没碰过的时候就提示错误吧）。\n>\n> 四，`*ngIf=\"name.invalid && (name.dirty||name.touched)\"`如果此表达式为真，则显示错误提示。\n>\n> 如果我希望提示更加精确呢？仅仅是一个 `input is invalid`可能用户并不知道哪里错了。\n\n```html\n<input #name=\"ngModel\" ngModel required minlength=\"4\">\n<div *ngIf=\"name.invalid && (name.dirty||name.touched)\">\n     <div *ngIf=\"name?.errors.required\">\n        Name is required.\n      </div>\n      <div *ngIf=\"name?.errors.minlength\">\n        Name must be at least 4 characters long.\n      </div>\n</div>\n```\n\n> 是的，就是这样。这里需要注意的是 `name?.errors`这个属性。（？是模板版中的语法，不这样写会报错，在github是仍是一个 open issue）。\n>\n> 如果在input中输入3个字符，在控制台输出name.errors，会是这样的：\n\n```js\n{ \"minlength\": { \"requiredLength\": 4, \"actualLength\": 3 } }\n```\n\n> 也就是说，`name?.errors` 是个对象，它的 key 就是未通过校验的规则，value 是一个可能为任意类型的值。为什么这么说？把input里的字符全部删掉，再看一下 错误输出：\n\n```js\n{ \"required\": true}\n```\n\n> 现在 key 还是未通过校验的规则，但是value变成了一个布尔类型的值。\n>\n> Angular 还提供了一些其它的校验规则：\n\n```typescript\nclass Validators {\n  static min(min: number): ValidatorFn\n  static max(max: number): ValidatorFn\n  static required(control: AbstractControl): ValidationErrors | null\n  static requiredTrue(control: AbstractControl): ValidationErrors | null\n  static email(control: AbstractControl): ValidationErrors | null\n  static minLength(minLength: number): ValidatorFn\n  static maxLength(maxLength: number): ValidatorFn\n  static pattern(pattern: string | RegExp): ValidatorFn\n  static nullValidator(c: AbstractControl): ValidationErrors | null\n  static compose(validators: (ValidatorFn | null | undefined)[] | null): ValidatorFn | null\n  static composeAsync(validators: (AsyncValidatorFn | null)[]): AsyncValidatorFn | null\n}\n```\n\n> 即便如此，还是远远满足不了业务需要。就举个小例子：我们在 input 里面输入了四个空格，发现校验居然通过了！\n\n```js\n<input required minlength=\"4\" ...\n```\n\n> 看来 required 会把空格当作有效输入，minlength 也是一样。既然它们满足不了需求，我们只能自己动手了。\n>\n> 我们希望最终的结果是这样的：\n\n```\n<input required minlength=\"4\" noEmpty ...\n```\n\n> 很显然， noEmpty 是一个 Directive。\n\n```js\nimport {Directive} from \'@angular/core\';\nimport {AbstractControl, NG_VALIDATORS, ValidationErrors, Validator} from \'@angular/forms\';\n\n\n@Directive({\n  selector: \'[noEmpty]\',\n  providers: [{provide: NG_VALIDATORS, useExisting: NoEmptyDirective, multi: true}]\n})\nexport class NoEmptyDirective implements Validator {\n  // 这个方法没用到，忽略。但是接口中有定义，又不能不实现，就让它空着吧。\n  registerOnValidatorChange(fn: () => void): void {\n  }\n  // 主要是这个方法。\n  // 它会将 input 对应的 ngModel 实例中的 formControl 传入这个方法中进行校验。\n  // 虽然有些绕，但事实如此。Angular 在对象的封装上下了很多功夫。\n  // formControl 的 value 就是input中你输入的值。\n  validate(c: AbstractControl): ValidationErrors | null {\n    const value = c.value;\n    // 我们仅仅是 去掉了 value 两边的空格。\n    // 按照约定，如果校验通过，返回 null,\n    // 如果不通过，返回一个对象。\n    // 对象的 key 为校验规则，value 为任意类型，你可以定义为你想要的任意格式。\n    return value && value.toString().trim() !== \'\' ? null : {noEmpty: {value}};\n  }\n}\n\n```\n\n> 需要注意的是 ` providers: [{provide: NG_VALIDATORS, useExisting: NoEmptyDirective, multi: true}]`这一行。\n>\n> provide 属性对应的是一个 token:`NG_VALIDATORS` 。这个token 是所有 validators 共用的，所以需要 muti:true属性，如果不加会报错。\n>\n>  `useExisting`表示使用已有的 `NoEmptyDirective`实例。如果使用 `useClass`，则会重新创建一个新的 `NoEmptyDirective`。(这个知识点你要深入学习一下 Angular 的 DI)。\n>\n> 现在让我们试一下效果，输入四个空格：\n\n```js\nnull\n```\n\n> what?\n>\n> 哦，忘了把它加到 declarations 数组了。。。\n\n```js\n@NgModule({\n    declarations:[NoEmptyDirective,...],\n    ...\n})\n```\n\n> 再试一次：\n\n```js\n{ \"noEmpty\": { \"value\": \" \" } }\n```\n\n> 欢迎对 Angular 感兴趣的同学入群学习！\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',2,42),(43,'前端大耍','2018-07-03 16:48:49',NULL,'Angular 动态创建表单','','在日常开发中，表单模板的书写工作乏味而繁冗。如何减少这部分工作量？\n\n表单元素无非就那么几种。\n\n```html\n<form [formGroup]=\"form\">\n    <input type=\"text\" formControlName=\"username\">\n    <input type=\"password\" formControlName=\"password\">\n    <select formControlName=\"area\">\n        <option value=\"100000\">北京</option>\n    </select>\n	<input type=\"radio\" formControlName=\"gender\" value=\"male\">男	\n    <input type=\"radio\" formControlName=\"gender\" value=\"female\">女\n	<button>提交</button>\n</form>\n<pre>{{form.value|json}}</pre>\n```\n\n这个表单只有很少的字段，但是工作中遇到的可不是这么简单，写起来很累。\n\n我们可以先看下对应的 formGroup 对象：\n\n```ts\nexport class DyFormComponent implements OnInit {\n  form: FormGroup;\n  constructor(private fb: FormBuilder) {}\n\n  ngOnInit() {\n    this.form = this.fb.group({\n      username: \'\',\n      password: \'\',\n      area: \'\',\n      gender: \'\'\n    });\n  }\n}\n```\n\n可以看到，要实例化一个 formGroup ，我们需要一个对象：\n\n```ts\n{\n      username: \'\',\n      password: \'\',\n      area: \'\',\n      gender: \'\'\n}\n```\n\n要动态创建表单模板，我们需要这样一个格式：\n\n```ts\nexport interface FormData{\n    name: string;\n    element: string;\n    label: string;\n    value: string;\n    options: {label:string,value:string}[];\n}\nexport type FormDataFormat = FormData[];\nthis.data: FormDataFormat = [\n  {\n    name: \'username\',\n    element: \'input-text\',\n    label: \'用户名\',\n    value: \'老王\'\n  },\n  {\n    name: \'password\',\n    element: \'input-password\',\n    label: \'密码\',\n    value: \'123456\'\n  },\n  {\n    name: \'area\',\n    element: \'select\',\n    label: \'地区\',\n    value: \'100000\',\n    options: [{ label: \'北京\', value: \'100000\' }, { label: \'上海\', value: \'200000\' }]\n  },\n  {\n    name: \'gender\',\n    element: \'radio\',\n    label: \'性别\',\n    value: \'male\',\n    options: [{ label: \'男\', value: \'male\' }, { label: \'女\', value: \'female\' }]\n  }\n];\n```\n\n利用这个数据生成实例化 FormGroup 所需要的参数\n\n```html\ngenerateFormGroupParam() {\n    return this.data.reduce((acc, curr) => {\n      const { name, value } = curr;\n      acc[name] = new FormControl(value);\n      return acc;\n    }, {});\n}\n```\n\n同样的利用 data 来循环出表单模板\n\n```html\n<form [formGroup]=\"dyForm\">\n  <ng-container *ngFor=\"let item of data\">\n    <ng-container [ngSwitch]=\"item.element\">\n      <ng-container *ngSwitchCase=\"\'input-text\'\">\n        <input type=\"text\" [formControlName]=\"item.name\">\n      </ng-container>\n      <ng-container *ngSwitchCase=\"\'input-password\'\">\n        <input type=\"password\" [formControlName]=\"item.name\">\n      </ng-container>\n      <ng-container *ngSwitchCase=\"\'select\'\">\n        <select [formControlName]=\"item.name\">\n          <option *ngFor=\"let option of item.options\" [value]=\"option.value\">{{option.label}}</option>\n        </select>\n      </ng-container>\n      <ng-container *ngSwitchCase=\"\'radio\'\">\n        <ng-container *ngFor=\"let option of item.options\">\n          <input type=\"radio\" [formControlName]=\"item.name\" [value]=\"option.value\">{{option.label}}\n        </ng-container>\n      </ng-container>\n    </ng-container>\n\n  </ng-container>\n</form>\n<pre>{{dyForm.value|json}}</pre>\n```\n\n实例化 FormGroup\n\n```ts\nngOnInit() {\n    this.dyForm = this.fb.group(this.generateFormGroupParam());\n}\n```\n---\n\n**此处缺少一张图片，请联系作者更新**\n\n---\n\n我们将其封装为一个组件：\n\n```ts\nimport { Component, OnInit, Input } from \'@angular/core\';\nimport { FormGroup } from \'@angular/forms\';\n\n@Component({\n  selector: \'app-simple-form\',\n  templateUrl: \'./simple-form.component.html\'\n})\nexport class SimpleFormComponent implements OnInit {\n  @Input() data: FormDataFormat;\n  @Input() group: FormGroup;\n  constructor() {}\n\n  ngOnInit() {}\n}\n\n```\n\nsimple-form.component.html\n\n```html\n<ng-container [formGroup]=\"group\">\n  <ng-container *ngFor=\"let item of data\">\n    <ng-container [ngSwitch]=\"item.element\">\n      <ng-container *ngSwitchCase=\"\'input-text\'\">\n        <input type=\"text\" [formControlName]=\"item.name\">\n      </ng-container>\n      <ng-container *ngSwitchCase=\"\'input-password\'\">\n        <input type=\"password\" [formControlName]=\"item.name\">\n      </ng-container>\n      <ng-container *ngSwitchCase=\"\'select\'\">\n        <select [formControlName]=\"item.name\">\n          <option *ngFor=\"let option of item.options\" [value]=\"option.value\">{{option.label}}</option>\n        </select>\n      </ng-container>\n      <ng-container *ngSwitchCase=\"\'radio\'\">\n        <ng-container *ngFor=\"let option of item.options\">\n          <input type=\"radio\" [formControlName]=\"item.name\" [value]=\"option.value\">{{option.label}}\n        </ng-container>\n      </ng-container>\n    </ng-container>\n  </ng-container>\n</ng-container>\n```\n\n在需要的地方使用\n\n```ts\nimport { Component, OnInit } from \'@angular/core\';\nimport { FormBuilder, FormGroup, FormControl } from \'@angular/forms\';\n\n@Component({\n  selector: \'app-dy-form\',\n  templateUrl: `dy-form.component.html`,\n  styles: []\n})\nexport class DyFormComponent implements OnInit {\n  form: FormGroup;\n  constructor(private fb: FormBuilder) {}\n  data:FormDataFormat = data; // 上面贴的 data 数据\n  ngOnInit() {\n    this.form = this.fb.group(this.generateFormGroupParam());\n  }\n\n  generateFormGroupParam() {\n    return this.data.reduce((acc, curr) => {\n      const { name, value } = curr;\n      acc[name] = new FormControl(value);\n      return acc;\n    }, {});\n  }\n}\n```\n\ndy-form.component.html\n\n```html\n\n<form [formGroup]=\"form\">\n  <app-simple-form [group]=\"form\" [data]=\"data\"></app-simple-form>\n</form>\n<pre>{{form.value|json}}</pre>\n\n```\n\n![2018-07-03下午11_37_381539793742793.png](http://pghicsch6.bkt.clouddn.com/2018-07-03下午11_37_381539793742793.png)\n\n这只是一个雏形，可以根据项目需要进行完善，加入更多表单元素，以及表单验证，以后再也不怕大表单了。\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',2,43),(44,'前端大耍','2018-07-24 11:45:43',NULL,'Angular 创建富文本编辑器','','在创建富文本编辑器之前，首先了解一下如何获取 dom 的引用。\n\n> ViewChild：\n>\n> 在模板中使用模板变量标记元素，然后在 Component 类中使用 @ViewChild 来获取元素的引用。\n\n```ts\nimport {Component, ElementRef, OnInit, ViewChild} from \'@angular/core\';\n\n@Component({\n  selector: \'app-find-element\',\n  template: `\n              <input type=\"text\"\n                     value=\"123\"\n                     #input>\n            `,\n  styles:   [],\n})\nexport class FindElementComponent implements OnInit {\n\n  @ViewChild(\'input\') input: ElementRef<HTMLInputElement>;\n\n  constructor() {\n  }\n\n  ngOnInit() {\n    console.log(\'onInit\', this.input.nativeElement.value); // 123\n    console.log(\'onInit\', this.input.nativeElement.offsetWidth); // 132\n  }\n\n}\n```\n\n> 如果想获取 host 元素，需要在 component 的 constructor 中注入 ElementRef。\n\n```ts\nimport {Component, ElementRef, OnInit, ViewChild} from \'@angular/core\';\n\n@Component({\n  selector: \'app-find-element\',\n  template: `\n              <input type=\"text\"\n                     value=\"123\"\n                     #input>\n            `,\n  styles:   [],\n})\nexport class FindElementComponent implements OnInit {\n\n  @ViewChild(\'input\') input: ElementRef<HTMLInputElement>;\n\n  constructor(private host: ElementRef) {\n\n  }\n\n  ngOnInit() {\n    console.log(this.host.nativeElement);\n    // <app-find-element><input type=\"text\" value=\"123\"></app-find-element>\n  }\n\n}\n```\n\n接下来，就可以创建富文本编辑器了。\n\n```\nnpm i --save @ckeditor/ckeditor5-build-classic\n```\n\n创建一个组件\n\n```ts\nimport {\n  Component,\n  OnInit,\n  ViewChild,\n  ElementRef,\n  AfterViewInit\n} from \'@angular/core\';\n\nimport ClassicEditor from \'@ckeditor/ckeditor5-build-classic\';\n\n@Component({\n  selector: \'app-editor\',\n  template: `\n  <textarea #container>\n    <p>\n      editor works!\n    </p>\n  </textarea>\n  `,\n  styles: []\n})\nexport class EditorComponent implements AfterViewInit {\n  @ViewChild(\'container\') container: ElementRef;\n  constructor() {}\n\n  ngAfterViewInit(): void {\n    const c = this.container.nativeElement;\n    ClassicEditor.create(c\n      .then(editor => {\n        console.log(editor);\n      })\n      .catch(error => {\n        console.error(error);\n      });\n  }\n}\n\n```\n\n看一下成果：\n![2018-07-24下午10_16_211539794193486.png](http://pghicsch6.bkt.clouddn.com/2018-07-24下午10_16_211539794193486.png)\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',2,44),(45,'前端大耍','2018-06-17 23:56:16',NULL,'Angular 创建新项目时报错','','最近使用 ng new 创建新项目时报错了：\n\n```shell\nnpm WARN deprecated istanbul-lib-hook@1.2.1: 1.2.0 should have been a major version bump\nnpm ERR! Unexpected end of JSON input while parsing near \'...b9cf5a53d28616f911894\'\n\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /Users/yang/.npm/_logs/2018-06-13T01_34_37_009Z-debug.log\nPackage install failed, see above.\n```\n\n解决办法：\n\n```shell\nnpm cache clean --force\n```\n\n然后重新运行 ng new 即可。\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',2,45),(46,'前端大耍','2018-05-22 21:48:44',NULL,'Angular 响应式表单校验','','> 动态表单的验证更加简单。\n\n```typescript\n<input\n  [formControl]=\"name\">\n<div *ngIf=\"name.invalid && (name.dirty||name.touched)\">\n  <div *ngIf=\"name.errors.required\">\n    name is required\n  </div>\n  <div *ngIf=\"name.errors.minlength\">\n    minlength is 4\n  </div>\n  <div *ngIf=\"name.errors.noEmpty\">\n    name can not be empty string\n  </div>\n</div>\n<div>{{name.errors | json}}</div>\n```\n\n> 模板很简洁，只需要给 input 添加一个 `[formControl]=\"name\"` 。这个 name 并不是固定的，你可以自己取名，但要和组件类里的属性名相同。\n\n```typescript\nexport class DyUserInputComponent implements OnInit {\n  name: FormControl;\n\n  constructor() {\n  }\n    \n  ngOnInit(): void {\n    this.name = new FormControl(\n      \'hello\', // 初始值\n      [Validators.required, Validators.minLength(4)], // 同步校验器\n      [] // 异步校验器\n    );\n  }\n}\n```\n\n> 这样就完成了。因为 formControl 在 ReactiveFormsModule 中，所以需要在模块中引入 ReactiveFormsModule。\n>\n> 同样的，当在 input 中输入四个空格时，发现校验居然通过了。很明显我们需要自定义一个校验规则，保证输入不能为空格。这非常简单。你只需要定义一个函数：\n\n```typescript\nfunction noEmpty(c: AbstractControl) {\n  const value = c.value;\n  return value && value.trim() !== \'\' ? null : {\'noEmpty\': true};\n}\n```\n\n> 这个函数定义要遵循一定的规则：\n>\n> 一。函数接收一个类型为 AbstractContrl 的参数。\n>\n> 二。通过参数的 value 属性即可以拿到需要校验的输入。\n>\n> 三。自定义判断逻辑。但要保证在校验通过时返回null，不通过时返回一个对象。\n>\n> 四。如果返回了对象，对象的 key 应和校验器名称对应，value 可以为任意值，只要你觉得方便使用就行。\n>\n> 现在我们把它加入到 input 的校验规则中：\n\n```typescript\n...\nngOnInit(): void {\n    this.name = new FormControl(\n      \'hello\', // 初始值\n      [Validators.required, Validators.minLength(4),noEmpty], // 同步校验器\n      [] // 异步校验器\n    );\n}\n...\n```\n\n> 现在输入四个空格：\n\n```\n{ \"noEmpty\": true }\n```\n\n> 可以发现，比模板表单的自定义校验要简单的多，不需要写 Directive,不需要定义 Providers。如果有问题，欢迎进群讨论。\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',2,46),(47,'前端大耍','2018-05-01 14:37:27',NULL,'Angular 开发最佳实践 — 不应该做的事','','## 重复代码\n\n```js\n@Component({\n  selector: \'app-some-component-with-form\',\n  template: `\n        <div [formGroup]=\"form\">\n          <div class=\"form-control\">\n            <label>First Name</label>\n            <input type=\"text\" formControlName=\"firstName\" />\n          </div>\n          \n          <div class=\"form-control\">\n            <label>Last Name</label>\n            <input type=\"text\" formControlName=\"lastName\" />\n          </div>\n          \n          <div class=\"form-control\">\n            <label>Age</label>\n            <input type=\"text\" formControlName=\"age\" />\n          </div>\n        </div>\n    `\n})\nexport class SomeComponentWithForm {\n  \n  public form: FormGroup;\n  \n  constructor(private formBuilder: FormBuilder){\n    this.form = formBuilder.group({\n      firstName: [\'\', Validators.required],\n      lastName: [\'\', Validators.required],\n      age: [\'\', Validators.max(120)],      \n    })\n  }\n  \n}\n```\n\n> 这种情况你应该将其封装为子组件。\n\n```js\n// 子组件\n@Component({\n  selector: \'app-single-control-component\',\n  template: `\n        <div class=\"form-control\">\n          <label>{{ label }}</label>\n          <input type=\"text\" [formControl]=\"control\" />\n        </div>\n      `\n})\nexport class SingleControlComponent{\n  @Input() control: AbstractControl \n  @Input() label: string;\n}\n\n// 父组件\n@Component({\n  selector: \'app-some-component-with-form\',\n  template: `\n        <div>\n  			<app-single-control-component \n				[control]=\"form.controls[\'firstName\']\"\n				[label]=\"\'First Name\'\" />\n              <app-single-control-component \n                [control]=\"form.controls[\'lastName\']\" \n                [label]=\"\'Last Name\'\" />\n\n              <app-single-control-component \n                [control]=\"form.controls[\'age\']\" \n                [label]=\"\'Age\'\" />\n         </div>\n    `\n})\nexport class SomeComponentWithForm {\n  \n  public form: FormGroup;\n  \n  constructor(private formBuilder: FormBuilder){\n    this.form = formBuilder.group({\n      firstName: [\'\', Validators.required],\n      lastName: [\'\', Validators.required],\n      age: [\'\', Validators.max(120)],      \n    })\n  }\n  \n}\n```\n\n> 如果情况就是这么简单，可以通过 ngFor 把它循环出来。\n\n\n\n## 使用 toPromise（）\n\n使用 toPromise 的劣势：\n\n1. 添加非必要的操作符。你没有必要将一个 Observable 转换为一个 Promise，你可以直接使用它。\n2. 失去了很多 RxJS 提供的强大功能。RxJS 大量的操作符让你可以自如的操作数据流，而转换为 Promise 之后，大部分功能都丢失了，你只能使用 Promise 提供的少得可怜的功能。\n\n\n\n## 不经常使用RxJS\n\nRxJS是一个优秀的工具，你应该使用它来操作数据，事件，以及应用中的各种状态。尽快掌握它。\n\n\n\n## 没有给数据定义interface\n\n比如说从服务器端请求回来的数据，一定要定义 interface。以后操作的时候，typescript 会给你精准的提示，而当你写错时，也会及时提醒你。\n\n```js\n// server response\n{\n    success: true,\n    code: 200,\n    users:[\n            {name:\'aaa\',age:20,favo:[\'singing\',\'writing\']}\n    ]\n}\n\n// interface\n\nexport interface UsersResponse{\n    success: boolean;\n    code: number;\n    users: User[]\n}\nexport interface User{\n    name:string;\n    age: number;\n    favo:Favo[]\n}\nexport type Favo = \'singing\'|\'writing\';\n\n// 使用时如果写错的话\nuserResponse.username // error! 没有 username 这个属性\nuserResponse.favo = \'singing\' // error! favo 是一个数组类型，不能赋予 string 类型的值\nuserResponse.favo[0] = \'swimming\' // error! favo 只可能是 \'singing\' 或者 \'writing\'\n```\n\n## 在Component 中修改数据\n\n下面是一个例子\n\n```js\ninterface Movie {\n  id: number;\n  title: string;\n}\n\n@Component({\n  selector: \'app-user-form\',\n  template: `\n	<form [formGroup]=\"form\">\n		<input type=\"text\" formControlName=\"firstName\" >\n		<input type=\"text\" formControlName=\"lastName\" >\n		<input type=\"number\" formControlName=\"age\" >\n		<select formControlName=\"favoriteMovies\" multiple>\n			<option *ngFor=\"let movie of movies\" [value]=\"movie\">\n				{{movie.title}}\n			</option>\n		</select>\n\n\n\n	</form>\n  ` \n})\nexport class SomeComponentWithForm {\n\n  public form: FormGroup;\n  public movies: Array<Movie>\n\n  constructor(private formBuilder: FormBuilder){\n    this.form = formBuilder.group({\n      firstName: [\'\', Validators.required],\n      lastName: [\'\', Validators.required],\n      age: [\'\', Validators.max(120)],\n      favoriteMovies: [[]],  /*喜爱的电影，多选*/\n    });\n  }\n  \n  public onSubmit(values){ \n    /*\n     \'values\' 是表单要提交的值，包含 form 内的所有字段。但是假设服务器端要求喜欢的电影是\n      一个包含电影 id 的数组，而不是一个电影的数组，那我们需要对数据进行一些预处理。\n    */\n    values.favouriteMovies = values.favouriteMovies.map((movie: Movie) => movie.id);\n    /* 处理过后，可以通过 service 将数据提交给服务器了。*/ \n  }\n}\n```\n\n目前，这样的方式并没有带来什么问题。仅仅在提交数据之前做了一点点修改数据的工作。但是想象一下，如果待提交的数据和很多其他因素有关联，或者字段在数据中所处层次较深，而数据的结构又较复杂时，这段代码会立刻变得臃肿。一个好的实践是下面这样做：\n\n```js\n\ninterface Movie {\n  id: number;\n  title: string;\n}\n\ninterface User {\n  firstName: string;\n  lastName: string;\n  age: number;\n  favoriteMovies: Array<Movie | number>; \n  /*\n  这里喜爱的电影是一个数组，\n  可以是 movie类型，\n  也可以是number类型（id)。\n  但是，不能既有 movie 又有 number。\n  */\n}\n\nclass UserModel implements User {\n  firstName: string;\n  lastName: string;\n  age: number;\n  favoriteMovies: Array<Movie | number>;\n\n  constructor(source: User){\n    this.firstName = source.firstName;\n    this.lastName = source.lastName;\n    this.age = source.age;\n    const type = typeof source.favoriteMovies[0];\n      if( type!=null &&  type!==\'number\'){\n           this.favoriteMovies =\n               source.favoriteMovies\n               .map((movie: Movie) => movie.id);\n      }\n    /*\n    我们将修改数据的逻辑分离到一个单独的 class 里，\n    这个 class 同时也代表了 User 的数据模型。\n    Componet 里面会变得简洁清晰\n    */\n  }\n}\n```\n\n修改后的 component\n\n```js\npublic onSubmit(values: User){\n    let user: UserModel = new UserModel(values);\n}\n```\n\n> 原来我们只有一个 interface User，现在增加了一个 interface UserModel。但是代码更加清晰。\n\n\n\n## 不用或者滥用 Pipes\n\n下面是一个例子\n\n```js\n// 不好的做法\n@Component({\n  selector: \'some-component\',\n  template: `\n    <div>\n      <dropdown-component [options]=\"weightUnits\" />\n      <dropdown-component [options]=\"slashedWeightUnits\"/>\n\n    </div>\n`\n})\nexport class SomeComponent {\n  public weightUnits = [{value: 1, label: \'kg\'}, {value: 2, label: \'oz\'}];\n  public slashedWeightUnits = [{value: 1, label: \'/kg\'}, {value: 2, label: \'/oz\'}];\n}\n```\n\n较好的做法\n\n```js\n\n@Pipe({\n  name: \'slashed\'\n})\nexport class Slashed implements PipeTransform {\n  transform(value){\n    return value.map(item => {\n      return {\n        label: \'/\' + item.label,\n        value: item.value\n      };\n    })\n  }\n}\n\n\n@Component({\n  selector: \'some-component\',\n  template: `\n    <div>\n      <dropdown-component [options]=\"weightUnits\" />\n      <dropdown-component [options]=\"(weightUnits | slashed)\" />\n    </div>\n`\n})\nexport class SomeComponent {\n  public weightUnits = [{value: 1, label: \'kg\'}, {value: 2, label: \'oz\'}];\n}\n```\n\n但是，想象一下，如果你的应用中有很多需要转换的东西，但是这些东西的转换通常很少用到，可能只用到一次。那么需要为每一个转换逻辑编写 Pipe 吗？那样会出现一大堆的 Pipe。更灵活的解决办法：\n\n\n\n```js\n\n@Pipe({\n  name: \'map\'\n})\nexport class Mapping implements PipeTransform {\n  /* \n  this will be a universal pipe for array mappings. You may add more \n  type checkings and runtime checkings to make sure it works correctly everywhere\n  */\n   /*\n   	这个通用pipe，接收一个转换函数作为参数。\n   	因为通用，所以 value 的类型也可能是多种多样的，我们只能使用 any\n   	在实际使用的时候，要注意检查参数类型是否正确\n   */\n  transform(value, mappingFunction: Function){\n    return mappingFunction(value)\n  }\n}\n\n\n@Component({\n  selector: \'some-component\',\n  template: `\n    <div>\n      <dropdown-component [options]=\"weightUnits\" />\n      <dropdown-component [options]=\"(weightUnits | map : slashed)\" />\n    </div>\n`\n})\nexport class SomeComponent {\n  public weightUnits = [{value: 1, label: \'kg\'}, {value: 2, label: \'oz\'}];\n  \n  /* \n  我们把转换逻辑定义在组件内部\n  需要注意的是，转换函数必须是 pure function\n  不能有任何副作用\n  不能使用 this\n  */\n  public slashed(units){\n    return units.map(unit => {\n      return {\n        label: \'/\' + unit.label,\n        value: unit.value\n      };\n    });\n  }\n}\n```\n\n\n\n> 原文地址：https://codeburst.io/angular-best-practices-4bed7ae1d0b7',1,0,0,'[\"angular\"]',2,47),(48,'前端大耍','2018-05-01 20:09:03',NULL,'Angular 最佳实践—应该做的事','','## tsconfig.json 设置 \'noImplicitAny\':true\n\n设置以后，当代码中的变量或者函数的参数未设置类型时，typescript 会报错。严格的类型检查让你的代码不易出错，typescript 为你提供了这样的功能，应该好好的利用它。\n\n\n\n## 组件\n\n组件是 Angular 的核心之一，如果可以把他们很好的组织起来，提升他们的可复用度，那么开发工作的一半就算完成了。\n\n###  创建一个或者多个基本组件类\n\n如果你的很多组件中都用到了相同的数据，或者处理逻辑，而又不想在每个组件中重复去定义这些变量和方法，那基本组件类就派上用场了。\n\n\n\n```js\nenum Status {\n  Unread = 0,\n  Read = 1\n}\n\nabstract class AbstractBaseComponent {\n  status = Status;\n}\n\n@Component({\n  selector: \'component-with-enum\',\n  template: `\n    <div *ngFor=\"notification in notifications\" \n        [ngClass]=\"{\'unread\': notification.status == statuses.Unread}\">\n		<!-- status 这个属性是从父类中继承下来的 -->\n      {{ notification.text }}\n    </div>\n`\n})\nclass NotificationComponent extends AbstractBaseComponent {\n  notifications = [\n    {text: \'Hello!\', status: Statuses.Unread},\n    {text: \'Angular is awesome!\', status: Statuses.Read}\n  ];\n}\n```\n\n另一种情况是当你构建应用时，很多页面都会用到表单。一个典型的带表单的组件是这样的：\n\n```js\n@Component({\n  selector: \'component-with-form\',\n  template: `...`\n})\nclass ComponentWithForm  {\n  /* formGroup 对象*/\n  form: FormGroup;\n /* 表单是否已经提交 */\n  submitted: boolean = false; \n  \n  /* 重置表单 */\n  resetForm() {\n    this.form.reset();\n  }\n  /* 提交表单 */\n  onSubmit() {\n    this.submitted = true;\n    if (!this.form.valid) {\n      return;\n    }\n    /* 提交表单的逻辑 */\n    // ...\n  }\n}\n```\n\n我们可以把这个典型的逻辑抽离出来：\n\n```js\n\nabstract class AbstractFormComponent {\n  form: FormGroup;\n  submitted: boolean = false;\n  resetForm() {\n    this.form.reset();\n  }\n\n  onSubmit() {\n    this.submitted = true;\n    if (!this.form.valid) {\n      return;\n    }\n  }\n}\n```\n\n所有包含表单的组件都可以继承它，让自己内部更简洁：\n\n```js\n\n@Component({\n  selector: \'component-with-form\',\n  template: `...`\n})\nclass ComponentWithForm extends AbstractFormComponent {\n  \n  onSubmit() {\n    super.onSubmit();\n    /* 组件内部逻辑 */\n  }\n}\n```\n\n### 容器组件\n\n容器组件专注于处理数据，它可以帮助你提取出更多可复用的 UI Component。\n\n\n\n```js\n@Component({\n    selector:\'app-user\',\n    template: `\n		<div>\n			<input [value]=\"user.name\">\n			<input [value]=\"user.age\">\n		</div>\n	`\n})\nexport class UserComponent implements Oninit{\n    user;\n    constructor(private readonly userService:Userservice){}\n    \n    onInit(){ \n    	this.user = this.userService.getUser();\n    }\n}\n```\n\n这个组件没有什么问题。但是如果我们本地已经存在一个user 的数组，希望通过这个组件渲染出来，发现不行。因为 组件是通过在初始化时，调用 userService 的方式来获取数据的。这就值得我们思考：组件到底是用来做什么的？我认为组件可以分为两种：一种负责处理数据逻辑，一种负责UI 展示。\n\n 至少 UserComponet 目前看起来没有处在正确的位置上，它既负责数据处理，又负责 UI 展示，结果就是不能被复用。\n\n我们可以通过 容器组件 来改造它：\n\n```js\n@Component({\n  selector: \'user-container-component\',\n  template: `<app-user-component [user]=\"user\"></app-user-component>`\n})\n/* 容器组件，负责处理数据 */\nclass UserContainerComponent {\n  \n  constructor(userService: UserService) {}\n  ngOnInit(){\n    this.userService.getUser().subscribe(res => this.user = user);\n  }\n  \n}\n/* 改造后的 负责 UI 展现的 UserComponent */\n@Component({\n  selector: \'app-user-component\',\n  template: `\n		<div>\n			<input [value]=\"user.name\">\n			<input [value]=\"user.age\">\n		</div>\n	`\n})\nclass UserComponent {\n  @Input() user;\n}\n```\n\n现在，只要有 user 数据，我们就可以使用 UserComponent 展示出来，它可以被复用了。\n\n> 小经验： 当使用 ngFor 指令时，可以考虑将循环的代码分离出来，封装为一个小组件。\n\n```js\n\n<-- bad -->\n<div *ngFor=\"let user of users\">\n  <h3 class=\"user_wrapper\">{{user.name}}</h3>\n  <span class=\"user_info\">{{ user.age }}</span>\n  <span class=\"user_info\">{{ user.dateOfBirth | date : \'YYYY-MM-DD\' }}</span>\n</div>\n\n<-- good -->\n\n<user-detail-component *ngFor=\"let user of users\" [user]=\"user\"></user-detail-component>\n```\n\n\n\n## Services\n\n\n\n### 为 API 调用创建基础的 service 类\n\n```js\n\nabstract class BaseService {\n\n  	protected baseUrl: \'http://your.api.domain\';\n\n    protected getFullUrl(url:string){\n        return this.baseUrl + url;\n    }\n    protected handleResponse(response:HttpResponse){\n        // do something\n        return Observable.of(handledResponse);\n    }\n    protected handleError(error){\n        // do something with error\n        return Observable.of(error);\n    }\n}\n```\n\n业务中的 UserService \n\n```js\n\n@Injectable()\nclass UserService extends BaseService {\n\n  private relativeUrl: string = \'/users/\';\n  constructor(private readonly http:HttpClient){}\n  public getAllUsers(): Observable<User[]> {\n    const fullUrl = this.getFullUrl(this.relativeurl);\n    return this.http.get(fullUrl)\n      		  .pipe(\n      			 map(response=>this.handleResponse(response))\n      			 catchError(error=>this.handleError)\n      			)\n  }\n}\n\n```\n\n一方面，公共的逻辑被抽离出来得以复用，另一方面，你可以随时在 BaseService 中扩展功能，所有的子类都会立刻获得新增的功能。相比在每个 service 中去做同一种修改效率要高的多。\n\n### 创建工具 service 类\n\n业务中对数据的处理，会有很多共同的逻辑，将这些逻辑代码抽离到 UtilsService 中，让它们得以复用。\n\n\n\n### 使用 TypeScript 的 Enum 来管理你的 Api\n\n```js\nenum UserApiUrls {\n  getAllUsers = \'users/getAll\',\n  getActiveUsers = \'users/getActive\',\n  deleteUser = \'users/delete\'\n}\n```\n\n为什么不直接使用对象？ 因为对象的属性值是可以修改的。我可以在应用的任何地方修改 getAllUsers 的地址，这并不合理。\n\n为什么不使用 interface ？因为 interface 只能作为类型约束来使用，它的任何属性都是类型，不是一个实际的值，在编译后都会消失。\n\n为什么不使用 class？实际上可以使用 class，将所有的 url 定义为 class 的 static 属性，但是，这难道有 enum 用起来方便吗？\n\n\n\n###  在合适的地方缓存http请求返回的数据\n\n对于某些基本不可能发生改变的数据，我们没必要每次用到的时候去请求。第一次请求后，缓存起来就可以了。建议在 http 中间件中处理。\n\n## Templates\n\n### 不要在模板中写大量的逻辑代码，应该抽离到组件的方法中。\n\n一个不好的例子：\n\n```js\n\n@Component({\n  selector: \'component-with-form\',\n  template: `\n        <div [formGroup]=\"form\"\n        [ngClass]=\"{\n        \'has-error\': (form.controls[\'firstName\'].invalid && (submitted || form.controls[\'firstName\'].touched))\n        }\">\n        <input type=\"text\" formControlName=\"firstName\"/>\n        </div>\n    `\n})\nclass SomeComponentWithForm {\n  form: FormGroup;\n  submitted: boolean = false;\n\n  constructor(private formBuilder: FormBuilder) {\n    this.form = formBuilder.group({\n      firstName: [\'\', Validators.required],\n      lastName: [\'\', Validators.required]\n    });\n  }\n}\n```\n\n将模板中的逻辑抽离到 component 中\n\n```Js\n\n@Component({\n  selector: \'component-with-form\',\n  template: `\n        <div [formGroup]=\"form\" [ngClass]=\"{\'has-error\': hasFieldError(\'firstName\')}\">\n            <input type=\"text\" formControlName=\"firstName\"/>\n        </div>\n    `\n})\nclass SomeComponentWithForm {\n  form: FormGroup;\n  submitted: boolean = false;\n\n  constructor(private formBuilder: FormBuilder) {\n    this.form = formBuilder.group({\n      firstName: [\'\', Validators.required],\n      lastName: [\'\', Validators.required]\n    });\n  }\n  \n  hasFieldError(fieldName: string): boolean {\n    return this.form.controls[fieldName].invalid &&\n        (this.submitted || this.form.controls[fieldName].touched);\n  }\n\n}\n```\n\n> 总之，我们所说的所有最佳实践，都是为了提升代码的复用性，结构的清晰度。说到底是提升项目的可维护性，可扩展性。\n\n> 原文地址：https://codeburst.io/angular-bad-practices-eab0e594ce92',1,0,0,'[\"angular\"]',2,48),(49,'前端大耍','2018-05-02 22:49:44',NULL,'Angular 的数据管理框架 Ngxs','','> 相信用过 redux 和 ngrx 的人都有体会，一大堆的action和reducer为项目开发和维护增加了不少难度。Angular社区为了解决这个问题，推出了新一代数据管理框架 Ngxs。文末有传送门。\n\n> Ngxs 是集 redux 的思路，结合 RxJS 的 Observable，以及Angular 的依赖注入，TypeScript的强类型，面向对象思想于一身的牛叉框架。看看它的出现改变了什么。\n\n- 消灭了大量的 Effect。\n- 消灭了大量的 Reducer。\n- 消灭了大量的 Selector。\n- 完全面向对象。\n- 可以利用 angular 的依赖注入。\n\n> 看个例子：\n\n```js\n\n\n// users.action.ts\nexport class User{\n    constructor(public name:string,public age:number){}\n}\nexport class AddUser{\n    static readonly type = \'[app] add user\';\n	constructor(public user: User){}\n}\n\n// users.state.ts\nexport interface UsersStateModel{\n    users:User[]\n}\n@State<UsersStateModel>({\n    name:\'users\',\n    defaults:{\n        users:[]\n    }\n})\nexport class UsersState{\n    @Action(AddUser)\n    addUser(context:StateContext<UsersStateModel>,action:AddUser){\n        const {user} = action;\n        const state = context.getState();\n        context.patchState({\n            users: [...state.users,user]\n        })\n    }\n}\n\n// users.component.ts\n@Component({\n    selector:\'app-users\',\n    template: `<button (click)=\"addUser()\"></button>`\n})\nexport class UsersComponent{\n    constructor(private store: Store){}\n    addUser(){\n        const user = new User(\'Mike\',18);\n        const action = new AddUser(user);\n        this.store.dispatch(action);\n    }\n}\n```\n\n\n\n> 是不是简单清晰？ 来分析一下它是如何做到的。\n>\n> 首先，如何去掉 Reducer?\n>\n> 关键在UsersState 的 decorator 上。 @State。@State 接收的参数是一个对象，其中包括 name 字段，这个字段是必须被赋值并且不可重复的。UsersState 包含的 State 将被包含在全局State的 name 属性中。\n>\n> reducer中大量的switch case 也不见了。因为每一个 Action 都通过 @Action decorator 与类中的方法建立了对应关系。只要Action被触发，就会调用对应的方法。\n>\n> 其次，如何消灭大量的 Effect ？\n>\n> 副作用在大型应用中非常复杂，一个action的触发，会导致连锁反应。所以，NGRX 使用Effect来实现这种Action之间的关联。但是代码越来越多，维护这些Effect的难度也越来越大。\n\n\n\n> Ngxs 采用简洁明了的方式来实现异步Action。\n>\n> 下面是个例子：\n\n```js\n// users.state.ts\n\nexport class UsersState{\n    \n    constructor(private usersService:UsersService){}\n    @Action(AddUser)\n    addUser(context:StateContext<UsersStateModel>,action:AddUser){\n        const {user} = action;\n        // 注意我们返回了这个 Observable\n        return this.usersService.addUser(user).pipe(\n            tap(user => {\n                const state = context.getState();\n                context.patchState({\n                    users:[...state.users,user]\n                })\n            })\n        )\n    }\n}\n\n// users.service.ts\nclass UsersService {\n    constructor(private http: HttpClient){}\n    addUser(user:User):Observable<User>{\n        return this.http.post(\'...\')\n    }\n}\n```\n\n> Ngxs 采用简单明了的方式来实现副作用。\n\n```js\n\n// users.state.ts\n\nexport class GetUsers(){\n    static readonly type = \'[app] get users\'\n}\nexport class UsersState{\n  constructor(private usersService:UsersService){}\n  @Action(AddUser)\n  addUser(context: StateContext<UsersStateModel>, action: AddUser) {\n    return this.userService.add(action.user).pipe(\n      // 发起一个新的Action，和Effect一样的效果\n      map(() => context.dispatch(new GetUsers()))\n    );\n  }\n  @Action(GetUsers)\n    getUsers(ctx,action){\n        // 注意，一定要return 这个 Observable, Ngxs才可以订阅它。\n        // 别忘了，Observable 是惰性的，只有被订阅后才会执行。\n        return this.usersService.getUsers().pipe(\n        	tap(users=>ctx.patchState([users]))\n        )\n    }\n}\n// users.service.ts\nclass UsersService {\n    constructor(private http: HttpClient){}\n    getUsers():Observable<User[]>{\n        return this.http.get<User[]>(...);\n    }\n}\n```\n\n\n\n> 再来看一下组件中如何消灭大量的 subscribe 和 select\n\n```js\nexport class UsersComponent{\n    // 使用 @Select ，你可以传入State的class，它会自动帮你选择class对应的State\n    // 这里 users$ 就是 UsersState 内部保存的 state，记住它是一个Observable\n    @Select(UsersState) usersState$:Observable<UsersStateModel>;\n    // 也可以传入一个函数\n    @Select(state => state.users) usersState$:Observable<UsersStateModel>;\n    // 也可以不传，只要被装饰的属性名称与 StateClass 的 name 属性一致（除了末尾的$符）\n    @Select() users$:Observable<UsersStateModel>;\n    \n    constructor(private store:Store){}\n    \n}\n```\n\n> 这样就省掉了大量的 Ngrx 中的 subscribe 和 select 代码，如果你用过的话就会明白。\n>\n> 不过上面的 Select 有个问题，选中的是 UsersState 中保存的 整个State 。它的结构是：\n\n```js\ninterface UsersStateModel{\n    users:User[]\n}\n```\n\n> 我们如果想直接取 users 这个数组怎么办？ 使用 Ngxs 提供的Selector，它是定义在 UsersState 中的。\n\n```js\n// users.state.ts\nexport class UsersState{\n  constructor(private usersService:UsersService){}\n  \n  // 就这么简单\n  @Selector()\n  static users(state:UsersStateModel){\n      return state.users;\n  }\n}\n\n// users.component.ts\nexport class UsersComponent{\n    // 注意这里，知道为什么是静态方法了吧。\n    @Select(UsersState.users) \n    users$:Observable<User[]>;//--> 我们的到的数据是类型是User数组了\n}\n\n```\n\n> 最后将一下如何在组件中dispatch 一个action\n\n```js\n@Component({\n    selector:\'app-users\',\n    template: `<button (click)=\"getUsers()\">getUsers</button>`\n})\nclass UsersComponent{\n    constructor(private store:Store){}\n    \n    getUsers(){\n        this.store.dispatch(new GetUsers());\n    }\n}\n```\n\n> 是不是很面向对象？代码以后维护起来应该很简单了。\n\n官方文档： https://ngxs.gitbook.io/ngxs/getting-started\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',2,49),(50,'前端大耍','2018-04-11 10:40:18',NULL,'Angular 应用实现 page-loading 效果','','> 如果在angular中实现了懒加载，那么在用户点击链接，到页面显示出来，是需要一小段时间来加载模块的。同样，在用户点击页面获取数据的过程中，如果网络较慢，页面也需要一段时间之后，才能显示出返回的数据。在这个时间段中，用户可能认为是网页停止响应了，于是再次点击。再次点击会引发很多问题，为了防止这样的情况发生，我们可以简单的告诉用户：页面正在加载，请稍后。那么，如何实现呢？\n\n> 首先，需要一个组件，来告诉用户，页面正在加载。\n\n```js\n// page-loading.component.ts\n\nComponent({\n    selector:\'app-page-loading\',\n    template: `\n    	<p>\n    		页面正在加载...\n    	</p>\n    `,\n    styles:[\n    `:host{\n            display: flex;\n            position: fixed;\n            width: 100%;\n            height: 100%;\n            justify-content: center;\n            align-items: center;\n            background: rgba(0,0,0,.3);\n            z-index: 999;\n        }`\n    ]\n})\nexport class PageLoadingComponent {}\n```\n\n>可以看出，这就是一个简单的，把窗口全部遮住的遮罩层，中间有一行文字，告诉用户页面正在加载。此时，用户无法点击页面了（用户也许会很郁闷，因为他还想不停的点下去，如何提升用户体验是另一个话题）。你可以把提示文字换成任何想展现的东西，比如一个图片，logo，动画等等。\n\n\n\n> 其次，这个东西放在哪里呢？如果要在整个应用中可用，则必须放在根组件中。\n\n\n\n```html\n// app.component.html\n\n<app-page-loading></app-page-loading>\n```\n\n>打开页面后，你会发现它遮住了整个窗口，无法进行任何操作。我们是希望它在路由跳转的那短暂的页面空白期出现，而不是一直存在。\n\n```html\n<app-page-loading *ngIf=\"isLoading$|async\"></app-page-loading>\n```\n\n```js\n// app.component.ts\n\n//...\nexport class AppComponent {\n    isLoading$:Observable<boolean>;\n\n	constructor(private pageLoadingService: PageLoadingService){}\n    ngOnInit(){\n        this.isLoading$ = this.pageLoadingService.loading$;\n    }\n}\n```\n\n>是的，我们需要一个service，由它来传递页面是否正在跳转的状态。注意，这个状态是一个包含着布尔值的Observable,所以我们在模板中需要使用 async pipe来订阅并且获取它的值。下面来实现这个service：\n\n```js\nimport {Injectable} from \'@angular/core\';\nimport {NavigationCancel, NavigationEnd, NavigationError, NavigationStart, Router} from \'@angular/router\';\nimport \'rxjs/add/operator/do\';\nimport {BehaviorSubject} from \'rxjs/BehaviorSubject\';\n\n@Injectable()\nexport class LoadingService {\n\n  loading$ = new BehaviorSubject<boolean>(false);\n\n  constructor(private readonly router: Router) {\n    this.router.events.subscribe(\n      event => this.navigationHandler(event),\n    );\n  }\n\n  loading() {\n    this.loading$.next(true);\n  }\n\n  loaded() {\n    this.loading$.next(false);\n  }\n\n\n  navigationHandler(event: any) {\n    if (event instanceof NavigationStart) {\n      this.loading();\n      return;\n    }\n    if (\n      event instanceof NavigationEnd ||\n      event instanceof NavigationCancel ||\n      event instanceof NavigationError\n    ) {\n      this.loaded();\n      return;\n    }\n  }\n\n\n}\n\n```\n\n>为了防止写错，我把整个文件copy过来了，这可能有点多，但是仍然很清晰。\n\n>听着，要使他正常工作，别忘了把他加入到根模块的providers数组中。\n\n>不要试图在url中切换地址栏来查看效果，那是页面重新加载，而不是懒加载。一定要通过routerLink来切换页面，才能看到效果。\n\n```html\n// app.component.html\n<button  routerLink=\"/user\">user</button>\n<button  routerLink=\"/home\">home</button>\n```\n\n\n\n```js\n// app-routing.module.ts\nconst routes:Routes = [\n    {\n        path:\'home\',\n        loadChildren:\'app/home/home.module#HomeModule\'},\n    {\n         path: \'user\',\n         loadChildren: \'app/user/user.module#UserModule\'\n    },\n]\n```\n\n\n\n>可能，因为你的代码都在本地，所以遮罩层的存在时间很短，会一闪而过。你可以试着打开开发者工具，在 Network 面板找到 Online，点击右边的向下的小箭头，选择 slow 3G 网络模式，查看效果。\n\n\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',2,50),(51,'前端大耍','2018-03-18 18:40:50',NULL,'angular与websocket---寻找更加便捷的工具','','> 前面两篇文章掌握的话，我们已经可以轻松的在应用中使用websocket了。但是，angular庞大的社区早就为我们准备好了便利的工具，直接使用即可。进入你的angular项目，安装它。\n\n```\nnpm install ng-socket-io\n```\n\n> 在 root module 或者 core module 中引入。\n\n```js\nimport {BrowserModule} from \'@angular/platform-browser\';\nimport {NgModule} from \'@angular/core\';\n\n\nimport {AppComponent} from \'./app.component\';\nimport {SocketIoService} from \'./socket-io.service\';\nimport {SocketIoConfig, SocketIoModule} from \'ng-socket-io\';\n\nconst config: SocketIoConfig = {url: \'http://localhost:8080\', options: {}};\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    SocketIoModule.forRoot(config)\n  ],\n  providers: [SocketIoService],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {\n}\n\n```\n\n> 创建 socket-io.service.ts 文件。\n\n```\nng g s socket-io -m app\n```\n\n> 代码\n\n```js\nimport {Injectable} from \'@angular/core\';\n// 请注意，不要引错了\nimport {Socket} from \'ng-socket-io\';\nimport {Observable} from \'rxjs/Observable\';\n\n@Injectable()\nexport class SocketIoService {\n\n  message$: Observable<string>;\n\n  constructor(\n    private socket: Socket\n  ) {\n    this.message$ =\n      this.socket\n        .fromEvent(\'serverMessage\');\n  }\n\n  sendMessage(msg: string) {\n    this.socket\n      .emit(\'clientMessage\', msg);\n  }\n}\n\n```\n\n> 在 组件中使用\n\n```js\nimport {Component, OnInit} from \'@angular/core\';\nimport {SocketIoService} from \'./socket-io.service\';\n\n@Component({\n  selector: \'app-root\',\n  template: `\n    <ul>\n      <li *ngFor=\"let msg of messages\">{{msg}}</li>\n    </ul>\n\n    <p *ngIf=\"error\">{{error | json}}</p>\n    <p *ngIf=\"completed\">completed!</p>\n\n\n    <input type=\"text\"\n           #message>\n    <button (click)=\"send(message.value);message.value=\'\';\">send</button>\n  `,\n  styleUrls: [\'./app.component.css\']\n})\nexport class AppComponent implements OnInit {\n  messages = [];\n  error: any;\n  completed = false;\n\n  constructor(private ioService: SocketIoService) {\n  }\n\n  ngOnInit(): void {\n    this.ioService.message$.subscribe(\n      msg => {\n        console.log(msg);\n        this.messages.push(msg);\n      }\n    );\n  }\n\n  send(message: string) {\n    this.ioService.sendMessage(message);\n  }\n}\n```\n\n> 总结一下，以后再也不用为websocket发愁了。\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',2,51),(52,'前端大耍','2018-04-09 20:42:10',NULL,'Angular应用打包后查看类库体积','','> 在打包angular应用后，发现体积较大，但是又不知道是哪个类库导致的。本文介绍一种简单有效的方式，让你一目了然的看到各类库文件在打包文件中的体积。\n\n\n> 首先，安装webpack的一个工具：\n\n```\nnpm install webpack-bundle-analyzer --save-dev\n```\n\n> 配置package.json 脚本, 假设你的打包目录是 dist ，生成的 stats.json 会放置在打包目录下。\n\n```js\n\"scripts\":{\n    \"size\":\"webpack-bundle-analyzer dist/stats.json\"\n}\n```\n\n> 打包项目\n\n```js\nng build --prod --stats-json\n```\n\n> 查看效果\n\n```\nnpm run size\n```\n\n![2018-04-25下午3_17_581539794521271.png](http://pghicsch6.bkt.clouddn.com/2018-04-25下午3_17_581539794521271.png)\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',2,52),(53,'前端大耍','2018-05-27 19:05:39',NULL,'Angular ControlValueAccessor','','表单是 Angular 的一大亮点。但是有时候，我们的表单需要获取一些自定义组件或第三方组件的值。这些组件不是一个正常的 form 元素，（不是 input , select等标准的表单元素),但是它们确实会有值。怎么才能将这些组件的值也通过 Angular 的表单管理起来呢？\n\n举个例子，说下使用场景。我们的表单中包含了一个自定义组件 <app-button-group>，\n\n它用来选择用户的性别。我希望在点击按钮时，将相应的值同步到 form.value 中去。\n\n看看我们的自定义组件：\n\n```typescript\n@Component({\n  selector: \'app-button-group\'\n  template: `\n    <div>\n      <button [class.active]=\"value===\'male\'\"\n			  (click)=\"value=\'male\'\">male</button>\n      <button [class.active]=\"value===\'female\'\"\n			  (click)=\"value=\'female\'\">female</button>\n    </div>                       \n  `,\n    // 点击高亮的样式\n   styles: [`\n      .active {\n        background: blue;\n        color: white;\n      } `\n  ]\n})                             \n                                  \nexport class ButtonGroupComponent {\n    value=\'male\';\n}\n```\n\n我们的表单：\n\n```typescript\n// a.component.ts\n@Component({\n    selector:\'app-a\',\n    template:`\n		<form [formGroup]=\"form\">\n			<input formControlName=\"username\">\n			<app-button-group formControlName=\'gender\'></app-button-group>\n		</form>\n		<div>form values:{{form.value|json}}</div>\n	`\n})\nexport class AComponent{\n    form: FormGroup;\n    constructor(private fb:FormBuilder){}\n    ngOnInit(){\n        this.form = this.fb.group({\n            username:\'abc\',\n            gender:\'male\'\n        })\n    }\n}\n```\n\n打开控制台，发现报错了：\n\n```js\n ERROR TypeError: dir.valueAccessor.writeValue is not a function\n```\n\n这是因为 Angular 无法操控这个自定义的表单元素，如何让 Angular 可以控制它呢？\n\n需要两步：\n\n1. 将组件注册到 NG_VALUE_ACCESSOR 这个token中。\n2. 实现 ControlValueAccessor 接口。\n\n```typescript\n// button-group.component.ts\n@Component({\n  selector: \'app-button-group\',\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: ButtonGroupComponent,\n      multi: true,\n    }\n  ],\n   ...\n})\nexport class ButtonGroupComponent implements  OnInit,ControlValueAccessor {\n    ...\n}\n```\n\n控制台的错误消失了。可是当我们点击 button 时，什么都没有发生，form.values并没有改变。这是因为，我们并没有在接口的方法中写具体的逻辑。\n\n重要的逻辑有两个：\n\n1. 当组件接收到一个值时，应该做什么。\n2. 当组件的值改变时，应该做什么。\n\n第一个逻辑通过 writeValue 方法来实现：\n\n```typesc\n// button-group.component.ts\nexport class ButtonGroupComponent implements  OnInit,ControlValueAccessor {\n    value:string;\n    writeValue(value:string){\n        this.value = value;\n    }\n}\n```\n\nformControl 会将值通过 writeValue方法传递进组件。\n\n```typescript\n// parent.component.ts \nthis.form = this.fb.group({\n      \'username\': \'zfy\',\n      \'gender\': \'female\', // 将 \'female\'传递给 <app-button-group>...\n });\n\n// button-group.component.ts\n...\n writeValue(value:string){  // value 就是 female\n        this.value = value; // 我们在这里将其赋值给组件自身的value 属性。\n }\n...\n```\n\n组件自身的 value 属性改变了，那么高亮显示的 button 也会相应的改变。因为模板中的逻辑：\n\n```html\n<button [class.active]=\"value===\'male\'\"\n              (click)=\"value=\'male\'\">male\n</button>\n```\n\n但我们点切换点击 button 的时候，发现 form.value 并没有改变。这是因为我们还没有实现第二步：\n\n```typescript\n// button-group.component.ts\n...\nonChange: any;  // 这个属性保存注册的函数\n\n// formControl 会调用这个方法，并传入一个函数 fn，这个函数接收组件内部新的值，并传递给 formControl,formControl将新的值同步,并作些状态检测，校验之类的工作。\nregisterOnChange(fn: any): void {\n    this.onChange = fn;\n}\n```\n\n那么什么时候我们的组件会产生新的值呢，当然是点击 button 的时候。\n\n```typescript\n// button-group.component.ts\n...\n constructor(private eleRef:ElementRef){}\n ngOnInit(): void {\n    // 点击 button时，调用 this.onChange，并将新值作为参数。\n    // 这样， formControl 就可以接收到新值，\n    // formControl 接收到新值， form.values 也会同步\n    this.eleRef.nativeElement.addEventListener(\'click\', e => {\n      const ele = e.target;\n      const nodeName = ele.nodeName;\n      const isBtn = nodeName === \'BUTTON\';\n      isBtn ? this.onChange(this.value) : void 0;\n    });\n  }\n...\n```\n\n所以，关键在于两点：\n\n1. formControl 可以将值传递给你的自定义组件。\n2. 你的新值可以传递给 formControl。\n\n可能你没看出这和 fromControl 有什么关系，其实只要组件的 directive 中有 ngModel,formControl,formControlName这三个指令中的一种，组件就会与一个formControl实例发生关系。\n\n如果有什么问题，欢迎入群交流。\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',2,53),(54,'前端大耍','2018-04-19 03:01:51',NULL,'路由守卫 guard','','### 在 angular 应用中，要实现对页面的访问控制，就需要用到 `guard`。\n\n> 路由守卫是一个很贴切的解释。如果把每个路由（route）当作一条到达页面的通道，那`gurad`就是站在通道前的守卫。只有守卫放行了，你才能穿过通道，到达目的地。\n\n#### 路由守卫的分类\n\n- `CanActivate` 是否可以进入当前路由\n- `CanActivateChild` 是否可以进入当前路由的子路由\n- `CanDeactivate` 是否可以离开当前路由\n- `Resolve` 在进入路由前准备数据\n- `CanLoad` 是否可以进入懒加载的路由（lazyload module）\n\n而要想实现一个路由守卫，并不复杂。\n\n- 首先你要建立一个路由守卫。\n- 然后你要将这个路由守卫添加到privoders数组中。应用中任何需要使用的服务，都需要添加到相应模块的providers数组中。注意，不要将同一个service放入不同的模块中，当然，这是另一个话题。\n- 最后，你要将这个路由守卫放到对应的路由上去。\n\n#### `CanActivate` 是否可以进入当前路由\n\n> 建立路由守卫\n\n```js\nimport { Injectable }     from \'@angular/core\';\nimport { CanActivate }    from \'@angular/router\';\n\n@Injectable()\nexport class AuthGuard implements CanActivate {\n  canActivate() {\n    console.log(\'AuthGuard#canActivate called\');\n    return true;\n  }\n}\n```\n\n> 将路由守卫添加到需要的路由\n\n```js\nimport { AuthGuard }                from \'./auth-guard.service\';\n\nconst adminRoutes: Routes = [\n  {\n    path: \'admin\',\n    component: AdminComponent,\n    canActivate: [AuthGuard], // ---> 添加到 canActivate 数组,可以添加多个守卫\n    children: [\n      {\n        path: \'\',\n        children: [\n          { path: \'crises\', component: ManageCrisesComponent },\n          { path: \'heroes\', component: ManageHeroesComponent },\n          { path: \'\', component: AdminDashboardComponent }\n        ],\n      }\n    ]\n  }\n];\n```\n\n> 将守卫添加到对应模块的 `providers` 中\n\n```js\n@NgModule({\n  imports: [\n    RouterModule.forChild(adminRoutes)\n  ],\n  exports: [\n    RouterModule\n  ],\n  \n  providers:[AuthGuard] // ---> service 必须添加到providers数组中，才能被注入使用\n})\nexport class AdminRoutingModule {}\n```\n\n就这么简单。路由守卫的CanActivate 方法返回true，就表示放行。返回false，你就别想过去了。如果有多个路由守卫，得所有人都点头（都返回true），你才能进去！\n\n\n\n#### `CanActivateChild` 子路由守卫。\n\n> 如果你进入的路由还拥有子路由（children），那么当你进入其任何一个子路由的时候，还需要问子路由守卫同不同意。\n\n实现方法和上面如出一辙，只是换了一个接口。\n\n> 创建路由守卫\n\n```js\nimport { Injectable }     from \'@angular/core\';\nimport { CanActivateChild }    from \'@angular/router\'; //---> 接口改变\n\n@Injectable()\nexport class AuthGuard implements CanActivateChild { //---> 接口改变\n  canActivateChild() {  //---> 方法改变\n    console.log(\'AuthGuard#canActivateChild called\');\n    return true;\n  }\n}\n```\n\n> 添加到路由\n\n```js\nimport { AuthGuard }                from \'./auth-guard.service\';\n\nconst adminRoutes: Routes = [\n  {\n    path: \'admin\',\n    component: AdminComponent,\n    canActivateChild: [AuthGuard], // ---> 添加到 canActivateChild 数组,可以添加多个守卫\n    children: [\n      {\n        path: \'\',\n        children: [\n          { path: \'crises\', component: ManageCrisesComponent },\n          { path: \'heroes\', component: ManageHeroesComponent },\n          { path: \'\', component: AdminDashboardComponent }\n        ],\n      }\n    ]\n  }\n];\n```\n\n> 守卫添加到对应模块的`providers`中\n\n```js\n@NgModule({\n  imports: [\n    RouterModule.forChild(adminRoutes)\n  ],\n  exports: [\n    RouterModule\n  ],\n  \n  providers:[AuthGuard] // ---> service 必须添加到providers数组中，才能被注入使用\n})\n```\n\n**注意：一个路由守卫可以实现多个接口，这样就可以被放置在路由守卫的不同位置。**\n\n```js\n@Injectable()\nexport class AuthGuard implements CanActivate, CanActivateChild {\n  constructor(private authService: AuthService, private router: Router) {}\n\n  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean {\n    let url: string = state.url;\n\n    return this.checkLogin(url);\n  }\n\n  canActivateChild(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean {\n    return this.canActivate(route, state);\n  }\n\n```\n\n> 放置在路由的不同位置，作为不同性质的守卫实用。\n\n```js\nimport { AuthGuard }                from \'./auth-guard.service\';\n\nconst adminRoutes: Routes = [\n  {\n    path: \'admin\',\n    component: AdminComponent,\n    canActivate: [AuthGuard], // ---> 添加到 canActivate 数组\n    canActivateChild: [AuthGuard], // ---> 添加到 canActivateChild 数组\n    children: [\n      {\n        path: \'\',\n        children: [\n          { path: \'crises\', component: ManageCrisesComponent },\n          { path: \'heroes\', component: ManageHeroesComponent },\n          { path: \'\', component: AdminDashboardComponent }\n        ],\n      }\n    ]\n  }\n];\n```\n\n这样，一个守卫只要实现了对应的接口，就可以拥有对应接口的守卫能力。\n\n#### CanDeactive\n\n> 使用场景: 当用户要离开当前页面时,提醒用户是否要保存在当前页面所做的修改.\n\n> 建立 guard\n\n```js\n// can-deactivate-guard.service.ts\nimport { Injectable }    from \'@angular/core\';\nimport { CanDeactivate } from \'@angular/router\';\nimport { Observable }    from \'rxjs/Observable\';\n\nexport interface CanComponentDeactivate {\n canDeactivate: () => Observable<boolean> | Promise<boolean> | boolean;\n}\n\n@Injectable()\nexport class CanDeactivateGuard implements CanDeactivate<CanComponentDeactivate> {\n  canDeactivate(component: CanComponentDeactivate) {\n    return component.canDeactivate ? component.canDeactivate() : true;\n  }\n}\n```\n\n\n\n```js\n// crisis-detail.component.ts\n// ...\n canDeactivate(): Observable<boolean> | boolean {\n    // Allow synchronous navigation (`true`) if no crisis or the crisis is unchanged\n    if (!this.crisis || this.crisis.name === this.editName) {\n      return true;\n    }\n    // Otherwise ask the user with the dialog service and return its\n    // observable which resolves to true or false when the user decides\n    return this.dialogService.confirm(\'Discard changes?\');\n  }\n// ...\n```\n\n\n\n> 将guard添加到对应路由.\n\n```js\nconst routes:Routes = [\n    {\n        path: \':id\',\n        component: CrisisDetailComponent,\n        canDeactivate: [CanDeactivateGuard]\n    },\n]\n```\n\n\n\n> 将guard添加到对应的路由模块的proviaders\n\n```js\n@NgModule({\n  imports: [\n    RouterModule.forRoot(\n      appRoutes,\n    )\n  ],\n  exports: [\n    RouterModule\n  ],\n  providers: [\n    CanDeactivateGuard\n  ]\n})\n```\n\n\n\n#### `CanLoad`\n\n> 如果一个模块时懒加载的,要使用`CanLoad`守卫来控制模块是否可以被加载.这在一些需要权限才可以访问的页面非常有用.如果守卫不同意,受保护模块的代码就不会被加载到本地.\n\n\n\n> 创建守卫,把守卫添加到对应路由,以及路由模块中的providers中.上面已经重复和很多遍.\n\n```js\n// xxx-routing.module.ts\nconst routes:Routes = [\n  //...\n  {\n      path: \'admin\',\n      loadChildren: \'app/admin/admin.module#AdminModule\',\n      canLoad: [AuthGuard]\n  },\n  // ...\n];\n\n@NgModule({\n  // ...\n  providers:[AuthGuard]\n  // ...\n})\n\n// auth-guard.ts\n\nexport class AuthGuard implements CanLoad {\n\n  // ...\n  canLoad(route: Route): boolean {\n    let url = `/${route.path}`;\n\n    return this.checkLogin(url);\n  }\n  \n  // ...\n}\n\n```\n\n\n\n####`resolver`\n\n> 如果需要在路由跳转到目标页面之前，提前获取页面需要的数据，以便在页面展示时能第一时间显示出对应的数据，就需要使用 resolve。\n\n> 建立 resolver\n\n```\n@Injectable()\nexport class CrisisDetailResolver implements Resolve<Crisis> {\n  constructor(private cs: CrisisService, private router: Router) {}\n\n  resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<Crisis> {\n    let id = route.paramMap.get(\'id\');\n\n    return this.cs.getCrisis(id).take(1).map(crisis => {\n      if (crisis) {\n        return crisis;\n      } else { // id not found\n      	// 在 resolver 中也可以重定向\n        this.router.navigate([\'/crisis-center\']);\n        // 记得当没有获取数据的时候也\n        return null;\n      }\n    });\n  }\n}\n```\n\n> 将`resolver`添加到对应的路由：\n\n```\nconst routes:Routes = [\n         {\n            path: \':id\',\n            component: CrisisDetailComponent,\n            // 整个 resolver 的数据会在被设置到ActivatedRoute的data属性中\n            // 路由中的 resolve 可以配置多个 resolver\n            // resolver将返回的数据存储在data对应的字段中(这里是 crisis)\n            resolve: {\n              // 然后在组件中注入的 ActivatedRoute 对象中,\n              // 通过 data的对应字段名称获取对应的数据.\n              crisis: CrisisDetailResolver\n            }\n         },\n];\n\n```\n\n> 将`resolver`加入路由模块的`providers`数组中\n\n```\n@NgModule({\n  ...\n  providers:[CrisisDetailResolver]\n})\n```\n\n> 在 component 中使用\n\n```js\n...\nconstructor(private route:ActivatedRoute){}\nngOnInit() {\n  // 从ActivatedRoute对象的data属性中获取需要的数据\n  this.route.data\n    .subscribe((data: { crisis: Crisis }) => {\n      this.editName = data.crisis.name;\n      this.crisis = data.crisis;\n    });\n}\n...\n```\n\n**注意** resolver 返回的Observable必须complete,否则路由会一直处于等待状态. 具体请查看Rxjs关于Observable的介绍.\n\n\n文中的代码引用自Angular官方网站 https://angular.io/guide/router',1,0,0,'[\"angular\"]',2,55),(55,'前端大耍','2018-04-23 10:24:21',NULL,'Angular 之 named outlet','','>named outlet 顾名思义，就是有名字的 router-outlet。\n\n> 平时我们使用的outlet都是这样的：\n\n```html\n<router-outlet></router-outlet>\n```\n\n> named outlet 是这样的：\n\n```html\n<router-outlet name=\"popup\"></router-outlet>\n```\n\n> 多了个name属性。其实，每一个outlet都有name。我们平时没有写name的outlet，它有一个默认name：primary,相当于：\n\n```html\n<router-outlet name=\"primary\"></router-outlet>\n```\n\n###要这么多outlet有什么用？\n\n> 用处太多了，因为网页中展示的内容不再局限于一个outlet，你可以在网页的不同位置，展示不同的内容。包括但不限于弹出窗口，confirm，还有广告。。。\n\n我想让窗口的右下角出现一个弹窗，里面有四个字：联系客服。重要的是，我需要在任意页面，都可以控制弹窗的出现和隐藏。如何实现？\n\n> 首先，我要在根模板中加入一个named outlet\n\n```html\n// app.component.html\n\n<router-outlet></router-outlet>\n<router-outlet name=\"popup\"></router-outlet>\n```\n\n> 我想让联系客服这个组件出现在 popup 这个outlet中。创建组件：\n\n```js\n@Component({\n    selector:\'app-concat\',\n    template:`<div>联系客服</div>`,\n    styles:[\n        `div{\n			position:fixed;\n			width: 200px;\n			height: 100px;\n			right: 0;\n			bottom: 0;\n			background: #fff;\n		}`\n    ]\n})\nclass ConcatComponent{\n    \n}\n```\n\n> 可以想象，这个组件是比较丑的，这是另外一个话题。接下来，我们既然想让他显示在router-outlet中，肯定要配置路由才是。\n\n```js\n// app-routing.module.ts\n\nconst routes:Routes = [\n    //...\n    {path:\'concat\',component:ConcatComponent,outlet:\'popup\'}\n    //...\n];\n```\n\n> 不要指望手工改变url这个路由就会显示出对应的组件，因为named outlet解析出来的url不一样。先看一下如何添加 link 来指向这个路由。\n\n```html\n// app.component.html\n<a [routerLink]=\"[{outlets:{\'popup\':\'concat\'}}]\">concat</a>\n```\n\n> 意思是，要在name为popup的router-outlet上挂载组件，挂载哪个组件？挂载路由定义中 path 为 concat 的路由指定的组件。\n\n\n\n> 在组件成功显示出来后，剩下的问题就是如何关闭它了。可以在页面上任意位置，包括ConcatComponent内部建立一个关闭按钮。\n\n```html\n<button (click)=\"closePopup()\">\n    close\n</button>\n```\n\n> 对应的方法\n\n```js\nclosePopUp(){\n    this.router.navigate([\n        {outlets:{popup:null}}\n    ])\n}\n```\n\n> 是的，让其显示的路由路径为null，就会清空该路由上挂载的所有组件。你可以用这个特性来实现很多东西！\n\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',2,56),(56,'前端大耍','2018-03-12 15:34:51',NULL,'ng-zorro-antd 项目搭建','','ng-zorro-antd 项目搭建\n\n1. 全局安装 angular-cli。项目使用版本号为 6\n\n```shell\nnpm i -g @angular/cli\nng -v\n\n     _                      _                 ____ _     ___\n    / \\   _ __   __ _ _   _| | __ _ _ __     / ___| |   |_ _|\n   / △ \\ | \'_ \\ / _` | | | | |/ _` | \'__|   | |   | |    | |\n  / ___ \\| | | | (_| | |_| | | (_| | |      | |___| |___ | |\n /_/   \\_\\_| |_|\\__, |\\__,_|_|\\__,_|_|       \\____|_____|___|\n                |___/\n    \n\nAngular CLI: 6.0.0\n```\n\n2. 创建项目\n\n```shell\nng new my-project --style less // 使用 less 样式表\n```\n\n3. 进入项目，安装 ng-zorro-antd。如果你使用的是 0.7版本，需要安装 rxjs-compat做兼容。\n\n```shell\ncd my-project\nnpm install --save ng-zorro-antd\nnpm install --save rxjs-compat\n```\n\n4. 在项目的 src/styles.less 中引入 ng-zorro-antd 样式表\n\n```less\n/* You can add global styles to this file, and also import other style files */\n@import \"../node_modules/ng-zorro-antd/src/ng-zorro-antd.min.css\";\n```\n\n5. 打开 src/app/app.module.ts, 引入 ng-zorro-antd 模块。\n\n```typescript\n@NgModule({\n  declarations: [\n    AppComponent,\n  ],\n  imports: [\n    BrowserModule,\n    NgZorroAntdModule.forRoot(),\n  ],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {\n}\n```\n\n6. 在 AppComponent 中使用组件。\n\n```html\n<button nz-button nzType=\"primary\">\n    button\n</button>\n```\n\n应该正常显示蓝色按钮。\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',2,57),(57,'前端大耍','2018-05-15 15:42:19',NULL,'ngDoCheck','','> 官方文档上是这样解释的：\n>\n> Detect and act upon changes that Angular can\'t or won\'t detect on its own.\n>\n> Called during every change detection run, immediately after `ngOnChanges()` and `ngOnInit()`.\n>\n> 中文官网：\n>\n> 检测，并在发生 Angular 无法或不愿意自己检测的变化时作出反应。\n>\n> 在每个 Angular 变更检测周期中调用，`ngOnChanges()` 和 `ngOnInit()` 之后。\n>\n> \n>\n> 中文文档确实翻译的不咋地，但是好歹我们能看出一些端倪。重点有两个：\n>\n> 1. Angular 自己无法检测到变化时可以做出反应。\n> 2. 在每个 Angular 变更检测周期中调用。\n>\n> 首先看第一点：\n>\n> Angular 自己无法检测到变化时。Angular 还有检测不到变化的时候吗？\n>\n> 有的。下面是个例子：\n\n\n\n```typescript\n// 这个父组件包含两个子组件\n@Component({\n  selector: \'app-optimization\',\n  template: `\n    <app-name-input (add)=\"add($event)\"></app-name-input>\n    <app-employee-list [data]=\"list\"></app-employee-list>\n  `,\n  styles: []\n})\nexport class OptimizationComponent {\n	list: EmployeeData[] = [{name: \'john\', num: 1}];\n \n    add(name: string) {\n        const employee: EmployeeData = {\n          name,\n          num: Math.random(),\n        };\n        this.list.unshift(employee);\n  }\n}\n```\n\n\n\n> 第一个子组件：NameInputComponent\n\n```typescript\n@Component({\n  selector: \'app-name-input\',\n  template: `\n    <div>\n      <input [(ngModel)]=\"name\"\n             (keydown.enter)=\"addEmployee()\">\n    </div>\n  `,\n  styles: []\n})\nexport class NameInputComponent {\n  name: string;\n  @Input() data: EmployeeData[];\n  @Output() add = new EventEmitter();\n\n  addEmployee() {\n    this.add.emit(this.name);\n    this.name = \'\';\n  }\n\n}\n```\n\n> 第二个子组件 EmployeeListComponent\n\n```typescript\n@Component({\n  selector: \'app-employee-list\',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  template: `\n    <ul>\n      <li *ngFor=\"let item of data\">\n        <span>{{item.name}}</span>\n        <span class=\"score\">{{item.num}}</span>\n      </li>\n    </ul>\n  `,\n})\nexport class EmployeeListComponent implements {\n  @Input() data: EmployeeData[] = [];\n}\n```\n\n> 用到的模型：EmployeeData\n\n```typescript\nexport interface EmployeeData {\n  name: string;\n  num: number;\n}\n```\n\n> 当你在input组件中输入字母并敲下回车时，发现新的数据并没有添加到列表中。Angular 没有检测到变化的情况出现了。看一下出现的条件：\n>\n> * 组件使用了 OnPush 的 检测机制。\n> * Componet的 Input 没有发生变化。\n> * 组件内部没有任何事件被触发。\n>\n> 看下源码中的关于 ChangeDetectorRef 的 markForCheck 方法的注释：\n>\n> ```\n> This can be used to ensure an {@link ChangeDetectionStrategy#OnPush OnPush}  component is checked when it needs to be re-rendered but the two normal triggers haven\'t marked it dirty (i.e. inputs haven\'t changed and events haven\'t fired in the view).\n> ```\n>\n> 里面提到了所有的三个条件。\n>\n> 我们的 EmployeeListComponent 组件恰好满足了所有条件：\n>\n> 1. 使用了 OnPush 变更检测机制。\n> 2. Input 属性没有变化。（Angular 使用===检测变化，对象的引用没有改变）\n> 3. 组件内部没有发生事件。（事件是在 NameInputComponent 组件中发生的）\n>\n> 我们要想办法让列表更新才行。这时候 ngDoCheck 这个钩子函数就派上用场了。\n\n```typescript\nexport class EmployeeListComponent  implements OnInit,DoCheck{\n  @Input() data: EmployeeData[] = [];\n  oldLength:number;\n  // 依赖注入 ChangeDetectorRef\n  constructor(private cd: ChangeDetectorRef) {\n  }\n\n  ngOnInit() {\n    // 初始化时保存 data 的 length\n    this.oldLength = this.data.length;\n  }\n\n  ngDoCheck() {\n    // 即使Input属性没有发生变化，最顶层的OnPush Component的 ngDoCheck\n    // 依然会被调用\n    console.log(\'list checked\');\n    // 通过对比 data 现在的 length 和从前的 length，\n    // 来手动触发变更检测\n    if (this.data.length !== this.oldLength) {\n      // 这个方法以会 将本组件以及所有的父组件都标记为 dirty ，\n      // angular就会对这一整个树的组件进行变更检测。\n      this.cd.markForCheck();\n      this.oldLength = this.data.length;\n    }\n  }\n}\n```\n\n> 现在，输入一个名子，回车后，它被添加到列表中了\n>\n> 关于 Angular 的变更检测，知识点真的太多。需要耐心，一点一点去挖。欢迎入群交流。\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',2,58),(58,'前端大耍','2018-07-31 10:07:54',NULL,'ngx-formly（入门）','','表单应该算是 Angular 中最常用也是最重要的部分。但是不管用什么 ui 框架，写起表单来都挺繁琐。 ngx-formly 应运而生。它主要解决了两个问题：\n\n- 繁琐的模板书写工作（搬砖）\n- 灵活可配置的表单选项。\n\n首先，我们需要安装 ngx-formly：\n\n```shell\nnpm install --save @ngx-formly/core  @ngx-formly/bootstrap\n```\n\n然后在应用中引入：\n\n```ts\nimport { NgModule } from \'@angular/core\';\nimport { ReactiveFormsModule } from \'@angular/forms\';\nimport { BrowserModule } from \'@angular/platform-browser\';\nimport { FormlyBootstrapModule } from \'@ngx-formly/bootstrap\';\nimport { FormlyModule } from \'@ngx-formly/core\';\nimport { AppComponent } from \'./app.component\';\n\n@NgModule({\n  declarations: [AppComponent],\n  imports: [\n    BrowserModule,\n    ReactiveFormsModule,  // ngx-formly 依赖 ReactiveFormsModule\n    FormlyModule.forRoot(), // ngx-formly 模块\n    FormlyBootstrapModule,  // 这个也需要引入，它定义了基本的 type\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {}\n\n```\n\n我们看一下使用了 ngx-formly 的表单模板有多简洁：\n\n```html\n <form [formGroup]=\"form\" (ngSubmit)=\"submit(model)\">\n      <formly-form [form]=\"form\" [fields]=\"fields\" [model]=\"model\">\n        <button>Submit</button>\n      </formly-form>\n</form>\n```\n\n要点有三个：\n\n- formly-form 这个组件。\n- 组件的 form 属性，对应当前所在的 FormGroup 对象。\n- 组件的 fields 属性，这是一个配置对象。\n- 组件的 model 属性，相当于 form.value。\n\n我们看下 fields 属性的值\n\n```ts\nfields: FormlyFieldConfig[] = [\n    {\n      key: \'username\',   // FormGroup 对象中的 key\n      type: \'input\',   // 表单元素的类型\n      templateOptions: {\n        label: \'username,  // label 显示的内容\n        required: true  // 必填\n      }\n    },\n    {\n      key: \'password\',\n      type: \'input\',\n      templateOptions: {\n        label: \'用户名\',\n        type: \'password\',  // input 有多种类型，这里可以指定子类型\n        required: true \n      }\n    }\n];\n```\n\nmodel 属性的值：\n\n```ts\nmodel = {\n    username: \'abc\',\n    passwrod: \'123456\'\n};\n```\n\n本文只是一个简单的介绍。具体情况可以在 github 上查看。\n\nhttps://github.com/formly-js/ngx-formly\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',2,59),(59,'前端大耍','2018-08-16 20:16:18',NULL,'ngx-formly 自定义组件以及整合 ng-zorro-antd','','ngx-formly 自定义组件以及整合 ng-zorro-antd\n\n​	前面我们已经说了 ngx-formly 的基本使用，以及校验规则和错误提示如何配置。这次说一下如何整合自定义组件。\n\n​	ngx-formly 已经将 bootstrap ，material， ionic ，primeNG, Kendo 等 UI 框架整合好了，你可以安装并直接使用。如果你使用的不是以上框架，就需要自己整合。\n\n首先我们还是要提在 app.module.ts 中引入ngx-formly的方式\n\n```ts\nFormlyModule.forRoot(config)\n```\n\n重点在这个 config ，它的类型定义为\n\n```ts\nexport interface ConfigOption {\n    types?: TypeOption[];  // 自定义组件放在这个数组中\n    wrappers?: WrapperOption[]; // 自定义组件的包装容器,后面再说\n    validators?: ValidatorOption[]; // 自定义校验器\n    validationMessages?: ValidationMessageOption[]; // 自定义错误提示\n    manipulators?: ManipulatorOption[];\n    extras?: {\n        fieldTransform?: any;\n        showError?: (field: Field) => boolean;\n    };\n}\n```\n\n重点在 types 和 wrappers 属性的定义。\n\n先说 types, 我们定义一个简单的自定义组件：\n\n```\nimport { Component, OnInit } from \'@angular/core\';\nimport { FieldType } from \'@ngx-formly/core\';\n\n@Component({\n  selector: \'app-text-input\',\n  template: `\n  <input [formControl]=\"formControl\"\n         [formlyAttributes]=\"field\">\n  `\n})\nexport class TextInputComponent extends FieldType {}\n```\n\n- 自定义组件需要继承 FieldType\n- 自定义组件模版中的表单元素传入两个属性\n  - formControl  当前元素关联的 FormControl 对象\n  - formlyAttributes  当前元素对应的 FormlyFieldConfig\n\n这两个属性是从父类继承得来：\n\n```TS\nexport declare abstract class FieldType extends Field ...\nexport declare abstract class Field {\n    form: FormGroup;\n    field: FormlyFieldConfig;\n    model: any;\n    options: FormlyFormOptions;\n    readonly key: string;\n    readonly formControl: AbstractControl;\n    readonly to: FormlyTemplateOptions;\n    readonly showError: boolean;\n    readonly id: string;\n    readonly formState: any;\n}\n```\n\n此时，你的自定义 input 已经写好了，只要加入到 config 中就可以使用了。\n\n```ts\nexport const config = {\n  types: [\n    { name: \'textInput\', component: TextInputComponent },\n  ],\n};\n    \n```\n\n在页面中使用它：\n\n```ts\nimport { Component, OnInit } from \'@angular/core\';\nimport { FormGroup } from \'@angular/forms\';\nimport { FormlyFieldConfig } from \'@ngx-formly/core\';\n\n@Component({\n  selector: \'app-three\',\n  template: `\n    <form [formGroup]=\"form\">\n      <formly-form [fields]=\"fields\" [form]=\"form\" [model]=\"model\">\n      </formly-form>\n    </form>\n  `,\n  styleUrls: [\'./three.component.less\']\n})\nexport class ThreeComponent {\n\n  model = { username: \'abc\' };\n  form = new FormGroup({});\n  fields: FormlyFieldConfig[] = [{\n      key: \'username\',\n      type: \'textInput\',  // 注意这里的 type ，需要和配置中的 name 属性对应\n      templateOptions: {\n        label: \'用户名\'\n      }\n    }]\n}；\n\n```\n\n如果使用了 ng-zorro-antd ，只需要在 Input 中加入 nz-input 就可以了，不过要记得安装  ng-zorro-antd 包，并将样式表引入项目中。\n\n\n\n```ts\n\nimport { Component, OnInit } from \'@angular/core\';\nimport { FieldType } from \'@ngx-formly/core\';\n\n@Component({\n  selector: \'app-text-input\',\n  template: `\n  <input nz-input\n       [formControl]=\"formControl\"\n       [formlyAttributes]=\"field\">\n  `\n})\nexport class TextInputComponent extends FieldType {}\n\n```\n\n\n\n但是这个表单元素如何显示 label 之类的元素呢，这就需要用到 wrappers 了。下一次讲如何使用 wrappers。等不及的同学可以自己看一下官方文档，有很详细的介绍。\n\n官方文档传送门：https://formly-js.github.io/ngx-formly/\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',2,60),(60,'前端大耍','2018-09-28 14:36:44',NULL,'ngx-formly自定义校验规则','','ngx-formly自定义校验规则\n\n ngx-formly 入门中已经说了如何使用它创建基本的 form。今天说一下如何添加自定义校验规则和错误提示。\n\n首先看一下我们的需求：\n\n要求：\n\n- 创建一个包含两个输入框的 form。一个用来添写用户名，一个用来添写用户密码。\n- 用户名必添，不能少于6位，首尾空格不算有效字符。\n- 密码必添，不能少于6位，并且当用户名不合格时，处于禁用状态。\n\n先把表单搞起来再说：\n\n```ts\nimport { Component, OnInit } from \'@angular/core\';\nimport { FormGroup, Validators } from \'@angular/forms\';\nimport { FormlyFieldConfig } from \'@ngx-formly/core\';\n\n@Component({\n  selector: \'app-one\',\n  templateUrl: \'./one.component.html\',\n  styleUrls: [\'./one.component.less\']\n})\nexport class OneComponent {\n  form = new FormGroup({});\n  model = {username: \'\', password: \'\'};\n  fields: FormlyFieldConfig[] = [\n    {\n      key: \'username\',\n      type: \'input\',\n      templateOptions: {\n        label: \'用户名\'\n      },\n    },\n    {\n      key: \'password\',\n      type: \'input\',\n      templateOptions: {\n        type: \'password\',\n        label: \'密码\'\n      }\n    }\n  ];\n\n  submit(model) {\n    console.log(model);\n  }\n}\n\n```\n\n要加入校验功能，需要在引入 FormlyModule 时，传入配置对象：\n\n```TS\nFormlyModule.forRoot(config)\n```\n\n我们看下 config 对象如何创建：\n\n- config  是一个对象。\n- 它的 validators 属性是一个数组，每一项都是一个对象，类型定义为：\n\n```ts\nexport interface ValidatorOption {\n    name: string;\n    validation: FieldValidatorFn;\n}\n```\n\n- 它的 validationMessages 属性也是一个数组，用来配置错误提示信息，每一项都是一个对象，类型定义为：\n\n```ts\nexport interface ValidationMessageOption {\n    name: string;\n    message: string | ((error: any, field: FormlyFieldConfig) => string);\n}\n```\n\n目前我们只需要了解这两项就可以自定义错误消息和校验规则了，配置如下：\n\n```TS\nexport const config = {\n  validators: [\n    { name: \'noEmpty\', validation: noEmptyValidator }\n  ],\n  validationMessages: [\n    { name: \'noEmpty\', message: noEmptyMessage },\n    { name: \'minlength\', message: minLengthMessage },\n  ]\n};\n\n// 防止用户输入6个空格\nexport function noEmptyValidator(control: FormControl) {\n  return control.value && control.value.trim().length > 0\n    ? null\n    : { noEmpty: true };\n}\n\nexport function noEmptyMessage(err, field: FormlyFieldConfig) {\n  return `请添写${field.templateOptions.label}`;\n}\n// 虽然 angular 内置了 Validators.minlength 这样的校验器，但是错误信息并没有内置，我们需要\n// 自己实现，并配置进去\nexport function minLengthMessage(err, field: FormlyFieldConfig) {\n  return `${field.templateOptions.label}不能少于${err.requiredLength}位`;\n}\n```\n\n 好了，现在将校验规则添加到我们的 Component 中去：\n\n```ts\nexport class OneComponent {\n  form = new FormGroup({});\n  model = {username: \'\', password: \'\'};\n  fields: FormlyFieldConfig[] = [\n    {\n      key: \'username\',\n      type: \'input\',\n      templateOptions: {\n        label: \'用户名\'\n      },\n      validators: {\n        validation: [\'noEmpty\', Validators.minLength(6)]\n      }\n    },\n    {\n      key: \'password\',\n      type: \'input\',\n      templateOptions: {\n        type: \'password\',\n        label: \'密码\'\n      },\n      validators: {\n        validation: [\'noEmpty\', Validators.minLength(6)]\n      },\n    }\n  ];\n\n  submit(model) {\n    console.log(model);\n  }\n}\n```\n\n现在只剩最后一个需求了，在用户名无效时禁用密码输入。这需要在 FormlyFieldConfig 中配置 expressionProperties 属性。 也就是在 password 的配置里加入这一项，完整代码：\n\n```ts\nimport { Component, OnInit } from \'@angular/core\';\nimport { FormGroup, Validators } from \'@angular/forms\';\nimport { FormlyFieldConfig } from \'@ngx-formly/core\';\n\n@Component({\n  selector: \'app-one\',\n  templateUrl: \'./one.component.html\',\n  styleUrls: [\'./one.component.less\']\n})\nexport class OneComponent {\n  form = new FormGroup({});\n  model = {username: \'\',password: \'\'};\n  fields: FormlyFieldConfig[] = [\n    {\n      key: \'username\',\n      type: \'input\',\n      templateOptions: {\n        label: \'用户名\'\n      },\n      validators: {\n        validation: [\'noEmpty\', Validators.minLength(6)]\n      }\n    },\n    {\n      key: \'password\',\n      type: \'input\',\n      templateOptions: {\n        type: \'password\',\n        label: \'密码\'\n      },\n      validators: {\n        validation: [Validators.minLength(6), \'noEmpty\']\n      },\n      expressionProperties: {\n        \'templateOptions.disabled\': (model: any, formState: any) => {\n          // model 就是 this.model\n          return !(model.username && model.username.trim().length >= 6);\n        }\n      }\n    }\n  ];\n\n  submit(model) {\n    console.log(model);\n  }\n}\n\n```\n\nngx-formly  is awesome, 值得深入学习。\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',2,61),(61,'前端大耍','2018-05-10 22:07:29',NULL,'你了解ngOnChanges吗？','','> 作为 Angular 组件生命周期中的一个重要钩子函数，我们需要着重了解三个核心要素：\n>\n> 1. 什么情况下被调用。\n> 2. 什么时间被调用。\n> 3. 实际项目中如何使用。\n\n\n\n```JS\nimport {Component, Input, OnChanges, OnInit, SimpleChanges} from \'@angular/core\';\n\n@Component({\n  selector: \'app-on-change\',\n  template: `\n    <div>\n      <label>parent:</label><input type=\"text\" [(ngModel)]=\"value\" >\n      <app-on-change-child [value]=\"value\"></app-on-change-child>\n    </div>`\n})\nexport class OnChangeComponent implements OnInit {\n  // 父组件的 value 属性不是外部传入的，不是 [input] 属性\n  value = \'a\';\n\n  constructor() {\n  }\n\n  ngOnInit() {\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    console.group(\'parent ngOnChanges called.\');\n    console.log(changes);\n    console.groupEnd();\n  }\n\n}\n\n@Component({\n  selector:\'app-on-change-child\',\n  template:`<label>child:</label><input type=\"text\" [value]=\"value\">`\n})\nexport class OnChangeChildComponent implements OnChanges {\n  // 子组件的 value 属性是外部传入的，是一个 【input】 属性\n  @Input() value = \'\';\n\n  ngOnChanges(changes: SimpleChanges): void {\n    console.group(\'child ngOnChanges called.\');\n    console.log(changes);\n    console.groupEnd();\n  }\n\n}\n```\n\n> 在parent input 中输入 \'aaa\',输出如下,其中 changes 是一个对象，它的 key 就是组件中发生改变的 input property，value 是一个 SimpleChange 类型的对象。SimpleChange 对象包含3个字段：\n>\n> 1. previousValue: 发生改变之前的值。\n> 2. currentValue: 发生改变之后的值。\n> 3. firstChange:  值是否是第一次改变。\n\n![2018-05-10下午7_15_001539794840255.png](http://pghicsch6.bkt.clouddn.com/2018-05-10下午7_15_001539794840255.png)\n\n> 什么是 [input] 属性？官网对 ngOnChanges 的说明：\n>\n> Respond when Angular (re)sets data-bound **input properties**. The method receives a `SimpleChanges` object of current and previous property values.\n>\n> Called before `ngOnInit()` and whenever one or more data-bound **input properties** change.\n>\n> 也就是说，只有当设置数据绑定的**输入属性**时，以及**输入属性**绑定的数据发生改变时，才会调用此函数。\n>\n> 这就解释了为什么当在父组件的输入框中输入数据时，并不会调用父组件的 ngOnChanges 方法，因为父组件中的 value 属性并不是一个 **input property**。而子组件因为将父组件的 value 作为输入数据，绑定在自身上， 这个 value 是个 **input property** ，所以会做出响应，调用自己的 ngOnChanges 方法。\n>\n> 所以，看起来很简单的东西，也可能并不是想象中的那样。\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',2,62),(62,'前端大耍','2018-05-18 14:22:58',NULL,'Angular 依赖注入','','> 什么是依赖注入？\n>\n> 通过**注入器**将创建一个对象所需要的**依赖**注入到这个对象的方法中，通常是构造方法。\n>\n> 官网上的例子很简明，我们可以分析一下：\n\n```js\nexport class Car {\n\n  public engine: Engine;\n  public tires: Tires;\n  public description = \'No DI\';\n\n  constructor() {\n    this.engine = new Engine();\n    this.tires = new Tires();\n  }\n\n  // Method using the engine and tires\n  drive() {\n    return `${this.description} car with ` +\n      `${this.engine.cylinders} cylinders and ${this.tires.make} tires.`;\n  }\n}\n```\n\n> 这是一个没有使用依赖注入的类，它有几个问题：\n>\n> 1. 以正常的思路来看，造车是需要造引擎的，毕竟没有引擎车就不能算一辆完整的车。\n> 2. 但是实际上，一种车可能有多种类型的引擎，更合理的思路是，造车时需要给我一个引擎。Car并不关心引擎是如何制造的。\n> 3. 可惜目前造引擎这个过程被写死在造车的过程中，这会导致以下问题：\n>    1. 车和引擎绑定了，这种类型的车就只能用这种引擎。\n>    2. 如果引擎的构造函数修改了（增加了一个参数），Car的代码也要修改。\n>    3. 这个引擎可能被很多种 Car 使用，这意味着所有的Car类都要随着引擎的修改而修改。\n>    4. 这只是一个引擎而已。还有轮胎，变速箱。。。任何部件的改变，都需要修改Car的代码\n>    5. 这将是一个维护噩梦。\n>\n> 我们需要一个解决方案，首先，将依赖分离出去：\n\n```js\nexport class Car {\n	constructor(public engine: Engine, public tires: Tires) { }\n}\n```\n\n> 现在，Car 不负责引擎及轮胎的创建了，它们作为参数传入Car的构造函数。这是合理的，想要造车，你得有引擎和轮胎。\n\n```js\nlet car = new Car(new Engine(), new Tires());\n```\n\n> 我们看一下，如果引擎的构造函数变了，会怎样：\n\n```\nclass Engine {\n  // 增加了一个代表汽缸数的参数\n  constructor(public cylinders: number) { }\n}\n// Car 类的代码不需要修改\nlet car = new Car(new Engine(4), new Tires());\n```\n\n> 如果我们想换个本田3缸引擎，可能更省油些：\n\n```\nclass HongDaEngine extends Engine{\n    constructor(public cylinders:number){}\n}\n\nlet car = new Car(new HongDaEngine(3),new Tires());\n```\n\n> 可以看到，依赖分离出去后，Car 类变得非常灵活，代码也非常稳定。\n>\n> 但这仅仅是分离，注入是什么？\n\n```js\nlet car = injector.get(Car);\n```\n\n> 这就是实现了依赖注入后的代码。\n>\n> 如何实现的呢？\n>\n> 1. 你的代码运行在一个容器中。比如说 Angular 应用。\n> 2. 对象不是你自己通过 new 创建的。比如 Component。\n> 3. 容器帮你创建对象，但是你要保证类的构造函数接收的参数都是**可注入**的。\n\n### 什么是可注入？\n\n> 首先，在Angular应用中，可注入的对象类型需要使用 @Injectable() 来标注。\n\n```js\nimport { Injectable } from \'@angular/core\';\n\n@Injectable({\n  providedIn: \'root\',\n})\nexport class UserService {\n  constructor() { }\n}\n```\n\n> 其次，需要将其添加到 module 或 component 的 providers 数组中：\n\n```js\nproviders: [\n  UserService,\n],\n```\n\n> 然后，你就可以在对应作用域中使用它进行依赖注入\n\n```js\n@Component({...})\nexport class UserComponent{\n   constructor(public readonly userService:UserService){}\n}\n```\n\n> UserService 中也可以注入别的依赖\n\n```js\nimport { Injectable } from \'@angular/core\';\n\n@Injectable({\n  providedIn: \'root\',\n})\nexport class MessageService {\n  constructor() { }\n}\n\n@Injectable({\n  providedIn: \'root\',\n})\nexport class UserService {\n  constructor(private readonly messageService: MessageService) { }\n}\n```\n\n> 实现依赖注入的示意图\n\n```\n1. Angular 创建 UserComponet,发现构造函数中有依赖。依赖的类为 UserService.\n\n2. Angular使用注入器获取 UserService: injector.get(UserService)\n\n3. 在providers数组中寻找 UserService 类，并创建 UserService 类的实例。// 我省略了一些关于单例的步骤。\n\n4. 创建 UserService 实例时，发现构造函数有依赖,依赖的类为 MessageService.\n\n5. Angular使用注入器获取 MessageService: injector.get(MessageService)\n\n6. 在providers数组中寻找 MessageService 类，并创建 MessageService 类的实例。// 我省略了一些关于单例的步骤。\n\n7. 成功创建 MessageService 实例。\n8. 成功创建 UserService 实例。\n9. 成功创建 UserComponent 实例。\n```\n\n> 这只是一个基本的实现原理。实际情况要复杂些。比如，在创建一个可注入的实例之前会检查是否已经在当前作用域创建过了，如果创建过，就返回已经创建的实例，不会再重新创建。\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',2,63),(63,'前端大耍','2018-05-07 21:38:27',NULL,'动态创建 Component','','> 动态创建Component，其实并不难，是你太悲观～\n>\n> 我们只需要了解三要素：\n>\n> 1. ViewContainerRef  动态组件就在这个东西内部创建。\n> 2. ComponentFactoryResolver 创建一个ComponentFactory\n> 3. ComponentRef 你动态创建了组件之后，对这个组件的引用。\n\n\n\n> 下面我们来创建一个动态组件。\n\n```js\nimport {Component, ComponentFactoryResolver, OnInit, ViewChild, ViewContainerRef} from \'@angular/core\';\nimport {HelloComponent} from \'./hello/hello.component\';\nimport {HiComponent} from \'./hi/hi.component\';\nimport {LoveComponent} from \'./love/love.component\';\nimport {AngularComponent} from \'./angular/angular.component\';\n\n@Component({\n  selector: \'app-root\',\n  template:\n      `\n    <h1> Dynamic Component Demo</h1>\n    <template #template></template>\n  `\n})\nexport class AppComponent implements OnInit {\n   // 注意，第一要素：ViewContainerRef 出现了\n  @ViewChild(\'template\', {read: ViewContainerRef}) template: ViewContainerRef;\n  componentArr = [\n    HelloComponent,   // ng g c hello\n    HiComponent,	  // ng g c hi\n    LoveComponent,    // ng g c love\n    AngularComponent  // ng g c angular\n  ];\n  index = 0;\n  // 注意，第二要素：ComponentFactoryResolver 出现了\n  constructor(private componentFactoryResolver: ComponentFactoryResolver) {\n  }\n\n  ngOnInit(): void {\n    this.loadComponent();\n    this.loop();\n  }\n\n  loadComponent() {\n    // 选择一个 component class\n    const component = this.componentArr[this.index++];\n    // 你也可以用取余实现，这样比较直观\n    if (this.index > this.componentArr.length - 1) {\n      this.index = 0;\n    }\n    // ComponentFactoryResolver 创建 ComponentFactory\n    const componentFactory =\n      this.componentFactoryResolver\n        .resolveComponentFactory(component);\n\n    // 清除容器内部的所有内容，this.template 就是一个 ViewContainerRef\n    this.template.clear();\n    // 容器需要接收一个 ComponentFactory 来创造组件的实例，返回一个引用。\n    // 注意，第三要素：ComponentRef 出现了\n    const componentRef = this.template.createComponent(componentFactory);\n    // 你可以 通过 instance属性 来访问 componentRef 内部的component实例\n    console.log(componentRef.instance);\n    // componentRef.instance.title = \'haha\' 前提是这个组件有title属性，并且为public\n    console.log(\'abc\');\n  }\n\n  loop() {\n    setInterval(() => this.loadComponent(), 1000);\n  }\n}\n\n```\n\n> 简单来说，就是我们先要获取一个ViewContainerRef的实例，然后调用它的createComponent 方法来创建组件，但是这个方法需要接收一个 ComponentFactory, 而ComponentFactory 需要通过 ComponentFactoryResolver来创建。\n>\n> 当你终于将代码写完去运行时，发现控制台报错了，心里开始骂娘。其实你忘了将那四个动态创建的组件加入到 AppModule 的 entryComponents 数组中。\n\n```js\n@NgModule({\n  declarations: [\n    AppComponent,\n    DynamicDirective,\n    HelloComponent,\n    HiComponent,\n    LoveComponent,\n    AngularComponent\n\n  ],\n  imports: [\n    BrowserModule\n  ],\n  entryComponents: [\n    HelloComponent,\n    HiComponent,\n    LoveComponent,\n    AngularComponent\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {\n}\n```\n\n> 动态组件华丽的运行着，你的心里思考着为什么这东西这么简单。\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',2,64),(64,'前端大耍','2018-04-28 09:29:24',NULL,'在 Angular 中使用 websocket','','> websocket 可以实现服务端和客户端的双向数据推送。在一些实时性要求高的业务中，不可或缺。那么如何在Angular应用中使用websocket呢？今天，我们先从原理说起。\n\n\n\n> 首先，你要有一个websocket服务器。对于 JavaScript 来说，实在过于简单。\n>\n> 第一步，创建一个文件夹，命名为server。 在文件夹中运行：\n\n```js\nnpm init -y\nnpm install --save ws\n```\n\n> ws是nodejs中一个实现websocket的库，有了它就可以很方便的创建websocket服务。下面是我们的服务器代码： index.js。因为代码实在太简单，就没有使用 ts 的必要了。\n\n```js\n// index.js\nconst WebSocket = require(\'ws\');\n \nconst wss = new WebSocket.Server({ port: 8080 });\n \nwss.on(\'connection\', function connection(ws) {\n  ws.on(\'message\', function incoming(message) {\n    console.log(\'received: %s\', message);\n    ws.send(message);\n  });\n \n  ws.send(\'something\');\n});\n```\n\n> 启动服务器\n\n```js\nnode index.js\n```\n\n> 此时控制台不应该有任何输出，否则，请检查代码。\n\n\n\n> 服务端已经准备就绪，就等客户端访问了。使用 @angular/cli 创建客户端代码。\n\n```js\nng new client\n```\n\n> 创建一个service，负责处理 websocket 请求。\n\n```\nng g service websocket --module app\n```\n\n> 下面是 WebsocketService 的实现。\n\n```js\nimport {Injectable} from \'@angular/core\';\nimport {Observable} from \'rxjs/Observable\';\nimport {retryWhen, tap} from \'rxjs/operators\';\nimport {timer} from \'rxjs/observable/timer\';\n\n@Injectable()\nexport class WebsocketService {\n\n  message$: Observable<MessageEvent>;\n  private URL = \'ws://localhost:8080\';\n  private ws: WebSocket;\n\n  constructor() {\n    this.message$ = this.create();\n  }\n\n  sendMessage(message: string) {\n    this.ws.send(message);\n  }\n\n  private create() {\n\n    const observable = Observable.create(observer => {\n      if (!this.ws) {\n        // 如果没有建立过连接，才建立连接并且添加时间监听\n        this.ws = new WebSocket(this.URL);\n        this.ws.onopen = () => console.log(\'websocket connected\');\n        this.ws.onmessage = msg => observer.next(msg);\n        this.ws.onerror = e => {\n          throw new Error(\'webSocket connection error:\');\n        };\n        // 我们需要保持websocket连接始终在打开状态，所以当断开时，要抛出错误，\n        // 然后在错误处理中重新连接\n        this.ws.onclose = (e) => {\n          throw new Error(\'webSocket connection closed:\');\n        };\n      }\n    });\n    // 这里注意 retryWhen 的用法\n    return observable.pipe(\n      // 在控制台输出错误信息\n      tap(err => console.log(err)),\n      // 3秒后重试\n      retryWhen(\n        () => timer(3000)\n      )\n    );\n  }\n}\n```\n\n> 在 AppComponent 中使用。 \n\n```js\nimport {Component, OnInit} from \'@angular/core\';\nimport {WebsocketService} from \'./websocket.service\';\n\n@Component({\n  selector: \'app-root\',\n  template: `\n    <ul>\n      <li *ngFor=\"let msg of messages\">{{msg}}</li>\n    </ul>\n\n    <p *ngIf=\"error\">{{error | json}}</p>\n    <p *ngIf=\"completed\">completed!</p>\n\n\n    <input type=\"text\"\n           #message>\n    <button (click)=\"send(message.value);message.value=\'\';\">send</button>\n  `,\n  styleUrls: [\'./app.component.css\']\n})\nexport class AppComponent implements OnInit {\n  messages = [];\n  error: any;\n  completed = false;\n\n  constructor(private webSocketService: WebsocketService) {\n  }\n\n  ngOnInit(): void {\n    this.webSocketService.message$.subscribe(\n      msg => this.messages.push(msg.data),\n      err => this.error = err,\n      () => this.completed = true\n    );\n  }\n\n  send(message: string) {\n    this.webSocketService.sendMessage(message);\n  }\n}\n\n```\n\n> 运行客户端\n\n```\nnpm start\n```\n\n> 运行截图\n\n![2018-04-28下午3_49_461539794956406.png](http://pghicsch6.bkt.clouddn.com/2018-04-28下午3_49_461539794956406.png)\n\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',2,65),(65,'前端大耍','2018-05-17 17:43:15',NULL,'typescript中的工厂模式','','# 工厂模式\n\n> 最近在看Angular源码的时候，发现里面大量使用了工厂模式。如果不好好研究一下这种设计模式，还真是举步维坚。\n>\n> 首先我们得知道，为什么要使用工厂模式，有以下几个要素：\n\n\n\n* 需要创建某种类的实例。工厂需要产出实例。Angular 中大量的Componet，Directive都是通过工厂模式创建的。\n\n```typescript\nexport abstract class ComponentFactory<C> {\n  abstract get selector(): string;\n  abstract get componentType(): Type<any>;\n  /**\n   * selector for all <ng-content> elements in the component.\n   */\n  abstract get ngContentSelectors(): string[];\n  /**\n   * the inputs of the component.\n   */\n  abstract get inputs(): {propName: string, templateName: string}[];\n  /**\n   * the outputs of the component.\n   */\n  abstract get outputs(): {propName: string, templateName: string}[];\n  /**\n   * Creates a new component.\n   */\n  abstract create(\n      injector: Injector, projectableNodes?: any[][], rootSelectorOrNode?: string|any,\n      ngModule?: NgModuleRef<any>): ComponentRef<C>;\n}\n```\n\n\n\n* 对用户隐藏创建对象的细节。用户操作的是创建出来的对象，只需要知道这个对象有什么功能，不用知道这个对象是如何创建的。比如你只需要知道在 Component 中如何写代码，不需要知道Component 的创建过程。\n* 程序在编写时并不知道要创建什么类型的对象，在运行时才知道。比如 Angular 框架在编写时，并不知道你要创建什么类型的对象，是一个 Component,还是一个Directive，或者是一个Pipe。是在运行时通过 metadata里的数据来动态创建的。\n* 你可以在需求变化时，更改工厂内部创建对象的逻辑，而不会影响到那些使用对象的代码。\n\n\n\n> Angular 的工厂模式运用的很夸张，就连工厂都是通过工厂创建的。\n\n```typescript\nexport abstract class ComponentFactoryResolver {\n  static NULL: ComponentFactoryResolver = new _NullComponentFactoryResolver();\n  abstract resolveComponentFactory<T>(component: Type<T>): ComponentFactory<T>;\n}\n```\n\n> 你可以看到上面两个类都是抽象类，意味着它们还会有不同的实现。比如 一个报告 Component 没找到的 ComponetFactoryResolver:\n\n```js\nclass _NullComponentFactoryResolver implements ComponentFactoryResolver {\n  resolveComponentFactory<T>(component: {new (...args: any[]): T}): ComponentFactory<T> {\n    throw noComponentFactoryError(component);\n  }\n}\n\nexport function noComponentFactoryError(component: Function) {\n  const error = Error(\n      `No component factory found for ${stringify(component)}. Did you add it to @NgModule.entryComponents?`);\n  (error as any)[ERROR_COMPONENT] = component;\n  return error;\n\n```\n\n> 另一个创建ComponentFactory的 ComponentFactoryResolver\n\n```typescript\nexport class CodegenComponentFactoryResolver implements ComponentFactoryResolver {\n  private _factories = new Map<any, ComponentFactory<any>>();\n\n  constructor(\n      factories: ComponentFactory<any>[], private _parent: ComponentFactoryResolver,\n      private _ngModule: NgModuleRef<any>) {\n    for (let i = 0; i < factories.length; i++) {\n      const factory = factories[i];\n      this._factories.set(factory.componentType, factory);\n    }\n  }\n\n  resolveComponentFactory<T>(component: {new (...args: any[]): T}): ComponentFactory<T> {\n    let factory = this._factories.get(component);\n    if (!factory && this._parent) {\n      factory = this._parent.resolveComponentFactory(component);\n    }\n    if (!factory) {\n      throw noComponentFactoryError(component);\n    }\n    return new ComponentFactoryBoundToModule(factory, this._ngModule);\n  }\n}\n```\n\n> 总的来说，如果你只关注对象的功能，希望将对象的使用和创建逻辑解耦，可以使用工厂模式。这样带来的好处是，当创建对象的逻辑改变时，不会影响使用到对象的那些 “客户端” 代码。而且因为创建对象的逻辑独立出来，你可以控制对象的创建过程，在创建前或创建后做一些额外的工作。\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"typescript\"]',2,66),(66,'前端大耍','2018-04-15 10:30:56',NULL,'如何同时查看同一个 git 仓库两个分支（或更多）的代码','','## git worktree\n\n```bash\ngit worktree add -b <新分支名> <新路径> <从此分支创建>\n```\n\n## 场景\n\n目录 project 是项目仓库。在此仓库的 A 分支上开发，布署。现在创建一个 B 分支，对代码进行优化和重构，过程中可能要经常对两个分支的代码进行比对和修改。这时可以使用 git worktree 创建一个新目录，相当于 clone 了一份项目代码。这样就可以同时在编辑器中打开A分支和B分支的代码了。\n\n那和 clone 有什么不同？\n\n不同处在于，两个文件夹其实共享了 .git 目录。所以它们的分支状态，文件改动是实时同步的。不需要你 pull。\n\n## 删除 worktree\n\n删除之前记得将修改合并到对应分支上\n\n```shell\ngit worktree list\n\ngit worktree remove [path]\n```\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"other\"]',2,67),(67,'前端大耍','2018-04-14 20:51:27',NULL,'git仓库共享文件夹','','> 场景：公司有两个代码仓库，一个是pc端前端代码，一个是mobile端的。这两个仓库中，有很多公共库及其相似，但是在两个仓库中各自持有。有没有办法将存放公共库的文件夹在两个仓库中共享，同时，对公共代码库的修改可以同步到两个仓库的文件夹中？使用git submodule 就可以实现。\n\n## git submodule\n\n> 建立一个公共代码库，存放共享代码。\n\n```\n// 假设仓库地址为 http://example.com/public-repo.git\nmkdir public-repo\ncd public-repo \ngit init \n```\n\n\n\n> 进入pc端代码仓库。\n\n```\ncd pc-project\ngit submodule add http://example.com/public-repo.git\ngit status \n// 将会显示刚刚添加的子模块里的文件\nYour branch is up-to-date with \'origin/master\'.\n\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n	new file:   .gitmodules\n	new file:   ...\n\ngit add . // 你需要将新文件的变化保存到当前项目中\n\ngit commit -m \'add submodule\'\n\ngit push origin master // 将改变推送到远程仓库\n```\n\n> 当别人克隆这个项目时，子模块文件夹将被克隆下来，但是里面没有任何文件。\n>\n> 要想同步子模块中的代码，有两种方法：\n\n```\n// 第一种方法\ncd pc-project\ngit submodule init\ngit submodule update\n```\n\n>  第二种方法，拉取包含子模块的仓库时，传递一个额外的参数:—recursive,它会自动初始化并更新仓库中的每一个子模块。\n\n```\n// 第二种方法，推荐使用。\ngit clone --recursive http://example.com/pc-project.git\n```\n\n> 如果公共代码库的代码修改了，如何同步到本地？\n\n```\n// 第一种方法：\n\ncd pc-project\ncd public-repo\ngit fetch\ngit merge\n\n// 第二种方法\n\ncd pc-project\ngit submodule update --remote public-repo\n\n// 第三种方法\ncd pc-project\ngit submodule update --remote // 更新所有子模块\n```\n\n> 子模块的更新和普通git仓库代码更新是一样的，你也可以切换分支，没有区别。\n\n```\ncd pc-project\ncd public-repo\ngit checkout stable // 假设子模块有这样一个分支\n\n// do something ...\n```\n\n> 如果你想在推送pc-project的时候，将子模块的改变也一起推送（而不是进入每个子模块单独进行推送），只需要加入参数。注意，子模块需要先将改动commit 。\n\n```\ngit push --recurse-submodules=on-demand\n// git 会进入子模块并推送子模块所作的提交，如果子模块推送失败，那么主项目也会推送失败。\n```\n\n\n\n在本篇文章中介绍了git子模块的核心用法，更加详细深入的了解，请参考：\n\ngit 子模块：(https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97)\n\n\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"other\"]',2,68),(68,'前端大耍','2018-04-30 21:52:39',NULL,'Ngrx Action 命名规范','','> 此建议来自 ng-conf [参考链接](https://www.youtube.com/watch?v=JmnsEvoy-gY)，演讲者是 ngrx 的贡献者之一。他在大会上提出了构建可维护应用中如何定义 Action 的几条核心原则。\n>\n> 一、 不要复用 Action。\n>\n> 二、使用具有描述性的 Action Type。\n>\n> 三、避免 Action 分类型。\n>\n> 四、注重简洁明了。\n>\n> 五、换位思考。\n>\n> 六、先写出 action。\n\n\n\n------\n\n\n\n> 使用具有描述性的 Action Type。\n>\n> 下面是一个简单的 Action 结构：\n\n```js\ninterface ModUser{ \n    type: \'modUser\';\n    payload:any;\n}\n```\n\n> 首先，modUser 可能被不同的页面触发。打开控制台后，我们看到一堆 Action，但是并不知道这些 Action 是在什么地方被触发的。所以，我们要给 Action 的 type 加入上下文：context。\n\n```js\ninterface ModUser{ \n    type: \'[UserPage] modUser\';\n    payload:any;\n}\n```\n\n> 其中 type 属性中的 [UserPage] ，就是上下文。 这样，当我们在控制台追踪 Action 的时候，可以很轻易的知道，这个 Action 是在 UserPage 触发的。\n\n> 其次，我们要能很清晰的从 action type 中看出这个 Action 对应的操作类型:增删改查。上面的例子中 ModUser 并不能明确的表明意图。 可能是更新，也可能是删除。更好的方式是：\n\n```js\ninterface UpdateUser{\n	type: \'[UserPage] updateUser\', \n	payload: any;\n}\n```\n\n> 经过修改，我们可以很清晰的得知，这是UserPage 触发的一个 Action，目的是更新用户。\n\n> 如果按照这种方式来组织 Action 的话，岂不是 Action 的数量要翻倍？原来只要一个 updateUser 就可以了，现在我需要 [UserPage] updateUser, [AnotherPage] updateUser, [ThirdPage] updateUser ? 而我的 reducer 也会变成这样：\n\n```js\nconst userReducer = (state:User,action:Action) => {\n    switch( action.type){\n        case :\'[UserPage] updateUser\':\n        case :\'[AnotherPage] updateUser\':\n        case: \'[ThirdPage] updateUser\':\n            return {...state,...action.payload}\n    }\n}\n```\n\n> 没错，这个倒是真的。项目的代码会膨胀起来。但是，你要做出选择，是在将来辛苦的 debugger 寻找 action 的出处，还是一眼就可以看出来。这也正对应了第一点原则：不要复用 Action。\n\n---\n\n> 三、避免 Action 分类型。\n>\n> 还是一个简单的例子：\n\n```js\ninterface AddItem{\n    type: \'[CartPage] addItem\',\n    kind: \'food|toy\'\n}\n```\n\n>因为 AddItem 这个 Action 可能会添加一种食物，也可能添加一种玩具。我们的 reducer 要根据 kind 将数据更新到不同的 state 中。\n\n```js\nconst cartReducer = (state:any,action: Action) => {\n    switch(action.type){\n        case \'[CartPage] addItem\':\n            // not good\n            if(action.kind===\'food\') {//doSomething ...}\n           \n    }\n}\n```\n\n> 如果我们还有 Effect ，也需要添加判断\n\n```js\nclass CartApiEffects{\n    @Effect() addItem$ = \n        this.action$\n		.ofType(\'[CartPage] addItem\')\n		.pipe(\n        	filter(action=>action.kind===\'food\')\n    	)					\n}\n```\n\n> 试想如果任由这种风格蔓延，代码将变得多么难以维护。所以，避免使用 Action 分类型，我们完全可以用更简明的方式来解决。\n\n```js\ninterface AddFood{\n    type: \'[CartPage] addFood\'\n}\ninterface AddToy{\n    type: \'[CartPage] addToy\'\n}\n// reducer\nconst cartReducer = (state:any,action: Action) => {\n    switch(action.type){\n        case \'[CartPage] addFood\':\n            // do something ...\n        case \'[CartPage] addToy\':\n            // do something ...\n           \n    }\n}\n// effect\nclass CartApiEffects{\n    @Effect() addFood$ = \n        this.action$\n		.ofType(\'[CartPage] addFood\')				\n}\n```\n\n---\n\n\n\n> 注重简洁明了和换位思考其实一个意思。ngrx 为你处理了大部分底层的东西，你只要写出简单的 action，reducer，effect 就好。保持他们的简洁与清晰。这样，在别人维护你的代码时，或者你维护遵循这些原则的程序员所写的代码时，会轻松愉快。\n\n---\n\n> 先写出 action。\n>\n> 这其实是一个需求到达后，我们如何去设计代码，组织代码的一个类似草稿的概念。比如说要实现页面的登录，我们可以先进行以下 action 的规划。\n\n```js\n// 用户操作触发的 action\n[login Page] Login\n// 与服务器交互的 action\n[Auth API] Login Success\n[Auth API] Login Failure\n// 与设备相关的 action\n[WebSocket] Open\n[WebSocket] Disconnected\n```\n\n> 预先规划 action 可以帮助我们深入到需求的细节当中，对每一种交互有完整的解决流程，在写代码时逻辑更加清晰。\n\n> 全文完。\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"other\"]',2,69),(69,'前端大耍','2018-04-23 15:08:16',NULL,'RxJS 之 Observable','','> 相信每一个刚接触RxJS的人，都会有些困惑。从今天开始，我们来一点点揭开她的神秘面纱。\n\n\n\n> Observable 是什么？引用原作者的话：\n>\n> **Observables are a function that take an observer and return a function.**\n>\n> 也就是说，Observable 是一个函数，它接收一个observer作为参数，然后返回一个函数。\n\n```js\nfunction Observable(observer){\n    \n    return () => 1;\n}\n// 这就是一个Observable\n```\n\n\n\n> observer  是什么？\n>\n> 一个包含了 next, error, complete 方法的对象。\n\n```js\nconst observer = {\n    next: data => console.log(\'data\',data),\n    error: error => console.error(\'error\',error),\n    complet: () => console.log(\'complete\')\n}\n// 这是一个Observer\n```\n\n\n\n> observer 在 Observable 中起了什么作用？完善一下我们的 Observable\n\n```js\nfunction Observable(observer){\n    \n    const body = document.body;\n    body.addEventListener(\'mousemove\', e=>observer.next(e));\n    body.addEventListener(\'click\', e => observer.error(e));\n    body.addEventListener(\'dbclick\',() => observer.complete());\n    \n    return () => body.removeEventListener(...) // remove EventLisnters\n}\n```\n\n\n\n> 可以看到，observable内部给 body绑定了事件监听函数。 每当 body 上触发了事件，相应的事件监听函数就会调用observer的方法，并传入event对象（生产出来的数据）作为参数。至于如何处理数据，是由observer 的next，error，以及complete方法指定的。这个observerble如何使用？\n\n```js\nObservable(observer);\n// 开始点击body。。\n```\n\n\n\n> 可以看到，Observable 确实只是一个函数。不去调用它的时候，它就安静的待在那里，没有运行，没有给body添加事件监听，就是安静的待着。只有当被调用的时候，它才会给body添加事件监听。监听到事件后，事件监听函数会调用observer对应的方法。 那么，Observable 到底有什么职责？\n\n\n\n> 首先，Observable 可以发射数据。\n\n\n\n> 其次，Observable 需要接收一个 observer，才能被真正激活。要记得，他是一个函数，调用以后才能执行。接收到一个observer后，他内部的producer才真正被创建，开始生产并发射数据。这些数据处理按照一定规则传递给observer对应的方法，再由observer的方法去处理。Observable要指明内部的数据应当如何传递给observer，以及传递给observer的哪个方法。\n\n\n\n> 最后，Observable的返回值是一个函数。这个函数的作用是让Observable内部的producer停止生产数据。在本文中就是停止body对事件的监听。这样，observable不会再有新的数据传递给observer，observer也不会再执行自己的next等方法。如何使用？\n\n```js\nconst subscription = Observable(observer);\n\nsubscription() // Observable停止发射数据。\n```\n\n\n\n\n\n> 为什么没有看到subscribe方法？\n>\n> 本文只是对observable原理的解析。并不是真正的Observable实现。官方实现中要考虑程序的健壮性，功能性，实现会复杂很多。但是，只要了解了原理，学习起来就会很快。\n\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"rxjs\"]',2,70),(70,'前端大耍','2018-03-10 12:55:11',NULL,'Operators','','虽然RxJS的基础是`Observable`，但是它的精髓在于`Operator`。`Operator`是实现有条理的管理异步代码的关键。\n\n## 什么是`Operator`\n\n`Operators`是`Observable`类型对象的方法，比如`.map(...)`,`.filter(...)`,`.merge(...)`,等等。当这些方法被调用时，并不会改变原始的`Observable`,而是返回一个新的`Observable`.新的`Observable`的执行逻辑以初始的`Observable`为基础.\n\n> 一个`Operator`是一个`function` ,它创建以初始`Observable`为基础的一个新的`Observable`,这是一个纯粹的操作:初始的`Observable`并不会改变.\n\n`Operator`本质上是一个纯函数,以一个`Observable`为输入,生成一个新的`Observable`作为输出.对输出的`Observable`进行`subscribe`,将会导致输入的`Observable`也被`subscribe`.在下面的例子中,我们新建了一个自定义的`Operator`,它把作为输入的`Observable`提交的每个值乘以10.\n\n```\nfunction multiplyByTen(input) {\n var output = Rx.Observable.create(function subscribe(observer) {\n   input.subscribe({\n     next: (v) => observer.next(10 * v),\n     error: (err) => observer.error(err),\n     complete: () => observer.complete()\n   });\n });\n return output;\n}\n\nvar input = Rx.Observable.from([1, 2, 3, 4]);\nvar output = multiplyByTen(input);\noutput.subscribe(x => console.log(x));\n```\n输出:\n```\n10\n20\n30\n40\n```\n注意对输出的`Observable`的`subscribe`会导致输入的`Observable`被`subscribe`.我们称之为\"Operator subscribe chain\"(操作符订阅链).\n\n##Instance operators versus static operators(实例操作符和静态操作符)\n\n**什么是instance operator?** 通常提到`operators`,我们认为是`Observable`实例上的`instance operator`.举例来说,如果 `multiplyByTen`操作符是一个正式的操作符,它大概是下面的样子:\n\n```\nRx.Observable.prototype.multiplyByTen = function multiplyByTen() {\n var input = this;\n return Rx.Observable.create(function subscribe(observer) {\n   input.subscribe({\n     next: (v) => observer.next(10 * v),\n     error: (err) => observer.error(err),\n     complete: () => observer.complete()\n   });\n });\n}\n```\n> `instance operator`是内部的`this`指向输入的`Observable`的函数.\n\n注意作为输入的`input Observable`不再做为函数的参数,它被认为是`this`指向的对象.这是我们为什么能够像下面这样调用它的原因.\n\n```\nvar observable = Rx.Observable.from([1, 2, 3, 4]).multiplyByTen();\n\nobservable.subscribe(x => console.log(x));\n```\n**什么是`static operator`?**和`instance operator`不同,`static operator`是直接绑定在`Observable`类上面的方法.`static operator`内部不使用`this`,它的执行完全取决于传递过来的参数.\n\n> `static operator`是绑定在`Observable`类上的纯函数,通常用来创建一个`Observable`.\n\n最常见的`static operator`是所谓的`creation operator`.和转换一个`input observable`到一个`output observable`不同,他们接收一个非`Observable`参数,像数字,字符串等,然后创建一个新的`Observable`.\n\n`static operator`的一个典型的例子是`interval operator`.它接受一个数字作为输入参数,然后创建并输出一个`Observable`.\n\n```\nvar observable = Rx.Observable.interval(1000 /* number of milliseconds */);\n```\n另一个`creation operator`的例子是我们在前面的例子中大量使用过的`create`.\n\n尽管如此,`static operator`除了简单的`create`,还有很多其他的类型.一些组合操作符可能是静态的,比如`merge`,`concat`,`combineLatest`,等等.他们之所以是静态操作符,原因在于他们以多个`Observable`作为输入,而不只是一个.例如:\n```\nvar observable1 = Rx.Observable.interval(1000);\nvar observable2 = Rx.Observable.interval(400);\n\nvar merged = Rx.Observable.merge(observable1, observable2);\n```\n\n##choose an operator\n\n你是否在寻找一个你需要的操作符?先从下面的列表中选择一项:\n\n* 我有一个`Observable`,而且......\n* 我有一些`Observables`需要组合成一个`Observable`,而且......\n* 我现在没有`Observable`,而且......\n\n##categories of operators\n\n不同的操作符有不同的目的,他们可以被分为:创建,转换,过滤,组合,错误处理,基础工具等等.\n\n\n\n本系列文章均翻译自:http://reactivex.io/rxjs/manual/overview.html',1,0,0,'[\"rxjs\"]',2,72),(71,'前端大耍','2018-04-24 16:11:38',NULL,'Rxjs 之 asObservable','','> 什么意思？Rxjs里不都是Observable么？为什么需要这个操作符？\n\n\n\n```js\nconst interval = Observable.interval(1000);\n\ninterval.asObservable().subscribe(x=>console.log(1));\n\n// 你期望的是：\n// logs\n// 0\n// 1\n// 2\n// ...\n// 然而实际上是：\n// Uncaught TypeError: interval.asObservable is not a function\n```\n\n> 普通的Observable是没有这个方法的。本来就是一个Observable，再包含一个把自己当作Observable的方法？没有人会这样设计代码。其实这个方法只存在于一种特殊的Observable上面，它就是Subject。\n\n```js\nconst subject = new Subject();\n\nsubject.subscribe(x=>console.log(x));\n\nsubject.next(1);\n// 1\nsubject.next(2);\n// 2\n```\n\n> 看起来有点自娱自乐的赶脚。确实是，这家伙既是 Observable，又是 Observer。看：\n\n```js\nsubject.next(3);\n// 3\nsubject.error(\'error!\')\n// Uncaught \'error!\'\nsubject.complete();\n// undefined\n```\n\n> 这不是observer是什么，observer 不就是有三个方法么？它都有。而asObservable操作符就是让它老老实实的做个Observable，砍掉它的Observer能力。\n\n```js\nconst observable = subject.asObservable();\nobservable.next();\n// Uncaught TypeError: observable.next is not a function\n```\n\n> 现在好了，他不能自娱自乐了。问题是，为什么要这样对他？给我一个理由！\n\n```js\n// websocket.service.ts\nclass WebSocketService {\n 	subject = new Subject();\n    constructor(){\n        // ... \n        websocket.onmessage = data => this.subject.next(data);\n    }\n}\n// in some file\nthis.websocketService.subject.subscribe(data=>{ /* do something with data */});\n                  \n// 来了一个搞破坏的\nthis.websocketService.subject.next(\'haha!\');\n        \n```\n\n> 我们如何限制这种情况的出现？subject被暴露出来后，代码中任何地方都可以调用它的next方法！\n\n\n\n```\n// websocket.service.ts\nclass WebSocketService {\n 	private subject = new Subject();\n    constructor(){\n        // ... \n        websocket.onmessage = data => this.subject.next(data);\n    }\n    get(){\n        return this.subject.asObservable();\n    }\n}\n// in some file\nthis.websocketService.get().subscribe(data=>{ /* do something with data */});\n                  \n// 来了一个搞破坏的\nthis.websocketService.subject.next(\'haha!\');\n// error! subject is private !\nthis.websocketService.get().next(\'haha!\');\n// Uncaught TypeError: ...next is not a function\n```',1,0,0,'[\"rxjs\"]',2,73),(72,'前端大耍','2018-04-29 04:17:43',NULL,'使用 pm2 管理你的node应用','','> 上一篇文章介绍了如何使用 nginx 来代理你的node应用。在实际项目中，不建议直接使用 node index.js 这样的方式来启动服务。推荐使用 pm2。\n\n```shell\nnpm install -g pm2\n```\n\n> 注意，有的同学在安装全局包的时候，会遇到权限问题。这时候不要使用sudo来安装，会引发很多问题。一种办法是改变全局包所在目录的权限。一种是将npm全局安装目录设置为当前用户目录的 node_modules 。我选择的是后者。如果没有遇到问题，请忽略下面步骤。\n\n```shell\nnpm config set prefix ~/node_modules\n```\n\n> 查看是否设置成功\n\n```shell\nnpm config get prefix \n\n// /home/your_user_name/node_modules\n```\n\n> 在全局安装后，如果发现命令行敲 pm2 ，提示命令不存在，那说明没有把npm全局包的bin目录加入到PATH 中。如果已经正常输出 pm2 介绍，请忽略下面步骤。\n\n```shell\nvi ~/.bash_profile\n```\n\n> 在最后加入下面这行。\n\n```shell\nPATH=$PATH:~/node_modules/bin  \n```\n\n> 最后，还要刷新文件。\n\n```shell\nsource ~/.bash_profile\n```\n\n> 再次运行 pm2\n\n```shell\n$ pm2 -v\n2.10.3\n```\n\n> 先停掉正在运行的 nodejs 应用。 可能有的同学上次连接了服务器，开启node应用后，就从服务器登出了。这次连接后，不知道怎么停掉服务器。如果不先停掉运行着的node应用，再次开启就会报错，因为端口已经被占用了。可以通过命令行来查看并杀死进程。\n\n```shell\n$ netstat -lnp|grep 8080\n(Not all processes could be identified, non-owned process info\n will not be shown, you would have to be root to see it all.)\ntcp6  	0  	0	 :::8080     :::*      LISTEN      9750/node /home/user \n```\n\n> 可以看到端口被 node 占用了，pid 是 9750，杀掉这个进程就可以了。\n\n```shell\nkill 9750\n```\n\n> 使用pm2运行你的 node 应用\n\n```shell\npm2 start path/to/yourserver/app.js --name app1\n```\n\n> 停止你的应用，参数为应用名称，也就是 —name 传入的参数\n\n```shell\npm2 stop app1\n```\n\n> 重启你的应用\n\n```shell\npm2 restart app1\n```\n\n> 查看日志\n\n```shell\npm2 logs\n```\n\n> 查看资源占用\n\n```shell\npm2 monit\n```\n\n> 查看所有应用的列表\n\n```shell\npm2 list\n```\n\n\n\n> pm2 还有监视模式，当服务器文件发生改变时，自动重启。更多详细信息请查看pm2官方文档。\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"other\"]',2,75),(73,'前端大耍','2018-03-20 11:57:07',NULL,'在 centos 7 上使用 nginx 代理你的 node 服务','','> 经常，我们一个服务器上不只有一个应用。我们可以通过给不同的应用设置不同的监听端口，通过nginx把请求转发给对应的应用。假设你是管理员用户，不用打那么多 sudo。\n>\n> 首先安装 nginx\n\n```\nyum install nginx\n```\n\n>安装后启动服务\n\n```\nservice nginx start\n```\n\n> 查看是否启动成功\n\n```\ncurl localhost\n```\n\n> 如果启动成功，会展示一段 HTML 字符。否则会报错。\n>\n> 现在准备我们的node应用。新建文件夹 app\n\n```js\n// index.js\nconst http = require(\'http\')\n\nconst server = http.createServer((req,res)=>{\n  res.writeHead(200,{\'Content-Type\':\'text/plain\'})\n  res.end(\'Welcome to Node.js!\');\n});\n\nserver.listen(8080);\n\nconsole.log(\'Server running at port %d\',8080);\n```\n\n> 启动你的应用：\n\n```\nnode index.js\n```\n\n> 测试应用是否已经启动：\n\n```\ncurl localhost:8080\n```\n\n>  看到 Welcome to Node.js!  说明已启动。\n>\n> 下面就该将应用配置到 Nginx 中去了。\n\n```\ncd /etc/nginx/conf.d\n```\n\n> 新建文件 app.conf\n\n```\nvi app.conf\n```\n\n> 输入以下内容 ，将 server_name 设置为你服务器的域名,proxy_pass 的端口设置为你的应用监听的端口。\n\n```\nserver{\n  listen 80;\n  server_name www.example.com;\n  location /{\n    proxy_pass http://127.0.0.1:8080/;\n    proxy_set_header Host $host;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_set_header  X-Real_IP $remote_addr;\n    proxy_set_header X-Forwarded-Proto $scheme;\n  }\n}\n```\n\n> 这样还是不行的，还需要修改另一个文件。\n\n```\nvi /etc/nginx/nginx.conf\n```\n\n> 将 http 中的 server 给去掉，改完后 http 属性是下面的样子\n\n```\nhttp {\n    log_format  main  \'$remote_addr - $remote_user [$time_local] \"$request\" \'\n                      \'$status $body_bytes_sent \"$http_referer\" \'\n                      \'\"$http_user_agent\" \"$http_x_forwarded_for\"\';\n\n    access_log  /var/log/nginx/access.log  main;\n\n    sendfile            on;\n    tcp_nopush          on;\n    tcp_nodelay         on;\n    keepalive_timeout   65;\n    types_hash_max_size 2048;\n\n    include             /etc/nginx/mime.types;\n    default_type        application/octet-stream;\n\n    # Load modular configuration files from the /etc/nginx/conf.d directory.\n    # See http://nginx.org/en/docs/ngx_core_module.html#include\n    # for more information.\n    include /etc/nginx/conf.d/*.conf;\n    \n    # server 被我删掉了，否则它监听80端口，将请求引导到 nginx 的欢迎页面。\n}\n```\n\n> 测试配置文件是否有效\n\n```\nnginx -t\nnginx: the configuration file /etc/nginx/nginx.conf syntax is ok\nnginx: configuration file /etc/nginx/nginx.conf test is successful\n```\n\n> 说明配置没有问题。重启nginx 服务\n\n```\nservice nginx reload\n```\n\n> 打开客户端的浏览器，访问你的域名。看到 Welcome to Node.js ! 你就成功了。\n\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"other\"]',2,76),(74,'前端大耍','2018-07-09 23:17:52',NULL,'项目组统一代码格式：Prettier','','为了统一项目内的代码格式，我们使用 Prettier。\n\n下载 prettier 插件。\n\n- vscode\n\n```shell\next install prettier-vscode\n```\n\n> 注意：如果你已经安装了其它的格式化工具，比如 beautify ，请先卸载，可能会有冲突。\n\n- webstorm下载  prettier 插件（2018.1 以后的版本自带，idea 需要下载）\n\n在项目中安装 prettier，你也可以全局安装。\n\n```shell\nnpm i prettier --save-dev \n```\n\n> 如果使用了 typescript 或者在做 Angular 项目 ，可以安装 prettier 的 typescript 配置。\n\n```shell\nnpm i -D tslint-config-prettier\n```\n\n> 在 tslint.json 中添加配置\n\n```json\n{\n  \"extends\": [\n    \"other configs ...\",\n    \"tslint-config-prettier\"\n  ]\n}\n```\n\n重启 ide，在 vscode 中 cmd+shift+p ，输入 Format Document，格式化代码。在 webstorm 中 Find Action,输入 Reformat With Prettier，格式化代码。\n\n\n\n你可以在项目根目录新建 `.prettierrc`文件，来配置格式化选项，不配就会使用默认值。\n\n```json\n{\n    \"tabWidth\": 4,\n    \"useTabs\": false,\n    \"singleQuote\": true\n}\n```\n\n\n\n> vscode 参考：https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode\n\n> webstorm 参考：https://plugins.jetbrains.com/plugin/10456-prettier\n\n> 为什么使用 prettier 参考：\n\n> https://alexjoverm.github.io/2017/06/12/Use-Prettier-with-TSLint-and-be-happy/\n\n> https://blog.fundebug.com/2017/10/23/format-code-use-Prettier/\n\n> https://juejin.im/post/5a791d566fb9a0634853400e\n\n> https://zhuanlan.zhihu.com/p/28195771\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"typescript\",\"other\"]',2,78),(75,'前端大耍','2018-05-31 09:46:22',NULL,'JSON 转 TypeScript Interface','','TypeScript 大法好。\n\n但是每次将后端返回的 json 转成 interface ，真的心好累！\n\n可是，现在有了 quicktype ！\n\n你可以直接在浏览器中打开它的网站，在线将 json 转成你喜欢的类型，包括 TypeScript Interface , Java 类，Go 结构体 。。。。\n\n这个地址就是： \n\n```js\nhttps://app.quicktype.io/\n```\n\n这里是它的 git 仓库\n\n```\nhttps://github.com/quicktype/quicktype\n```\n\n你可以通过 npm 安装它：\n\n```\nnpm install -g quicktype\n```\n\n这是后端返回的 json:\n\n```json\n{\n  \"name\": \"How To Live Forever\",\n  \"artist\": {\n    \"name\": \"Michael Forrest\",\n    \"founded\": 1982,\n    \"members\": [\n      \"Michael Forrest\"\n    ]\n  },\n  \"tracks\": [\n    {\n      \"name\": \"Get Connected\",\n      \"duration\": 208\n    }\n  ]\n}\n```\n\n转换成 typescript interface:\n\n```js\nexport interface Album {\n    name:   string;\n    artist: Artist;\n    tracks: Track[];\n}\n\nexport interface Artist {\n    name:    string;\n    founded: number;\n    members: string[];\n}\n\nexport interface Track {\n    name:     string;\n    duration: number;\n}\n\n```\nEnjoy yourself! \n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"other\"]',2,80),(76,'前端大耍','2018-06-04 03:56:16',NULL,'FormArray','','在 Angular 中，使用 formArray 的地方很多，比如 checkbox，只要你想在 form 中提交数组类型的值，就需要使用它。更常见的是动态添加表单项。比如表单中可以添加多个收货地址，多个联系人信息等。\n\n我们直接说如何在后一种情况下使用 FormArray。\n\n情景：表单可以动态添加收货地址。每当点击 【添加】按钮，就会出现一个新的输入框。\n\n```html\n<form [formGroup]=\"myForm\">\n   <div formArrayName=\"addresses\">\n       <div *ngFor=\"let address of addresses.controls;let i=index\">\n           <input [formControlName]=\"i\">\n       </div>\n    </div>\n    <button (click)=\"add($event)\">\n        add\n    </button>\n</form>\n```\n\n这里要注意三点：\n\n1. 声明一个拥有 formArrayName 指令的父元素。\n2. 用 *ngFor 循环得出每一个 formControl 对应的输入框。\n3. 每个输入框的 formControlName 是循环中的 index。（0,1,2 ,数组下标)\n\nts 文件中，需要创建 FormGroup 和 FormArray 实例:\n\n```typescript\n...\nmyForm: FormGroup;\nconstructor(private fb: FormBuilder) {\n    this.myForm = this.fb.group({\n        addresses:this.fb.array([[\'\',Validators.required]])\n    })\n}\n\nget addresses(){\n    return this.myForm.get(\'addresses\') as FormArray;\n}\nadd(event){\n    event.preventDefault();\n    this.addresses.push(new FormControl(\'\',Validators.required))\n}\n```\n\nformArray 也可以由多个 formGroup 组成.\n\n```html\n<form [formGroup]=\"myForm\">\n    <div formArrayName=\"addresses\">\n        <div *ngFor=\"let address of addresses.controls;let i=index;\"\n             [formGroupName]=\"i\">\n            <input formControlName=\"city\">\n            <input formControlName=\"street\">\n        </div>\n    </div>\n</form>\n```\n\nts:\n\n```typescript\n...\nconstructor(private fb: FormBuilder) {\n    this.myForm = this.fb.group({\n        addresses: this.fb.array([\n            this.fb.group({\n                city:\'\',\n                street:\'\'\n            })\n        ])\n    })\n}\n\nget addresses(){\n    return this.myForm.get(\'addresses\') as FormArray;\n}\n\nadd(event){\n    event.preventDefault();\n    const newGroup = this.fb.group({\n        city:[\'\',Validators.required],\n        street:\'\',\n    });\n    this.addresses.push(newGroup);\n}\n```\n\n动态添加表单项在 angular 中非常简单。Enjoy ！\n\r转载请注明出处：www.hijavascript.com',1,1,0,'[\"angular\"]',2,81);
/*!40000 ALTER TABLE `article_entity` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `article_statistics_entity`
--

DROP TABLE IF EXISTS `article_statistics_entity`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `article_statistics_entity` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `enjoy` int(11) NOT NULL,
  `view` int(11) NOT NULL,
  `stored` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=82 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article_statistics_entity`
--

LOCK TABLES `article_statistics_entity` WRITE;
/*!40000 ALTER TABLE `article_statistics_entity` DISABLE KEYS */;
INSERT INTO `article_statistics_entity` VALUES (1,7,21,0),(2,7,73,0),(3,0,3,0),(4,12,12,0),(5,5,10,0),(6,16,40,0),(7,10,9,0),(8,0,18,0),(9,9,4,0),(10,0,2,0),(11,0,2,0),(12,0,2,0),(13,0,2,0),(14,0,2,0),(15,0,3,0),(16,0,2,0),(17,8,6,0),(18,17,12,0),(19,0,4,0),(20,12,4,0),(21,0,2,0),(22,0,3,0),(23,0,2,0),(24,0,2,0),(25,0,2,0),(26,0,2,0),(27,0,2,0),(28,0,2,0),(29,0,2,0),(30,0,2,0),(31,0,2,0),(32,0,2,0),(33,0,3,0),(34,0,1,0),(35,0,0,0),(36,0,0,0),(37,4,2,0),(38,0,0,0),(39,0,0,0),(40,0,0,0),(41,0,0,0),(42,0,0,0),(43,13,2,0),(44,0,0,0),(45,0,2,0),(46,0,0,0),(47,0,0,0),(48,0,0,0),(49,0,0,0),(50,0,0,0),(51,0,0,0),(52,0,0,0),(53,0,0,0),(55,0,0,0),(56,0,0,0),(57,0,0,0),(58,0,0,0),(59,6,6,0),(60,7,2,0),(61,4,53,0),(62,0,0,0),(63,0,0,0),(64,0,0,0),(65,0,0,0),(66,9,2,0),(67,0,0,0),(68,0,0,0),(69,16,3,0),(70,0,0,0),(72,0,0,0),(73,0,0,0),(75,0,2,0),(76,0,2,0),(78,13,4,0),(80,0,0,0),(81,0,0,0);
/*!40000 ALTER TABLE `article_statistics_entity` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `comment_entity`
--

DROP TABLE IF EXISTS `comment_entity`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `comment_entity` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) NOT NULL,
  `userId` int(11) NOT NULL,
  `createdAt` varchar(255) NOT NULL,
  `content` text NOT NULL,
  `enjoy` int(11) NOT NULL,
  `articleId` int(11) NOT NULL,
  `isDeleted` tinyint(4) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `comment_entity`
--

LOCK TABLES `comment_entity` WRITE;
/*!40000 ALTER TABLE `comment_entity` DISABLE KEYS */;
INSERT INTO `comment_entity` VALUES (1,'sxlwar',1,'2018-10-21 21:19:54','这个东西的学习成本高吗',0,60,0);
/*!40000 ALTER TABLE `comment_entity` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `comment_reply_entity`
--

DROP TABLE IF EXISTS `comment_reply_entity`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `comment_reply_entity` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `createdAt` varchar(255) NOT NULL,
  `content` text NOT NULL,
  `fromUser` varchar(255) NOT NULL,
  `userId` int(11) NOT NULL,
  `toUser` varchar(255) NOT NULL,
  `commentId` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `FK_35e40df9c91cf2632dd8db5e867` (`commentId`),
  CONSTRAINT `FK_35e40df9c91cf2632dd8db5e867` FOREIGN KEY (`commentId`) REFERENCES `comment_entity` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `comment_reply_entity`
--

LOCK TABLES `comment_reply_entity` WRITE;
/*!40000 ALTER TABLE `comment_reply_entity` DISABLE KEYS */;
/*!40000 ALTER TABLE `comment_reply_entity` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user_entity`
--

DROP TABLE IF EXISTS `user_entity`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
 SET character_set_client = utf8mb4 ;
CREATE TABLE `user_entity` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `githubId` int(11) NOT NULL,
  `account` varchar(255) NOT NULL,
  `email` varchar(255) NOT NULL,
  `name` varchar(255) NOT NULL,
  `avatar` varchar(255) NOT NULL,
  `isAdmin` tinyint(4) NOT NULL DEFAULT '0',
  `isLogout` tinyint(4) NOT NULL DEFAULT '0',
  `storedArticles` varchar(255) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user_entity`
--

LOCK TABLES `user_entity` WRITE;
/*!40000 ALTER TABLE `user_entity` DISABLE KEYS */;
INSERT INTO `user_entity` VALUES (1,20088392,'sxlwar','sxlwar@163.com','sxlwar','https://avatars3.githubusercontent.com/u/20088392?v=4',1,0,'[]'),(2,14977369,'hackzfy','','z.x.x','https://avatars2.githubusercontent.com/u/14977369?v=4',1,1,'[]'),(3,38906041,'hungyim','','music','https://avatars2.githubusercontent.com/u/38906041?v=4',0,0,'[]');
/*!40000 ALTER TABLE `user_entity` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2018-10-22 15:11:41
